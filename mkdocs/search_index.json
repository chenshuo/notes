{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-mkdocs",
            "text": "For full documentation visit  mkdocs.org .",
            "title": "Welcome to MkDocs"
        },
        {
            "location": "/#commands",
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.",
            "title": "Commands"
        },
        {
            "location": "/#project-layout",
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.",
            "title": "Project layout"
        },
        {
            "location": "/bugs/",
            "text": "GCC\n\n\nBug 54812\n: \nprivate\n \n=default\n destructor is \npublic\n\n\nDelete expression doesn't respect access of defaulted destructor\n\n\nstruct Base\n{\n private:\n  ~Base() = default;\n};\n\nint main()\n{\n  Base* p = new Base;\n  delete p;\n}\n\n\n\n\n\n\nQuote:\n The bug affects protected destructors too, and they're commonly used for base classes to prevent deletion via pointer-to-base.\n\n\n\n\nFixed in 4.9.0, by \nr203985\n.\nTest case added by \nr204057\n.\n\n\nGlibc\n\n\nstrstr(3)\n\n\nSince glibc 2.9, strstr(3) may use \nTwo Way algorithm\n in some cases, but the impl. had several bugs:\n\n\n\n\nBug 12092\n\n\nBug 12100\n\n\nBug 14602\n\n\nMore?\n\n\n\n\nKernel\n\n\nwrite(2)\n not thread-safe\n\n\nFixed in v3.14, released in 2014-03-30. Ubuntu 14.04 has this bug, Debian 8 doesn't.\n\n\ncommit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4\nAuthor: Linus Torvalds <torvalds@linux-foundation.org>\nDate:   Mon Mar 3 09:36:58 2014 -0800\n\n    vfs: atomic f_pos accesses as per POSIX\n\n    Our write() system call has always been atomic in the sense that you get\n    the expected thread-safe contiguous write, but we haven't actually\n    guaranteed that concurrent writes are serialized wrt f_pos accesses, so\n    threads (or processes) that share a file descriptor and use \"write()\"\n    concurrently would quite likely overwrite each others data.\n\n    This violates POSIX.1-2008/SUSv4 Section XSI 2.9.7 that says:\n\n     \"2.9.7 Thread Interactions with Regular File Operations\n\n      All of the following functions shall be atomic with respect to each\n      other in the effects specified in POSIX.1-2008 when they operate on\n      regular files or symbolic links: [...]\"\n\n    and one of the effects is the file position update.\n\n    This unprotected file position behavior is not new behavior, and nobody\n    has ever cared.  Until now.  Yongzhi Pan reported unexpected behavior to\n    Michael Kerrisk that was due to this.\n\n    This resolves the issue with a f_pos-specific lock that is taken by\n    read/write/lseek on file descriptors that may be shared across threads\n    or processes.\n\n    Reported-by: Yongzhi Pan <panyongzhi@gmail.com>\n    Reported-by: Michael Kerrisk <mtk.manpages@gmail.com>\n    Cc: Al Viro <viro@zeniv.linux.org.uk>\n    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>\n\n\n\n\n$ man 2 write\n\n\nBUGS\n       According  to  POSIX.1-2008/SUSv4  Section XSI 2.9.7 (\"Thread Interactions\n       with Regular File Operations\"):\n\n           All of the following functions shall be atomic with  respect  to  each\n           other  in  the  effects specified in POSIX.1-2008 when they operate on\n           regular files or symbolic links: ...\n\n       Among the APIs subsequently listed are write() and writev(2).   And  among\n       the  effects  that  should  be  atomic  across threads (and processes) are\n       updates of the file offset.  However, on Linux before version  3.14,  this\n       was  not  the  case:  if two processes that share an open file description\n       (see open(2)) perform a write() (or writev(2)) at the same time, then  the\n       I/O operations were not atomic with respect updating the file offset, with\n       the result that the blocks of data  output  by  the  two  processes  might\n       (incorrectly) overlap.  This problem was fixed in Linux 3.14.",
            "title": "Bugs"
        },
        {
            "location": "/bugs/#gcc",
            "text": "",
            "title": "GCC"
        },
        {
            "location": "/bugs/#bug-54812-private-default-destructor-is-public",
            "text": "Delete expression doesn't respect access of defaulted destructor  struct Base\n{\n private:\n  ~Base() = default;\n};\n\nint main()\n{\n  Base* p = new Base;\n  delete p;\n}   Quote:  The bug affects protected destructors too, and they're commonly used for base classes to prevent deletion via pointer-to-base.   Fixed in 4.9.0, by  r203985 .\nTest case added by  r204057 .",
            "title": "Bug 54812: private =default destructor is public"
        },
        {
            "location": "/bugs/#glibc",
            "text": "",
            "title": "Glibc"
        },
        {
            "location": "/bugs/#strstr3",
            "text": "Since glibc 2.9, strstr(3) may use  Two Way algorithm  in some cases, but the impl. had several bugs:   Bug 12092  Bug 12100  Bug 14602  More?",
            "title": "strstr(3)"
        },
        {
            "location": "/bugs/#kernel",
            "text": "",
            "title": "Kernel"
        },
        {
            "location": "/bugs/#write2-not-thread-safe",
            "text": "Fixed in v3.14, released in 2014-03-30. Ubuntu 14.04 has this bug, Debian 8 doesn't.  commit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4\nAuthor: Linus Torvalds <torvalds@linux-foundation.org>\nDate:   Mon Mar 3 09:36:58 2014 -0800\n\n    vfs: atomic f_pos accesses as per POSIX\n\n    Our write() system call has always been atomic in the sense that you get\n    the expected thread-safe contiguous write, but we haven't actually\n    guaranteed that concurrent writes are serialized wrt f_pos accesses, so\n    threads (or processes) that share a file descriptor and use \"write()\"\n    concurrently would quite likely overwrite each others data.\n\n    This violates POSIX.1-2008/SUSv4 Section XSI 2.9.7 that says:\n\n     \"2.9.7 Thread Interactions with Regular File Operations\n\n      All of the following functions shall be atomic with respect to each\n      other in the effects specified in POSIX.1-2008 when they operate on\n      regular files or symbolic links: [...]\"\n\n    and one of the effects is the file position update.\n\n    This unprotected file position behavior is not new behavior, and nobody\n    has ever cared.  Until now.  Yongzhi Pan reported unexpected behavior to\n    Michael Kerrisk that was due to this.\n\n    This resolves the issue with a f_pos-specific lock that is taken by\n    read/write/lseek on file descriptors that may be shared across threads\n    or processes.\n\n    Reported-by: Yongzhi Pan <panyongzhi@gmail.com>\n    Reported-by: Michael Kerrisk <mtk.manpages@gmail.com>\n    Cc: Al Viro <viro@zeniv.linux.org.uk>\n    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>  $ man 2 write  BUGS\n       According  to  POSIX.1-2008/SUSv4  Section XSI 2.9.7 (\"Thread Interactions\n       with Regular File Operations\"):\n\n           All of the following functions shall be atomic with  respect  to  each\n           other  in  the  effects specified in POSIX.1-2008 when they operate on\n           regular files or symbolic links: ...\n\n       Among the APIs subsequently listed are write() and writev(2).   And  among\n       the  effects  that  should  be  atomic  across threads (and processes) are\n       updates of the file offset.  However, on Linux before version  3.14,  this\n       was  not  the  case:  if two processes that share an open file description\n       (see open(2)) perform a write() (or writev(2)) at the same time, then  the\n       I/O operations were not atomic with respect updating the file offset, with\n       the result that the blocks of data  output  by  the  two  processes  might\n       (incorrectly) overlap.  This problem was fixed in Linux 3.14.",
            "title": "write(2) not thread-safe"
        },
        {
            "location": "/git/",
            "text": "Notes on Git\n\n\nData model\n\n\n\n\nblob\n is content of file\n\n\n\n\n$ git cat-file -p 74576250e3c3a901bf06832bd0e4ee5e00422115\n# Shuo's notes\nhttp://chenshuo.github.io/notes\n\n\n\n\n\n\ntree\n has one or more \ntree\n/\nblob\n, it's \nMerkle tree\n.\n\n\nblob\n are leaf nodes\n\n\ntree\n are internal nodes\n\n\n\n\n\n\n\n\n$ git cat-file -p 5d42664e3d812288b47795718d0e4faf26397bf9\n100644 blob cde88fe0e10f265ed3cb2af0ea5422f607c1a37c    .gitignore\n100644 blob 74576250e3c3a901bf06832bd0e4ee5e00422115    README.md\n040000 tree eabff4ee0b30f5d6a644ce508ba7fe47dc563aa4    docs\n100644 blob 020682e2399c75cf3ad9636964c7501f27a0e893    mkdocs.yml\n\n\n\n\n\n\ncommit\n:\n\n\nhas one \ntree\n\n\nhas one or more parent \ncommit\n(s)\n\n\n\n\n\n\n\n\n$ git cat-file -p 3f08891b366c750d4739241874cfb1dbef56c398\ntree 5d42664e3d812288b47795718d0e4faf26397bf9\nparent 955f683cae5d2514d1c788fce9206451e2ac3334\nauthor Shuo Chen <chenshuo@chenshuo.com> 1484903215 -0800\ncommitter Shuo Chen <chenshuo@chenshuo.com> 1484903215 -0800\n\nupdate ssl.md\n\n\n\n\n\n\n\n\ntag\n ???\n\n\n\n\n\n\nExceptions:\n\n\n\n\ninitial \ncommit\n has no parent\n\n\nempty file is empty \nblob\n\n\nempty directory is empty \ntree\n\n\n\n\n\n\n\n\nPack file format\n\n\nDelta\n\n\nPack index format",
            "title": "Git"
        },
        {
            "location": "/git/#notes-on-git",
            "text": "",
            "title": "Notes on Git"
        },
        {
            "location": "/git/#data-model",
            "text": "blob  is content of file   $ git cat-file -p 74576250e3c3a901bf06832bd0e4ee5e00422115\n# Shuo's notes\nhttp://chenshuo.github.io/notes   tree  has one or more  tree / blob , it's  Merkle tree .  blob  are leaf nodes  tree  are internal nodes     $ git cat-file -p 5d42664e3d812288b47795718d0e4faf26397bf9\n100644 blob cde88fe0e10f265ed3cb2af0ea5422f607c1a37c    .gitignore\n100644 blob 74576250e3c3a901bf06832bd0e4ee5e00422115    README.md\n040000 tree eabff4ee0b30f5d6a644ce508ba7fe47dc563aa4    docs\n100644 blob 020682e2399c75cf3ad9636964c7501f27a0e893    mkdocs.yml   commit :  has one  tree  has one or more parent  commit (s)     $ git cat-file -p 3f08891b366c750d4739241874cfb1dbef56c398\ntree 5d42664e3d812288b47795718d0e4faf26397bf9\nparent 955f683cae5d2514d1c788fce9206451e2ac3334\nauthor Shuo Chen <chenshuo@chenshuo.com> 1484903215 -0800\ncommitter Shuo Chen <chenshuo@chenshuo.com> 1484903215 -0800\n\nupdate ssl.md    tag  ???    Exceptions:   initial  commit  has no parent  empty file is empty  blob  empty directory is empty  tree",
            "title": "Data model"
        },
        {
            "location": "/git/#pack-file-format",
            "text": "",
            "title": "Pack file format"
        },
        {
            "location": "/git/#delta",
            "text": "",
            "title": "Delta"
        },
        {
            "location": "/git/#pack-index-format",
            "text": "",
            "title": "Pack index format"
        },
        {
            "location": "/kernel/data-structures/",
            "text": "File Descriptor Table\n\n\n// include/linux/sched.h\n\nstruct task_struct {\n  // ...\n  /* open file information */\n        struct files_struct *files;\n  // ...\n};\n\n// include/linux/fdtable.h\n\nstruct fdtable {\n        unsigned int max_fds;\n        struct file __rcu **fd;      /* current fd array */\n        unsigned long *close_on_exec;\n        unsigned long *open_fds;\n        unsigned long *full_fds_bits;\n        struct rcu_head rcu;\n};\n\n/*\n * Open file table structure\n */\nstruct files_struct {\n  /*\n   * read mostly part\n   */\n        atomic_t count;\n        bool resize_in_progress;\n        wait_queue_head_t resize_wait;\n\n        struct fdtable __rcu *fdt;\n        struct fdtable fdtab;\n  /*\n   * written part on a separate cache line in SMP\n   */\n        spinlock_t file_lock ____cacheline_aligned_in_smp;\n        unsigned int next_fd;\n        unsigned long close_on_exec_init[1];\n        unsigned long open_fds_init[1];\n        unsigned long full_fds_bits_init[1];\n        struct file __rcu * fd_array[NR_OPEN_DEFAULT];\n};\n\n// include/linux/fs.h\n\nstruct file {\n        union {\n                struct llist_node       fu_llist;\n                struct rcu_head         fu_rcuhead;\n        } f_u;\n        struct path             f_path;\n        struct inode            *f_inode;       /* cached value */\n        const struct file_operations    *f_op;\n\n        // ...\n\n        atomic_long_t           f_count;\n\n        // ...\n\n        /* needed for tty driver, and maybe others */\n        void                    *private_data;\n\n#ifdef CONFIG_EPOLL\n        /* Used by fs/eventpoll.c to link all the hooks to this file */\n        struct list_head        f_ep_links;\n        struct list_head        f_tfile_llink;\n#endif\n};\n\n\n\n\n\nstruct socket{}\n\n\n// include/linux/net.h\n\nstruct socket_wq {\n        /* Note: wait MUST be first field of socket_wq */\n        wait_queue_head_t       wait;\n        struct fasync_struct    *fasync_list;\n        unsigned long           flags; /* %SOCKWQ_ASYNC_NOSPACE, etc */\n        struct rcu_head         rcu;\n} ____cacheline_aligned_in_smp;\n\n/**\n *  struct socket - general BSD socket\n *  @state: socket state (%SS_CONNECTED, etc)\n *  @type: socket type (%SOCK_STREAM, etc)\n *  @flags: socket flags (%SOCK_NOSPACE, etc)\n *  @ops: protocol specific socket operations\n *  @file: File back pointer for gc\n *  @sk: internal networking protocol agnostic socket representation\n *  @wq: wait queue for several uses\n */\nstruct socket {\n        socket_state            state;\n\n        kmemcheck_bitfield_begin(type);\n        short                   type;\n        kmemcheck_bitfield_end(type);\n\n        unsigned long           flags;\n\n        struct socket_wq __rcu  *wq;\n\n        struct file             *file;\n        struct sock             *sk;\n        const struct proto_ops  *ops;\n};\n\n// include/net/sock.h\n\nstruct socket_alloc {\n        struct socket socket;\n        struct inode vfs_inode;\n};\n\n// include/linux/fs.h\nstruct inode {\n        umode_t                 i_mode;     // S_IFSOCK | S_IRWXUGO;\n        unsigned short          i_opflags;\n        kuid_t                  i_uid;\n        kgid_t                  i_gid;\n        unsigned int            i_flags;\n// ...\n        const struct inode_operations   *i_op;\n        struct super_block      *i_sb;\n// ...\n        unsigned long           i_ino;      // sockfs_dname: \"socket:[%lu]\"\n// ...\n        union {\n                struct hlist_head       i_dentry;\n                struct rcu_head         i_rcu;\n        };\n// ...\n};\n\n\n\n\nsocket(2)\n\n\nint sys_socket(int family, int type, int protocol)\n  -> struct socket* sock_create(family, type, protocol)\n    -> __sock_create(family, type, protocol)\n      -> struct socket* sock = sock_alloc()\n        -> inode = new_inode_pseudo(super_block of sockfs)      // fs/inode.c\n          -> alloc_inode\n            -> sock_alloc_inode (sb->s_op->alloc_inod)\n              -> socket_alloc *ei = kmem_cache_alloc(sock_inode_cachep)  // 306B\n              -> socket_wq *wq = kmalloc(sizeof(*wq))  // 24B\n              ei->socket.wq = wq;\n              ei->socket.state = SS_UNCONNECTED;\n            -> inode_init_always\n        sock = SOCKET_I(inode);\n        inode->i_op = &sockfs_inode_ops;  // .listxattr = sockfs_listxattr,\n      -> net_families[family]->create(sock, protocol)\n        -> inet_create(sock, protocol)                  // net/ipv4/af_inet.c\n  -> sock_map_fd()\n    -> get_unused_fd_flags\n    -> sock_alloc_file\n      -> d_alloc_pseudo  // sizeof(struct dentry) == 128\n      -> file = alloc_file(..., &socket_file_ops);  // sizeof(struct file) == 140\n        -> get_empty_filp\n        file.f_op = &socket_file_ops\n      sock->file = file;\n      file->private_data = sock;\n    -> fd_install\n\ninet_create(sock, protocol)\n  -> find inet_protosw for sock->type & protocol\n  -> struct sock* sk = sk_alloc()\n    -> sk_prot_alloc -> kmem_cache_alloc (tcp_prot is 1360B)\n  -> sock_init_data\n    sk->sk_socket = sock;\n    sock->sk = sk;\n  -> sk->sk_prot->init(sk)\n    -> tcp_v4_init_sock\n      -> tcp_init_sock\n        -> tcp_init_xmit_timers\n        -> tcp_prequeue_init\n        -> tcp_enable_early_retrans\n        -> tcp_assign_congestion_control\n        sk->sk_state = TCP_CLOSE;\n      icsk->icsk_af_ops = &ipv4_specific;\n\n\n\n\nAfter \nsocket()\n\n\n\n\nMemory usage\n\n\nOn x86-64 Deiban 8, Linux 3.16, \n/proc/slabinfo\n\n\n\n\n\n\n\n\nstruct\n\n\nsize\n\n\nslab cache name\n\n\n\n\n\n\n\n\n\n\nfile\n\n\n256\n\n\n\"filp\"\n\n\n\n\n\n\ndentry\n\n\n192\n\n\n\"dentry\"\n\n\n\n\n\n\nsocket_alloc\n\n\n640\n\n\n\"sock_inode_cache\"\n\n\n\n\n\n\ntcp_sock\n\n\n1792\n\n\n\"TCP\"\n\n\n\n\n\n\nsocket_wq\n\n\n64\n\n\n\"kmalloc-64\"\n\n\n\n\n\n\ninet_bind_bucket\n\n\n64\n\n\n\"tcp_bind_bucket\"\n\n\n\n\n\n\ntcp_request_sock\n\n\n256\n\n\n\"request_sock_TCP\"\n\n\n\n\n\n\ninet_timewait_sock\n\n\n192\n\n\n\"tw_sock_TCP\"\n\n\n\n\n\n\nepitem\n\n\n128\n\n\n\"eventpoll_epi\"\n\n\n\n\n\n\n\n\nTotal : 2944 bytes/socket, not including send/receive buffers. For client sockets, +64B for \ninet_bind_bucket\n.\n\n\nnet_proto_family\n\n\n\n\n\n\n\n\nfamily\n\n\ntype\n\n\nprotocol\n\n\n\n\n\n\n\n\n\n\nAF_UNIX=1\n\n\nSOCK_STREAM=1\n\n\n0\n\n\n\n\n\n\nAF_UNIX\n\n\nSOCK_DGRAM=2\n\n\n0\n\n\n\n\n\n\nAF_INET=2\n\n\nSOCK_STREAM\n\n\nIPPROTO_TCP=6\n\n\n\n\n\n\nAF_INET\n\n\nSOCK_DGRAM\n\n\nIPPROTO_UDP=17\n\n\n\n\n\n\nAF_INET\n\n\nSOCK_DGRAM\n\n\nIPPROTO_ICMP=1\n\n\n\n\n\n\nAF_INET\n\n\nSOCK_RAW=3\n\n\nIPPROTO_IP=0\n\n\n\n\n\n\nNPROTO=AF_MAX=41\n\n\nSOCK_MAX=11\n\n\nno max?\n\n\n\n\n\n\n\n\n// include/linux/net.h\n// How to create a socket for an address family\nstruct net_proto_family {\n  int family;  // AF_INET, AF_UNIX, AF_INET6, etc. must: 0 <= family < NPROTO\n  int (*create)(struct net *net, struct socket *sock, int protocol, int kern);\n  struct module *owner;\n};\n\n\n\n\n\n// net/socket.c\nstatic const struct net_proto_family *net_families[NPROTO];\n\n// net/ipv4/af_inet.c\nstatic int inet_create(struct net *net, struct socket *sock, int protocol, int kern);\n\nstatic const struct net_proto_family inet_family_ops = {\n  .family = PF_INET,\n  .create = inet_create,\n  .owner  = THIS_MODULE\n};\n\n// inet_init() calls sock_register():\nnet_families[AF_INET] = &inet_family_ops;\n\n\n\n\ninet_protosw\n\n\n// include/net/protocol.h\n/* This is used to register socket interfaces for IP protocols.  */\nstruct inet_protosw {\n  struct list_head list;\n\n  /* These two fields form the lookup key.  */\n  unsigned short   type;     /* This is the 2nd argument to socket(2).  eg. SOCK_STREAM, SOCK_DGRAM */\n  unsigned short   protocol; /* This is the L4 protocol number.  eg. IPPROTO_TCP, IPPROTO_TCP */\n\n  struct proto           *prot;\n  const struct proto_ops *ops;\n\n  unsigned char    flags;      /* See INET_PROTOSW_* below.  */\n};\n#define INET_PROTOSW_REUSE      0x01  /* Are ports automatically reusable? */\n#define INET_PROTOSW_PERMANENT  0x02  /* Permanent protocols are unremovable. */\n#define INET_PROTOSW_ICSK       0x04  /* Is this an inet_connection_sock? */\n\n\n\n\n// net/ipv4/af_inet.c\n/* The inetsw table contains everything that inet_create needs to\n * build a new socket.\n */\nstatic struct list_head inetsw[SOCK_MAX];\nstatic DEFINE_SPINLOCK(inetsw_lock);\n\n/* Upon startup we insert all the elements in inetsw_array[] into\n * the linked list inetsw.\n */\nstatic struct inet_protosw inetsw_array[] =\n{\n  {\n    .type =       SOCK_STREAM,\n    .protocol =   IPPROTO_TCP,\n    .prot =       &tcp_prot,\n    .ops =        &inet_stream_ops,\n    .flags =      INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK,\n  },\n  {\n    .type =       SOCK_DGRAM,\n    .protocol =   IPPROTO_UDP,\n    .prot =       &udp_prot,\n    .ops =        &inet_dgram_ops,\n    .flags =      INET_PROTOSW_PERMANENT,\n  },\n  {\n    .type =       SOCK_DGRAM,\n    .protocol =   IPPROTO_ICMP,\n    .prot =       &ping_prot,\n    .ops =        &inet_dgram_ops,\n    .flags =      INET_PROTOSW_REUSE,\n  },\n  {\n    .type =       SOCK_RAW,\n    .protocol =   IPPROTO_IP,        /* wild card */\n    .prot =       &raw_prot,\n    .ops =        &inet_sockraw_ops,\n    .flags =      INET_PROTOSW_REUSE,\n  }\n};\n\n#define INETSW_ARRAY_LEN ARRAY_SIZE(inetsw_array)\n\n// inet_init()\n  sock_register(&inet_family_ops);\n\n  /* Register the socket-side information for inet_create. */\n  for (struct list_head *r = &inetsw[0]; r < &inetsw[SOCK_MAX]; ++r)\n    INIT_LIST_HEAD(r);\n\n  for (struct inet_protosw *q = inetsw_array; q < &inetsw_array[INETSW_ARRAY_LEN]; ++q)\n    inet_register_protosw(q);\n\n\n\n\nAfter Initialization:\n\n\n\nskbuff\n\n\nA sample of receive skb for TCP SYN segment:",
            "title": "Data Structures"
        },
        {
            "location": "/kernel/data-structures/#file-descriptor-table",
            "text": "// include/linux/sched.h\n\nstruct task_struct {\n  // ...\n  /* open file information */\n        struct files_struct *files;\n  // ...\n};\n\n// include/linux/fdtable.h\n\nstruct fdtable {\n        unsigned int max_fds;\n        struct file __rcu **fd;      /* current fd array */\n        unsigned long *close_on_exec;\n        unsigned long *open_fds;\n        unsigned long *full_fds_bits;\n        struct rcu_head rcu;\n};\n\n/*\n * Open file table structure\n */\nstruct files_struct {\n  /*\n   * read mostly part\n   */\n        atomic_t count;\n        bool resize_in_progress;\n        wait_queue_head_t resize_wait;\n\n        struct fdtable __rcu *fdt;\n        struct fdtable fdtab;\n  /*\n   * written part on a separate cache line in SMP\n   */\n        spinlock_t file_lock ____cacheline_aligned_in_smp;\n        unsigned int next_fd;\n        unsigned long close_on_exec_init[1];\n        unsigned long open_fds_init[1];\n        unsigned long full_fds_bits_init[1];\n        struct file __rcu * fd_array[NR_OPEN_DEFAULT];\n};\n\n// include/linux/fs.h\n\nstruct file {\n        union {\n                struct llist_node       fu_llist;\n                struct rcu_head         fu_rcuhead;\n        } f_u;\n        struct path             f_path;\n        struct inode            *f_inode;       /* cached value */\n        const struct file_operations    *f_op;\n\n        // ...\n\n        atomic_long_t           f_count;\n\n        // ...\n\n        /* needed for tty driver, and maybe others */\n        void                    *private_data;\n\n#ifdef CONFIG_EPOLL\n        /* Used by fs/eventpoll.c to link all the hooks to this file */\n        struct list_head        f_ep_links;\n        struct list_head        f_tfile_llink;\n#endif\n};",
            "title": "File Descriptor Table"
        },
        {
            "location": "/kernel/data-structures/#struct-socket",
            "text": "// include/linux/net.h\n\nstruct socket_wq {\n        /* Note: wait MUST be first field of socket_wq */\n        wait_queue_head_t       wait;\n        struct fasync_struct    *fasync_list;\n        unsigned long           flags; /* %SOCKWQ_ASYNC_NOSPACE, etc */\n        struct rcu_head         rcu;\n} ____cacheline_aligned_in_smp;\n\n/**\n *  struct socket - general BSD socket\n *  @state: socket state (%SS_CONNECTED, etc)\n *  @type: socket type (%SOCK_STREAM, etc)\n *  @flags: socket flags (%SOCK_NOSPACE, etc)\n *  @ops: protocol specific socket operations\n *  @file: File back pointer for gc\n *  @sk: internal networking protocol agnostic socket representation\n *  @wq: wait queue for several uses\n */\nstruct socket {\n        socket_state            state;\n\n        kmemcheck_bitfield_begin(type);\n        short                   type;\n        kmemcheck_bitfield_end(type);\n\n        unsigned long           flags;\n\n        struct socket_wq __rcu  *wq;\n\n        struct file             *file;\n        struct sock             *sk;\n        const struct proto_ops  *ops;\n};\n\n// include/net/sock.h\n\nstruct socket_alloc {\n        struct socket socket;\n        struct inode vfs_inode;\n};\n\n// include/linux/fs.h\nstruct inode {\n        umode_t                 i_mode;     // S_IFSOCK | S_IRWXUGO;\n        unsigned short          i_opflags;\n        kuid_t                  i_uid;\n        kgid_t                  i_gid;\n        unsigned int            i_flags;\n// ...\n        const struct inode_operations   *i_op;\n        struct super_block      *i_sb;\n// ...\n        unsigned long           i_ino;      // sockfs_dname: \"socket:[%lu]\"\n// ...\n        union {\n                struct hlist_head       i_dentry;\n                struct rcu_head         i_rcu;\n        };\n// ...\n};",
            "title": "struct socket{}"
        },
        {
            "location": "/kernel/data-structures/#socket2",
            "text": "int sys_socket(int family, int type, int protocol)\n  -> struct socket* sock_create(family, type, protocol)\n    -> __sock_create(family, type, protocol)\n      -> struct socket* sock = sock_alloc()\n        -> inode = new_inode_pseudo(super_block of sockfs)      // fs/inode.c\n          -> alloc_inode\n            -> sock_alloc_inode (sb->s_op->alloc_inod)\n              -> socket_alloc *ei = kmem_cache_alloc(sock_inode_cachep)  // 306B\n              -> socket_wq *wq = kmalloc(sizeof(*wq))  // 24B\n              ei->socket.wq = wq;\n              ei->socket.state = SS_UNCONNECTED;\n            -> inode_init_always\n        sock = SOCKET_I(inode);\n        inode->i_op = &sockfs_inode_ops;  // .listxattr = sockfs_listxattr,\n      -> net_families[family]->create(sock, protocol)\n        -> inet_create(sock, protocol)                  // net/ipv4/af_inet.c\n  -> sock_map_fd()\n    -> get_unused_fd_flags\n    -> sock_alloc_file\n      -> d_alloc_pseudo  // sizeof(struct dentry) == 128\n      -> file = alloc_file(..., &socket_file_ops);  // sizeof(struct file) == 140\n        -> get_empty_filp\n        file.f_op = &socket_file_ops\n      sock->file = file;\n      file->private_data = sock;\n    -> fd_install\n\ninet_create(sock, protocol)\n  -> find inet_protosw for sock->type & protocol\n  -> struct sock* sk = sk_alloc()\n    -> sk_prot_alloc -> kmem_cache_alloc (tcp_prot is 1360B)\n  -> sock_init_data\n    sk->sk_socket = sock;\n    sock->sk = sk;\n  -> sk->sk_prot->init(sk)\n    -> tcp_v4_init_sock\n      -> tcp_init_sock\n        -> tcp_init_xmit_timers\n        -> tcp_prequeue_init\n        -> tcp_enable_early_retrans\n        -> tcp_assign_congestion_control\n        sk->sk_state = TCP_CLOSE;\n      icsk->icsk_af_ops = &ipv4_specific;  After  socket()",
            "title": "socket(2)"
        },
        {
            "location": "/kernel/data-structures/#memory-usage",
            "text": "On x86-64 Deiban 8, Linux 3.16,  /proc/slabinfo     struct  size  slab cache name      file  256  \"filp\"    dentry  192  \"dentry\"    socket_alloc  640  \"sock_inode_cache\"    tcp_sock  1792  \"TCP\"    socket_wq  64  \"kmalloc-64\"    inet_bind_bucket  64  \"tcp_bind_bucket\"    tcp_request_sock  256  \"request_sock_TCP\"    inet_timewait_sock  192  \"tw_sock_TCP\"    epitem  128  \"eventpoll_epi\"     Total : 2944 bytes/socket, not including send/receive buffers. For client sockets, +64B for  inet_bind_bucket .",
            "title": "Memory usage"
        },
        {
            "location": "/kernel/data-structures/#net_proto_family",
            "text": "family  type  protocol      AF_UNIX=1  SOCK_STREAM=1  0    AF_UNIX  SOCK_DGRAM=2  0    AF_INET=2  SOCK_STREAM  IPPROTO_TCP=6    AF_INET  SOCK_DGRAM  IPPROTO_UDP=17    AF_INET  SOCK_DGRAM  IPPROTO_ICMP=1    AF_INET  SOCK_RAW=3  IPPROTO_IP=0    NPROTO=AF_MAX=41  SOCK_MAX=11  no max?     // include/linux/net.h\n// How to create a socket for an address family\nstruct net_proto_family {\n  int family;  // AF_INET, AF_UNIX, AF_INET6, etc. must: 0 <= family < NPROTO\n  int (*create)(struct net *net, struct socket *sock, int protocol, int kern);\n  struct module *owner;\n};  // net/socket.c\nstatic const struct net_proto_family *net_families[NPROTO];\n\n// net/ipv4/af_inet.c\nstatic int inet_create(struct net *net, struct socket *sock, int protocol, int kern);\n\nstatic const struct net_proto_family inet_family_ops = {\n  .family = PF_INET,\n  .create = inet_create,\n  .owner  = THIS_MODULE\n};\n\n// inet_init() calls sock_register():\nnet_families[AF_INET] = &inet_family_ops;",
            "title": "net_proto_family"
        },
        {
            "location": "/kernel/data-structures/#inet_protosw",
            "text": "// include/net/protocol.h\n/* This is used to register socket interfaces for IP protocols.  */\nstruct inet_protosw {\n  struct list_head list;\n\n  /* These two fields form the lookup key.  */\n  unsigned short   type;     /* This is the 2nd argument to socket(2).  eg. SOCK_STREAM, SOCK_DGRAM */\n  unsigned short   protocol; /* This is the L4 protocol number.  eg. IPPROTO_TCP, IPPROTO_TCP */\n\n  struct proto           *prot;\n  const struct proto_ops *ops;\n\n  unsigned char    flags;      /* See INET_PROTOSW_* below.  */\n};\n#define INET_PROTOSW_REUSE      0x01  /* Are ports automatically reusable? */\n#define INET_PROTOSW_PERMANENT  0x02  /* Permanent protocols are unremovable. */\n#define INET_PROTOSW_ICSK       0x04  /* Is this an inet_connection_sock? */  // net/ipv4/af_inet.c\n/* The inetsw table contains everything that inet_create needs to\n * build a new socket.\n */\nstatic struct list_head inetsw[SOCK_MAX];\nstatic DEFINE_SPINLOCK(inetsw_lock);\n\n/* Upon startup we insert all the elements in inetsw_array[] into\n * the linked list inetsw.\n */\nstatic struct inet_protosw inetsw_array[] =\n{\n  {\n    .type =       SOCK_STREAM,\n    .protocol =   IPPROTO_TCP,\n    .prot =       &tcp_prot,\n    .ops =        &inet_stream_ops,\n    .flags =      INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK,\n  },\n  {\n    .type =       SOCK_DGRAM,\n    .protocol =   IPPROTO_UDP,\n    .prot =       &udp_prot,\n    .ops =        &inet_dgram_ops,\n    .flags =      INET_PROTOSW_PERMANENT,\n  },\n  {\n    .type =       SOCK_DGRAM,\n    .protocol =   IPPROTO_ICMP,\n    .prot =       &ping_prot,\n    .ops =        &inet_dgram_ops,\n    .flags =      INET_PROTOSW_REUSE,\n  },\n  {\n    .type =       SOCK_RAW,\n    .protocol =   IPPROTO_IP,        /* wild card */\n    .prot =       &raw_prot,\n    .ops =        &inet_sockraw_ops,\n    .flags =      INET_PROTOSW_REUSE,\n  }\n};\n\n#define INETSW_ARRAY_LEN ARRAY_SIZE(inetsw_array)\n\n// inet_init()\n  sock_register(&inet_family_ops);\n\n  /* Register the socket-side information for inet_create. */\n  for (struct list_head *r = &inetsw[0]; r < &inetsw[SOCK_MAX]; ++r)\n    INIT_LIST_HEAD(r);\n\n  for (struct inet_protosw *q = inetsw_array; q < &inetsw_array[INETSW_ARRAY_LEN]; ++q)\n    inet_register_protosw(q);  After Initialization:",
            "title": "inet_protosw"
        },
        {
            "location": "/kernel/data-structures/#skbuff",
            "text": "A sample of receive skb for TCP SYN segment:",
            "title": "skbuff"
        },
        {
            "location": "/kernel/file-descriptor-table/",
            "text": "Evolution of File Descriptor Table in Linux Kernel\n\n\n\n\n0.01 to 1.1.10\n\n\nA fixed length array in \nstruct task_struct\n.\n\n\n// include/linux/sched.h of linux-1.1.10\n\nstruct task_struct {\n        // ...\n        struct file * filp[NR_OPEN];\n        fd_set close_on_exec;\n        // ...\n};\n\n\n\n\nNote 1: \nfile_table\n and \ninode_table\n were made dynamic in 0.99.10.\n\n\n\n\n\n\n\n\nVersion\n\n\nNR_OPEN\n\n\nNR_FILE\n\n\nNR_INODE\n\n\n\n\n\n\n\n\n\n\n0.01\n\n\n20\n\n\n64\n\n\n32\n\n\n\n\n\n\n0.12\n\n\n20\n\n\n64\n\n\n64\n\n\n\n\n\n\n0.95\n\n\n20\n\n\n64\n\n\n128\n\n\n\n\n\n\n0.96a-patch3\n\n\n32\n\n\n64\n\n\n128\n\n\n\n\n\n\n0.96c-patch1\n\n\n32\n\n\n128\n\n\n128\n\n\n\n\n\n\n0.96pre\n\n\n32\n\n\n64\n\n\n128\n\n\n\n\n\n\n0.97\n\n\n32\n\n\n128\n\n\n128\n\n\n\n\n\n\n0.98.4\n\n\n256\n\n\n128\n\n\n128\n\n\n\n\n\n\n0.99.10\n\n\n256\n\n\n1024\n\n\n2048\n\n\n\n\n\n\n\n\n// fs/file_table.c of linux-0.99.10\n\n-struct file file_table[NR_FILE];\n+struct file * first_file;\n\n\n\n\nNote 2: ext2 file system was added 0.99.7.\n\n\n1.1.11 to 1.3.21\n\n\nSplit into \nstruct files_struct\n.\n1.1.11 was released in 1995/05.\n\n\n// include/linux/sched.h of linux-1.3.21\n\nstruct files_struct {\n        int count;\n        fd_set close_on_exec;\n        struct file * fd[NR_OPEN];\n};\n\nstruct task_struct {\n        // ...\n\n/* filesystem information */\n        struct fs_struct fs[1];\n/* open file information */\n        struct files_struct files[1];\n/* memory management info */\n        struct mm_struct mm[1];\n\n        // ...\n\n};\n\n\n\n\n1.3.22 to 2.1.89\n\n\nChange \nfiles\n from a \nstruct[1]\n to a pointer, so it can be shared by threads within a process.\n1.3.22 was released in 1995/09.  LinuxThreads needs 2.0 kernel, which was released in 1996/07.\n\n\n// include/linux/sched.h of linux-2.0.2\n\n/* Open file table structure */\nstruct files_struct {\n        int count;\n        fd_set close_on_exec;\n        fd_set open_fds;\n        struct file * fd[NR_OPEN];\n};\n\nstruct task_struct {\n        // ...\n\n /* filesystem information */\n-       struct fs_struct fs[1];\n+       struct fs_struct *fs;\n /* open file information */\n-       struct files_struct files[1];\n+       struct files_struct *files;\n /* memory management info */\n-       struct mm_struct mm[1];\n+       struct mm_struct *mm;\n\n        // ...\n};\n\n\n\n\n2.1.90 to 2.6.13\n\n\nChange fixed-length array \nfd\n to dynamic array.\n2.2.0 was released in 1999/01.\n\n\n// include/linux/sched.h of linux-2.2.0\n\n/*\n * Open file table structure\n */\nstruct files_struct {\n        atomic_t count;\n+       int max_fds;\n+       struct file ** fd;      /* current fd array */\n        fd_set close_on_exec;   // changed to fd_set* in 2.2.12\n        fd_set open_fds;\n-       struct file * fd[NR_OPEN];\n};\n\nstruct task_struct {\n        // ...\n\n/* open file information */\n        struct files_struct *files;\n\n        // ...\n\n};\n\n\n\n\n\n\n2.6.14 to now (4.15.7)\n\n\nIntroduce \nstruct fdtable\n for RCU. 2.6.15 was released in 2006/01, Ubuntu 6.04 LTS and Debian 4 ship it.\n\n\n// include/linux/fdtable.h of linux-2.6.37\n\nstruct fdtable {\n        unsigned int max_fds;\n        struct file __rcu **fd;      /* current fd array */\n        fd_set *close_on_exec;\n        fd_set *open_fds;\n        struct rcu_head rcu;\n        struct fdtable *next;\n};\n\n/*\n * Open file table structure\n */\nstruct files_struct {\n  /*\n   * read mostly part\n   */\n        atomic_t count;\n        struct fdtable __rcu *fdt;\n        struct fdtable fdtab;\n  /*\n   * written part on a separate cache line in SMP\n   */\n        spinlock_t file_lock ____cacheline_aligned_in_smp;\n        int next_fd;\n        struct embedded_fd_set close_on_exec_init;\n        struct embedded_fd_set open_fds_init;\n        struct file __rcu * fd_array[NR_OPEN_DEFAULT];\n};\n\nstruct task_struct {\n        // ...\n\n/* open file information */\n        struct files_struct *files;\n\n        // ...\n\n};\n\n\n\n\nstruct file\n itself.\n\n\n// include/linux/fs.h of linux-4.9\n\nstruct file {\n        union {\n                struct llist_node       fu_llist;\n                struct rcu_head         fu_rcuhead;\n        } f_u;\n        struct path             f_path;\n        struct inode            *f_inode;  /* cached value */ // added back in 3.9, same as f_path.dentry->d_inode\n        const struct file_operations    *f_op;\n\n        /*\n         * Protects f_ep_links, f_flags.\n         * Must not be taken from IRQ context.\n         */\n        spinlock_t              f_lock;\n        atomic_long_t           f_count;\n        unsigned int            f_flags;\n        fmode_t                 f_mode;\n        struct mutex            f_pos_lock;  // Fixed in 3.14\n        loff_t                  f_pos;\n        struct fown_struct      f_owner;\n        const struct cred       *f_cred;\n        struct file_ra_state    f_ra;\n\n        u64                     f_version;\n#ifdef CONFIG_SECURITY\n        void                    *f_security;\n#endif\n        /* needed for tty driver, and maybe others */\n        void                    *private_data;\n\n#ifdef CONFIG_EPOLL\n        /* Used by fs/eventpoll.c to link all the hooks to this file */\n        struct list_head        f_ep_links;\n        struct list_head        f_tfile_llink;\n#endif /* #ifdef CONFIG_EPOLL */\n        struct address_space    *f_mapping;\n} __attribute__((aligned(4)));  /* lest something weird decides that 2 is OK */\n\n\n\n\nFreeBSD up to 9.3\n\n\n\n\n4.3BSD-Reno and older BSDes use fixed-length array of \nstruct file*\n.\n\n\nstruct user {\n        // ...\n        struct  file *u_ofile[NOFILE];  /* file structures for open files */\n        // ...\n};\n\n\n\n\nFrom BSD Net/2 up to FreeBSD 9.3 use a similiar dynamic array data structure of Linux 2.0 (see diagram above.),\nwhere \nproc\n == \ntask_struct\n, \nfiledesc\n == \nfiles_struct\n, \nfile\n == \nfile\n.\n\n\n// sys/proc.h\n/*\n * Process structure.\n */\nstruct proc {\n        // ...\n        struct filedesc *p_fd;          /* (b) Open files. */\n        // ...\n};\n\n// sys/filedesc.h\nstruct filedesc {\n        struct  file **fd_ofiles;       /* file structures for open files */\n        char    *fd_ofileflags;         /* per-process open file flags */\n        struct  vnode *fd_cdir;         /* current directory */\n        struct  vnode *fd_rdir;         /* root directory */\n        struct  vnode *fd_jdir;         /* jail root directory */\n        int     fd_nfiles;              /* number of open files allocated */\n        NDSLOTTYPE *fd_map;             /* bitmap of free fds */\n        int     fd_lastfile;            /* high-water mark of fd_ofiles */\n        int     fd_freefile;            /* approx. next free file */\n        u_short fd_cmask;               /* mask for file creation */\n        u_short fd_refcnt;              /* thread reference count */\n        u_short fd_holdcnt;             /* hold count on structure + mutex */\n        struct  sx fd_sx;               /* protects members of this struct */\n        struct  kqlist fd_kqlist;       /* list of kqueues on this filedesc */\n        int     fd_holdleaderscount;    /* block fdfree() for shared close() */\n        int     fd_holdleaderswakeup;   /* fdfree() needs wakeup */\n};\n\n// sys/file.h\nstruct file {\n        void            *f_data;        /* file descriptor specific data */\n        struct fileops  *f_ops;         /* File operations */\n        struct ucred    *f_cred;        /* associated credentials. */\n        struct vnode    *f_vnode;       /* NULL or applicable vnode */\n        short           f_type;         /* descriptor type */\n        short           f_vnread_flags; /* (f) Sleep lock for f_offset */\n        volatile u_int  f_flag;         /* see fcntl.h */\n        volatile u_int  f_count;        /* reference count */\n        // ...\n        off_t           f_offset;\n        // ...\n};",
            "title": "File Descriptor Table"
        },
        {
            "location": "/kernel/file-descriptor-table/#evolution-of-file-descriptor-table-in-linux-kernel",
            "text": "",
            "title": "Evolution of File Descriptor Table in Linux Kernel"
        },
        {
            "location": "/kernel/file-descriptor-table/#001-to-1110",
            "text": "A fixed length array in  struct task_struct .  // include/linux/sched.h of linux-1.1.10\n\nstruct task_struct {\n        // ...\n        struct file * filp[NR_OPEN];\n        fd_set close_on_exec;\n        // ...\n};  Note 1:  file_table  and  inode_table  were made dynamic in 0.99.10.     Version  NR_OPEN  NR_FILE  NR_INODE      0.01  20  64  32    0.12  20  64  64    0.95  20  64  128    0.96a-patch3  32  64  128    0.96c-patch1  32  128  128    0.96pre  32  64  128    0.97  32  128  128    0.98.4  256  128  128    0.99.10  256  1024  2048     // fs/file_table.c of linux-0.99.10\n\n-struct file file_table[NR_FILE];\n+struct file * first_file;  Note 2: ext2 file system was added 0.99.7.",
            "title": "0.01 to 1.1.10"
        },
        {
            "location": "/kernel/file-descriptor-table/#1111-to-1321",
            "text": "Split into  struct files_struct .\n1.1.11 was released in 1995/05.  // include/linux/sched.h of linux-1.3.21\n\nstruct files_struct {\n        int count;\n        fd_set close_on_exec;\n        struct file * fd[NR_OPEN];\n};\n\nstruct task_struct {\n        // ...\n\n/* filesystem information */\n        struct fs_struct fs[1];\n/* open file information */\n        struct files_struct files[1];\n/* memory management info */\n        struct mm_struct mm[1];\n\n        // ...\n\n};",
            "title": "1.1.11 to 1.3.21"
        },
        {
            "location": "/kernel/file-descriptor-table/#1322-to-2189",
            "text": "Change  files  from a  struct[1]  to a pointer, so it can be shared by threads within a process.\n1.3.22 was released in 1995/09.  LinuxThreads needs 2.0 kernel, which was released in 1996/07.  // include/linux/sched.h of linux-2.0.2\n\n/* Open file table structure */\nstruct files_struct {\n        int count;\n        fd_set close_on_exec;\n        fd_set open_fds;\n        struct file * fd[NR_OPEN];\n};\n\nstruct task_struct {\n        // ...\n\n /* filesystem information */\n-       struct fs_struct fs[1];\n+       struct fs_struct *fs;\n /* open file information */\n-       struct files_struct files[1];\n+       struct files_struct *files;\n /* memory management info */\n-       struct mm_struct mm[1];\n+       struct mm_struct *mm;\n\n        // ...\n};",
            "title": "1.3.22 to 2.1.89"
        },
        {
            "location": "/kernel/file-descriptor-table/#2190-to-2613",
            "text": "Change fixed-length array  fd  to dynamic array.\n2.2.0 was released in 1999/01.  // include/linux/sched.h of linux-2.2.0\n\n/*\n * Open file table structure\n */\nstruct files_struct {\n        atomic_t count;\n+       int max_fds;\n+       struct file ** fd;      /* current fd array */\n        fd_set close_on_exec;   // changed to fd_set* in 2.2.12\n        fd_set open_fds;\n-       struct file * fd[NR_OPEN];\n};\n\nstruct task_struct {\n        // ...\n\n/* open file information */\n        struct files_struct *files;\n\n        // ...\n\n};",
            "title": "2.1.90 to 2.6.13"
        },
        {
            "location": "/kernel/file-descriptor-table/#2614-to-now-4157",
            "text": "Introduce  struct fdtable  for RCU. 2.6.15 was released in 2006/01, Ubuntu 6.04 LTS and Debian 4 ship it.  // include/linux/fdtable.h of linux-2.6.37\n\nstruct fdtable {\n        unsigned int max_fds;\n        struct file __rcu **fd;      /* current fd array */\n        fd_set *close_on_exec;\n        fd_set *open_fds;\n        struct rcu_head rcu;\n        struct fdtable *next;\n};\n\n/*\n * Open file table structure\n */\nstruct files_struct {\n  /*\n   * read mostly part\n   */\n        atomic_t count;\n        struct fdtable __rcu *fdt;\n        struct fdtable fdtab;\n  /*\n   * written part on a separate cache line in SMP\n   */\n        spinlock_t file_lock ____cacheline_aligned_in_smp;\n        int next_fd;\n        struct embedded_fd_set close_on_exec_init;\n        struct embedded_fd_set open_fds_init;\n        struct file __rcu * fd_array[NR_OPEN_DEFAULT];\n};\n\nstruct task_struct {\n        // ...\n\n/* open file information */\n        struct files_struct *files;\n\n        // ...\n\n};  struct file  itself.  // include/linux/fs.h of linux-4.9\n\nstruct file {\n        union {\n                struct llist_node       fu_llist;\n                struct rcu_head         fu_rcuhead;\n        } f_u;\n        struct path             f_path;\n        struct inode            *f_inode;  /* cached value */ // added back in 3.9, same as f_path.dentry->d_inode\n        const struct file_operations    *f_op;\n\n        /*\n         * Protects f_ep_links, f_flags.\n         * Must not be taken from IRQ context.\n         */\n        spinlock_t              f_lock;\n        atomic_long_t           f_count;\n        unsigned int            f_flags;\n        fmode_t                 f_mode;\n        struct mutex            f_pos_lock;  // Fixed in 3.14\n        loff_t                  f_pos;\n        struct fown_struct      f_owner;\n        const struct cred       *f_cred;\n        struct file_ra_state    f_ra;\n\n        u64                     f_version;\n#ifdef CONFIG_SECURITY\n        void                    *f_security;\n#endif\n        /* needed for tty driver, and maybe others */\n        void                    *private_data;\n\n#ifdef CONFIG_EPOLL\n        /* Used by fs/eventpoll.c to link all the hooks to this file */\n        struct list_head        f_ep_links;\n        struct list_head        f_tfile_llink;\n#endif /* #ifdef CONFIG_EPOLL */\n        struct address_space    *f_mapping;\n} __attribute__((aligned(4)));  /* lest something weird decides that 2 is OK */",
            "title": "2.6.14 to now (4.15.7)"
        },
        {
            "location": "/kernel/file-descriptor-table/#freebsd-up-to-93",
            "text": "4.3BSD-Reno and older BSDes use fixed-length array of  struct file* .  struct user {\n        // ...\n        struct  file *u_ofile[NOFILE];  /* file structures for open files */\n        // ...\n};  From BSD Net/2 up to FreeBSD 9.3 use a similiar dynamic array data structure of Linux 2.0 (see diagram above.),\nwhere  proc  ==  task_struct ,  filedesc  ==  files_struct ,  file  ==  file .  // sys/proc.h\n/*\n * Process structure.\n */\nstruct proc {\n        // ...\n        struct filedesc *p_fd;          /* (b) Open files. */\n        // ...\n};\n\n// sys/filedesc.h\nstruct filedesc {\n        struct  file **fd_ofiles;       /* file structures for open files */\n        char    *fd_ofileflags;         /* per-process open file flags */\n        struct  vnode *fd_cdir;         /* current directory */\n        struct  vnode *fd_rdir;         /* root directory */\n        struct  vnode *fd_jdir;         /* jail root directory */\n        int     fd_nfiles;              /* number of open files allocated */\n        NDSLOTTYPE *fd_map;             /* bitmap of free fds */\n        int     fd_lastfile;            /* high-water mark of fd_ofiles */\n        int     fd_freefile;            /* approx. next free file */\n        u_short fd_cmask;               /* mask for file creation */\n        u_short fd_refcnt;              /* thread reference count */\n        u_short fd_holdcnt;             /* hold count on structure + mutex */\n        struct  sx fd_sx;               /* protects members of this struct */\n        struct  kqlist fd_kqlist;       /* list of kqueues on this filedesc */\n        int     fd_holdleaderscount;    /* block fdfree() for shared close() */\n        int     fd_holdleaderswakeup;   /* fdfree() needs wakeup */\n};\n\n// sys/file.h\nstruct file {\n        void            *f_data;        /* file descriptor specific data */\n        struct fileops  *f_ops;         /* File operations */\n        struct ucred    *f_cred;        /* associated credentials. */\n        struct vnode    *f_vnode;       /* NULL or applicable vnode */\n        short           f_type;         /* descriptor type */\n        short           f_vnread_flags; /* (f) Sleep lock for f_offset */\n        volatile u_int  f_flag;         /* see fcntl.h */\n        volatile u_int  f_count;        /* reference count */\n        // ...\n        off_t           f_offset;\n        // ...\n};",
            "title": "FreeBSD up to 9.3"
        },
        {
            "location": "/kernel/epoll/",
            "text": "EPOLL(7) data structures\n\n\nAfter \nepoll_create()\n\n\n\n\nAfter \nepoll_ctl(ADD, socketfd)\n\n\n\n\npipe()",
            "title": "Epoll"
        },
        {
            "location": "/kernel/epoll/#epoll7-data-structures",
            "text": "",
            "title": "EPOLL(7) data structures"
        },
        {
            "location": "/kernel/epoll/#after-epoll_create",
            "text": "",
            "title": "After epoll_create()"
        },
        {
            "location": "/kernel/epoll/#after-epoll_ctladd-socketfd",
            "text": "",
            "title": "After epoll_ctl(ADD, socketfd)"
        },
        {
            "location": "/kernel/epoll/#pipe",
            "text": "",
            "title": "pipe()"
        },
        {
            "location": "/kernel/callgraph/",
            "text": "tcp_sock\n\n\n\n\ntcp_hashinfo\n\n\n// include/linux/types.h\nstruct hlist_head {\n        struct hlist_node *first;\n};\n\nstruct hlist_node {\n        struct hlist_node *next, **pprev;\n};\n\n// include/linux/list_nulls.h\nstruct hlist_nulls_head {\n        struct hlist_nulls_node *first;\n};\n\nstruct hlist_nulls_node {\n        struct hlist_nulls_node *next, **pprev;\n};\n\n// include/net/inet_hashtables.h\nstruct inet_ehash_bucket {\n        struct hlist_nulls_head chain;\n};\n\nstruct inet_bind_hashbucket {\n        spinlock_t              lock;  // empty\n        struct hlist_head       chain;\n};\n\nstruct inet_listen_hashbucket {\n        spinlock_t              lock;  // empty\n        struct hlist_head       head;\n};\n\n#define INET_LHTABLE_SIZE       32      /* Yes, really, this is all you need. */\n\nstruct inet_hashinfo {\n        /* This is for sockets with full identity only.  Sockets here will\n         * always be without wildcards and will have the following invariant:\n         *\n         *          TCP_ESTABLISHED <= sk->sk_state < TCP_CLOSE\n         *\n         */\n        struct inet_ehash_bucket        *ehash;\n        spinlock_t                      *ehash_locks;\n        unsigned int                    ehash_mask;\n        unsigned int                    ehash_locks_mask;\n\n        /* Ok, let's try this, I give up, we do need a local binding\n         * TCP hash as well as the others for fast bind/connect.\n         */\n        struct inet_bind_hashbucket     *bhash;\n\n        unsigned int                    bhash_size;\n        /* 4 bytes hole on 64 bit */\n\n        struct kmem_cache               *bind_bucket_cachep;\n\n        /* All the above members are written once at bootup and\n         * never written again _or_ are predominantly read-access.\n         *\n         * Now align to a new cache line as all the following members\n         * might be often dirty.\n         */\n        /* All sockets in TCP_LISTEN state will be in here.  This is the only\n         * table where wildcard'd TCP sockets can exist.  Hash function here\n         * is just local port number.\n         */\n        struct inet_listen_hashbucket   listening_hash[INET_LHTABLE_SIZE]\n                                        ____cacheline_aligned_in_smp;\n};\n\n\n\n\n\nTCP state diagram in Linux 4.4+\n\n\n\n\nbind\n\n\nsys_bind\n  -> inet_bind\n    -> inet_csk_get_port\n      -> goto have_snum:\n      -> goto tb_not_found:  tb == NULL\n        -> inet_bind_bucket_create\n      -> goto success:\n        -> inet_bind_hash\n          -> sk_add_bind_node\n  -> fput_light\n// tcp_hashinfo.bhash -> inet_bind_hashbucket -> inet_bind_bucket[port=2222] -> tcp_sock\n\n\n\n\nlisten\n\n\nsys_listen\n  -> inet_listen\n    -> inet_csk_listen_start\n      -> reqsk_queue_alloc\n      -> inet_csk_delack_init\n      -> set sk->sk_state = TCP_LISTEN\n      -> inet_csk_get_port\n        -> goto have_snum:\n        -> goto tb_found:\n          -> inet_csk_bind_conflict\n        -> goto tb_not_found:  tb != NULL\n      -> inet_hash\n        -> __inet_hash  // tcp_hashinfo.listening_hash[X] add node\n\n\n\n\nAfter bind() and listen()\n\n\n\nPassive open\n\n\nReceive SYN\n\n\ntcp_v4_rcv\n  -> __inet_lookup_skb\n    -> __inet_lookup\n      -> __inet_lookup_established\n      -> __inet_lookup_listener  // found\n\n  -> tcp_v4_do_rcv  // sk_state == TCP_LISTEN\n    -> tcp_rcv_state_process\n      -> tcp_v4_conn_request  // icsk->icsk_af_ops->conn_request\n        -> tcp_conn_request\n          -> req = inet_reqsk_alloc\n            -> reqsk_alloc\n               req->rsk_listener = sk_listener;\n            ireq->ireq_state = TCP_NEW_SYN_RECV;\n            ireq->ireq_family = sk_listener->sk_family;\n          -> tcp_parse_options\n          -> tcp_openreq_init\n          -> tcp_v4_init_req  // af_ops->init_req\n            -> tcp_v4_save_options\n          -> isn = tcp_v4_init_sequence  // af_ops->init_seq\n          -> tcp_v4_route_req  // af_ops->route_req\n            -> inet_csk_route_req\n              -> flowi4_init_output\n              -> ip_route_output_flow\n          -> tcp_ecn_create_request\n          -> tcp_openreq_init_rwin\n            -> tcp_select_initial_window\n          -> tcp_reqsk_record_syn\n          -> tcp_try_fastopen\n          -> inet_csk_reqsk_queue_hash_add\n            -> reqsk_queue_hash_req  //***\n              -> inet_ehash_insert\n                -> __sk_nulls_add_node_rcu\n            -> inet_csk_reqsk_queue_added\n              inet_csk(sk)->icsk_accept_queue.qlen++\n          -> tcp_v4_send_synack  // af_ops->send_synack\n            -> tcp_make_synack\n            -> __tcp_v4_send_check\n            -> ip_build_and_send_pkt\n              -> ip_local_out\n                -> __ip_local_out\n                  -> dst_output\n                    -> ip_output\n\n\n\n\nAfter receiving SYN\n\n\n\nReceive ACK\n\n\ntcp_v4_rcv\n  -> __inet_lookup_skb\n    -> __inet_lookup\n      -> __inet_lookup_established  // found tcp_request_sock\n  -> sk->sk_state == TCP_NEW_SYN_RECV\n    sk = req->rsk_listener;\n  -> tcp_check_req\n    -> tcp_parse_options\n      -> tcp_paws_reject\n      -> tcp_in_window\n    -> tcp_v4_syn_recv_sock  // inet_csk(sk)->icsk_af_ops->syn_recv_sock\n      -> tcp_create_openreq_child\n        -> inet_csk_clone_lock\n          -> sk_clone_lock\n            -> newsk = sk_prot_alloc  // new tcp_sock\n            -> sock_copy\n          newsk->sk_state = TCP_SYN_RECV;\n        -> tcp_init_xmit_timers\n      -> inet_sk_rx_dst_set\n      -> inet_csk_route_child_sock\n      -> tcp_ca_openreq_child\n        -> tcp_assign_congestion_control\n        -> tcp_set_ca_state TCP_CA_Open\n      -> tcp_sync_mss -> dst_mtu -> ipv4_mtu\n        -> tcp_mtu_to_mss\n        -> tcp_bound_to_half_wnd\n      -> dst_metric_advmss -> ipv4_default_advmss\n      -> tcp_initialize_rcv_mss\n      -> __inet_inherit_port\n        -> inet_bind_hash  // put newsk in bind_bucket\n        inet_csk(sk)->icsk_bind_hash = tb;\n      -> inet_ehash_nolisten\n        -> inet_ehash_insert(newsk, reqsk)\n          -> sk_nulls_del_node_init_rcu(osk)\n          -> __sk_nulls_add_node_rcu(sk, list)\n        -> sock_prot_inuse_add\n      -> tcp_move_syn\n    -> sock_rps_save_rxhash\n    -> tcp_synack_rtt_meas\n      -> skb_mstamp_us_delta\n      -> tcp_ack_update_rtt\n        -> tcp_update_rtt_min\n        -> tcp_rtt_estimator\n        -> tcp_set_rto\n    -> inet_csk_complete_hashdance\n      -> inet_csk_reqsk_queue_drop\n        -> reqsk_queue_unlink\n          -> reqsk_put(req)\n          return found(false)\n      -> reqsk_queue_removed\n        &inet_csk(sk)->icsk_accept_queue.qlen--\n      -> inet_csk_reqsk_queue_add\n        queue->rskq_accept_head = req  // first\n        -> sk_acceptq_added\n          sk->sk_ack_backlog++;  // listen_sk\n  -> tcp_child_process\n    -> tcp_rcv_state_process(child, skb)\n      -> tcp_validate_incoming\n      -> tcp_ack\n        -> tcp_ack_update_window\n        -> tcp_ecn_rcv_ecn_echo  // false\n        -> tcp_in_ack_event\n        return 1\n      switch(sk_state) case TCP_SYN_RECV:\n      -> inet_sk_rebuild_header  // icsk->icsk_af_ops->rebuild_header\n      -> tcp_init_congestion_control\n      -> tcp_mtup_init\n      -> tcp_init_buffer_space\n        -> tcp_fixup_rcvbuf\n        -> tcp_sndbuf_expand\n        -> tcp_full_space\n      tcp_set_state(sk, TCP_ESTABLISHED)\n      sk->sk_state_change -> sock_def_wakeup\n      -> tcp_init_metrics\n      -> tcp_update_pacing_rate\n      -> tcp_initialize_rcv_mss\n      -> tcp_fast_path_on\n      // out of switch\n      -> tcp_urg\n      switch TCP_ESTABLISHED\n        -> tcp_data_queue\n      -> tcp_data_snd_check\n      -> tcp_ack_snd_check\n    -> parent->sk_data_ready -> sock_def_readable -> wake_up_interruptible_sync_poll\n\n\n\n\nAfter receiving ACK\n\n\n\nActive open\n\n\nconnect\n\n\nsys_connect\n  -> inet_stream_connect -> __inet_stream_connect\n    -> tcp_v4_connect (sk->sk_prot->connect)\n      -> ip_route_connect\n      tcp_set_state(sk, TCP_SYN_SENT)\n      -> inet_hash_connect\n        -> port_offset = inet_sk_port_offset(sk)\n          -> secure_ipv4_port_ephemeral(saddr, daddr, dport)\n            -> md5_transform\n        -> __inet_hash_connect(..., port_offset, __inet_check_established)\n          static uint32_t hint // counter\n          -> inet_get_local_port_range\n          -> inet_bind_bucket_create\n          -> inet_bind_hash\n            -> sk_add_bind_node\n          -> inet_ehash_nolisten\n            -> inet_ehash_insert\n              -> sk_ehashfn\n                -> inet_ehashfn\n                  -> __inet_ehashfn\n                    -> jhash_3words\n            -> sock_prot_inuse_add\n      -> ip_route_newports\n        -> ip_route_output_flow\n      -> secure_tcp_sequence_number(saddr, daddr, sport, dport)\n        -> md5_transform\n      -> tcp_connect\n        -> tcp_connect_init\n        -> sk_stream_alloc_skb\n        -> tcp_init_nondata_skb\n        -> tcp_connect_queue_skb\n        -> tcp_ecn_send_syn\n        -> tcp_transmit_skb\n          -> tcp_options_size = tcp_syn_options\n          tcp_header_size = tcp_options_size + sizeof(struct tcphdr);\n          -> skb_push(skb, tcp_header_size)\n          -> skb_reset_transport_header\n          -> skb_orphan\n          skb->destructor = tcp_wfree;\n          -> tcp_options_write\n          -> tcp_v4_send_check (icsk->icsk_af_ops->send_check)\n            -> __tcp_v4_send_check\n              skb->ip_summed == CHECKSUM_PARTIAL\n          -> ip_queue_xmit (icsk->icsk_af_ops->queue_xmit)\n            -> skb_push\n            -> skb_reset_network_header\n            iph->frag_off = htons(IP_DF);\n            -> ip_copy_addrs\n            -> ip_select_ident_segs\n            -> ip_local_out\n              -> __ip_local_out\n                -> ip_send_check\n                  -> ip_fast_csum\n                -> nf_hook { return 1; }\n              -> dst_output\n                -> ip_output (skb_dst(skb)->output)\n        -> inet_csk_reset_xmit_timer\n    sock->state = SS_CONNECTING;\n    err = -EINPROGRESS;\n    timeo = sock_sndtimeo() // NULL\n    return err\n\n\n\n\nAfter \nconnect()\n\n\n\n\nReceive SYN+ACK\n\n\ntcp_v4_rcv\n  -> __inet_lookup_skb\n    -> __inet_lookup\n      -> __inet_lookup_established  // found\n  -> tcp_v4_do_rcv  // sk_state == TCP_SYN_SENT\n    -> tcp_rcv_state_process\n      case TCP_SYN_SENT:\n      -> tcp_rcv_synsent_state_process\n        -> tcp_parse_options\n        if (th->ack)  // true\n        -> tcp_ecn_rcv_synack\n        -> tcp_init_wl\n        -> tcp_ack(FLAG_SLOWPATH)\n          // FLAG_SLOWPATH\n          -> tcp_ack_update_window\n            -> tcp_may_update_window  // true\n            -> tcp_update_wln\n            -> tcp_fast_path_check\n            -> tcp_sync_mss\n            -> tcp_snd_una_update\n          -> tcp_ecn_rcv_ecn_echo  // false\n          -> tcp_in_ack_event\n          -> tcp_clean_rtx_queue\n            -> tcp_ack_update_rtt\n            -> tcp_rearm_rto\n          -> tcp_rate_gen\n          -> tcp_cong_control\n          -> tcp_xmit_recovery\n        -> tcp_mtup_init\n        -> tcp_sync_mss\n        -> tcp_initialize_rcv_mss\n        -> tcp_finish_connect\n          -> tcp_set_state(sk, TCP_ESTABLISHED);\n          -> inet_sk_rx_dst_set (icsk->icsk_af_ops->sk_rx_dst_set)\n          -> inet_sk_rebuild_header (icsk->icsk_af_ops->rebuild_header)\n          -> tcp_init_metrics\n          -> tcp_init_congestion_control\n          -> tcp_init_buffer_space\n            -> tcp_fixup_rcvbuf\n            -> tcp_sndbuf_expand\n            -> tcp_full_space\n        -> tcp_send_ack\n          -> skb_reserve\n          -> tcp_init_nondata_skb\n          -> skb_set_tcp_pure_ack\n          -> skb_mstamp_get\n          -> tcp_transmit_skb\n            -> tcp_options_size = tcp_established_options  // 12\n            ...\n      -> tcp_urg\n      -> __kfree_skb\n      -> tcp_data_snd_check\n      return 0;\n\n\n\n\naccept\n\n\nsys_accept4\n  -> newsock = sock_alloc\n  -> newfd = get_unused_fd_flags\n  -> newfile = sock_alloc_file(newsock, ...)\n  -> inet_accept (sock->ops->accept)\n    -> sk2 = inet_csk_accept (sk1->sk_prot->accept)\n      queue = &icsk->icsk_accept_queue;\n      req = reqsk_queue_remove(queue, sk);\n        req = queue->rskq_accept_head;\n        -> sk_acceptq_removed(parent);  // sk->sk_ack_backlog--;\n      newsk = req->sk\n      -> release_sock(sk)\n      -> reqsk_put(req) -> reqsk_free\n      return newsk\n    -> sock_graft(sk2, newsock)\n  -> fd_install(newfd, newfile)\n\n\n\n\nread\n\n\nwrite",
            "title": "Call Graphs"
        },
        {
            "location": "/kernel/callgraph/#tcp_sock",
            "text": "",
            "title": "tcp_sock"
        },
        {
            "location": "/kernel/callgraph/#tcp_hashinfo",
            "text": "// include/linux/types.h\nstruct hlist_head {\n        struct hlist_node *first;\n};\n\nstruct hlist_node {\n        struct hlist_node *next, **pprev;\n};\n\n// include/linux/list_nulls.h\nstruct hlist_nulls_head {\n        struct hlist_nulls_node *first;\n};\n\nstruct hlist_nulls_node {\n        struct hlist_nulls_node *next, **pprev;\n};\n\n// include/net/inet_hashtables.h\nstruct inet_ehash_bucket {\n        struct hlist_nulls_head chain;\n};\n\nstruct inet_bind_hashbucket {\n        spinlock_t              lock;  // empty\n        struct hlist_head       chain;\n};\n\nstruct inet_listen_hashbucket {\n        spinlock_t              lock;  // empty\n        struct hlist_head       head;\n};\n\n#define INET_LHTABLE_SIZE       32      /* Yes, really, this is all you need. */\n\nstruct inet_hashinfo {\n        /* This is for sockets with full identity only.  Sockets here will\n         * always be without wildcards and will have the following invariant:\n         *\n         *          TCP_ESTABLISHED <= sk->sk_state < TCP_CLOSE\n         *\n         */\n        struct inet_ehash_bucket        *ehash;\n        spinlock_t                      *ehash_locks;\n        unsigned int                    ehash_mask;\n        unsigned int                    ehash_locks_mask;\n\n        /* Ok, let's try this, I give up, we do need a local binding\n         * TCP hash as well as the others for fast bind/connect.\n         */\n        struct inet_bind_hashbucket     *bhash;\n\n        unsigned int                    bhash_size;\n        /* 4 bytes hole on 64 bit */\n\n        struct kmem_cache               *bind_bucket_cachep;\n\n        /* All the above members are written once at bootup and\n         * never written again _or_ are predominantly read-access.\n         *\n         * Now align to a new cache line as all the following members\n         * might be often dirty.\n         */\n        /* All sockets in TCP_LISTEN state will be in here.  This is the only\n         * table where wildcard'd TCP sockets can exist.  Hash function here\n         * is just local port number.\n         */\n        struct inet_listen_hashbucket   listening_hash[INET_LHTABLE_SIZE]\n                                        ____cacheline_aligned_in_smp;\n};",
            "title": "tcp_hashinfo"
        },
        {
            "location": "/kernel/callgraph/#tcp-state-diagram-in-linux-44",
            "text": "",
            "title": "TCP state diagram in Linux 4.4+"
        },
        {
            "location": "/kernel/callgraph/#bind",
            "text": "sys_bind\n  -> inet_bind\n    -> inet_csk_get_port\n      -> goto have_snum:\n      -> goto tb_not_found:  tb == NULL\n        -> inet_bind_bucket_create\n      -> goto success:\n        -> inet_bind_hash\n          -> sk_add_bind_node\n  -> fput_light\n// tcp_hashinfo.bhash -> inet_bind_hashbucket -> inet_bind_bucket[port=2222] -> tcp_sock",
            "title": "bind"
        },
        {
            "location": "/kernel/callgraph/#listen",
            "text": "sys_listen\n  -> inet_listen\n    -> inet_csk_listen_start\n      -> reqsk_queue_alloc\n      -> inet_csk_delack_init\n      -> set sk->sk_state = TCP_LISTEN\n      -> inet_csk_get_port\n        -> goto have_snum:\n        -> goto tb_found:\n          -> inet_csk_bind_conflict\n        -> goto tb_not_found:  tb != NULL\n      -> inet_hash\n        -> __inet_hash  // tcp_hashinfo.listening_hash[X] add node  After bind() and listen()",
            "title": "listen"
        },
        {
            "location": "/kernel/callgraph/#passive-open",
            "text": "",
            "title": "Passive open"
        },
        {
            "location": "/kernel/callgraph/#receive-syn",
            "text": "tcp_v4_rcv\n  -> __inet_lookup_skb\n    -> __inet_lookup\n      -> __inet_lookup_established\n      -> __inet_lookup_listener  // found\n\n  -> tcp_v4_do_rcv  // sk_state == TCP_LISTEN\n    -> tcp_rcv_state_process\n      -> tcp_v4_conn_request  // icsk->icsk_af_ops->conn_request\n        -> tcp_conn_request\n          -> req = inet_reqsk_alloc\n            -> reqsk_alloc\n               req->rsk_listener = sk_listener;\n            ireq->ireq_state = TCP_NEW_SYN_RECV;\n            ireq->ireq_family = sk_listener->sk_family;\n          -> tcp_parse_options\n          -> tcp_openreq_init\n          -> tcp_v4_init_req  // af_ops->init_req\n            -> tcp_v4_save_options\n          -> isn = tcp_v4_init_sequence  // af_ops->init_seq\n          -> tcp_v4_route_req  // af_ops->route_req\n            -> inet_csk_route_req\n              -> flowi4_init_output\n              -> ip_route_output_flow\n          -> tcp_ecn_create_request\n          -> tcp_openreq_init_rwin\n            -> tcp_select_initial_window\n          -> tcp_reqsk_record_syn\n          -> tcp_try_fastopen\n          -> inet_csk_reqsk_queue_hash_add\n            -> reqsk_queue_hash_req  //***\n              -> inet_ehash_insert\n                -> __sk_nulls_add_node_rcu\n            -> inet_csk_reqsk_queue_added\n              inet_csk(sk)->icsk_accept_queue.qlen++\n          -> tcp_v4_send_synack  // af_ops->send_synack\n            -> tcp_make_synack\n            -> __tcp_v4_send_check\n            -> ip_build_and_send_pkt\n              -> ip_local_out\n                -> __ip_local_out\n                  -> dst_output\n                    -> ip_output  After receiving SYN",
            "title": "Receive SYN"
        },
        {
            "location": "/kernel/callgraph/#receive-ack",
            "text": "tcp_v4_rcv\n  -> __inet_lookup_skb\n    -> __inet_lookup\n      -> __inet_lookup_established  // found tcp_request_sock\n  -> sk->sk_state == TCP_NEW_SYN_RECV\n    sk = req->rsk_listener;\n  -> tcp_check_req\n    -> tcp_parse_options\n      -> tcp_paws_reject\n      -> tcp_in_window\n    -> tcp_v4_syn_recv_sock  // inet_csk(sk)->icsk_af_ops->syn_recv_sock\n      -> tcp_create_openreq_child\n        -> inet_csk_clone_lock\n          -> sk_clone_lock\n            -> newsk = sk_prot_alloc  // new tcp_sock\n            -> sock_copy\n          newsk->sk_state = TCP_SYN_RECV;\n        -> tcp_init_xmit_timers\n      -> inet_sk_rx_dst_set\n      -> inet_csk_route_child_sock\n      -> tcp_ca_openreq_child\n        -> tcp_assign_congestion_control\n        -> tcp_set_ca_state TCP_CA_Open\n      -> tcp_sync_mss -> dst_mtu -> ipv4_mtu\n        -> tcp_mtu_to_mss\n        -> tcp_bound_to_half_wnd\n      -> dst_metric_advmss -> ipv4_default_advmss\n      -> tcp_initialize_rcv_mss\n      -> __inet_inherit_port\n        -> inet_bind_hash  // put newsk in bind_bucket\n        inet_csk(sk)->icsk_bind_hash = tb;\n      -> inet_ehash_nolisten\n        -> inet_ehash_insert(newsk, reqsk)\n          -> sk_nulls_del_node_init_rcu(osk)\n          -> __sk_nulls_add_node_rcu(sk, list)\n        -> sock_prot_inuse_add\n      -> tcp_move_syn\n    -> sock_rps_save_rxhash\n    -> tcp_synack_rtt_meas\n      -> skb_mstamp_us_delta\n      -> tcp_ack_update_rtt\n        -> tcp_update_rtt_min\n        -> tcp_rtt_estimator\n        -> tcp_set_rto\n    -> inet_csk_complete_hashdance\n      -> inet_csk_reqsk_queue_drop\n        -> reqsk_queue_unlink\n          -> reqsk_put(req)\n          return found(false)\n      -> reqsk_queue_removed\n        &inet_csk(sk)->icsk_accept_queue.qlen--\n      -> inet_csk_reqsk_queue_add\n        queue->rskq_accept_head = req  // first\n        -> sk_acceptq_added\n          sk->sk_ack_backlog++;  // listen_sk\n  -> tcp_child_process\n    -> tcp_rcv_state_process(child, skb)\n      -> tcp_validate_incoming\n      -> tcp_ack\n        -> tcp_ack_update_window\n        -> tcp_ecn_rcv_ecn_echo  // false\n        -> tcp_in_ack_event\n        return 1\n      switch(sk_state) case TCP_SYN_RECV:\n      -> inet_sk_rebuild_header  // icsk->icsk_af_ops->rebuild_header\n      -> tcp_init_congestion_control\n      -> tcp_mtup_init\n      -> tcp_init_buffer_space\n        -> tcp_fixup_rcvbuf\n        -> tcp_sndbuf_expand\n        -> tcp_full_space\n      tcp_set_state(sk, TCP_ESTABLISHED)\n      sk->sk_state_change -> sock_def_wakeup\n      -> tcp_init_metrics\n      -> tcp_update_pacing_rate\n      -> tcp_initialize_rcv_mss\n      -> tcp_fast_path_on\n      // out of switch\n      -> tcp_urg\n      switch TCP_ESTABLISHED\n        -> tcp_data_queue\n      -> tcp_data_snd_check\n      -> tcp_ack_snd_check\n    -> parent->sk_data_ready -> sock_def_readable -> wake_up_interruptible_sync_poll  After receiving ACK",
            "title": "Receive ACK"
        },
        {
            "location": "/kernel/callgraph/#active-open",
            "text": "",
            "title": "Active open"
        },
        {
            "location": "/kernel/callgraph/#connect",
            "text": "sys_connect\n  -> inet_stream_connect -> __inet_stream_connect\n    -> tcp_v4_connect (sk->sk_prot->connect)\n      -> ip_route_connect\n      tcp_set_state(sk, TCP_SYN_SENT)\n      -> inet_hash_connect\n        -> port_offset = inet_sk_port_offset(sk)\n          -> secure_ipv4_port_ephemeral(saddr, daddr, dport)\n            -> md5_transform\n        -> __inet_hash_connect(..., port_offset, __inet_check_established)\n          static uint32_t hint // counter\n          -> inet_get_local_port_range\n          -> inet_bind_bucket_create\n          -> inet_bind_hash\n            -> sk_add_bind_node\n          -> inet_ehash_nolisten\n            -> inet_ehash_insert\n              -> sk_ehashfn\n                -> inet_ehashfn\n                  -> __inet_ehashfn\n                    -> jhash_3words\n            -> sock_prot_inuse_add\n      -> ip_route_newports\n        -> ip_route_output_flow\n      -> secure_tcp_sequence_number(saddr, daddr, sport, dport)\n        -> md5_transform\n      -> tcp_connect\n        -> tcp_connect_init\n        -> sk_stream_alloc_skb\n        -> tcp_init_nondata_skb\n        -> tcp_connect_queue_skb\n        -> tcp_ecn_send_syn\n        -> tcp_transmit_skb\n          -> tcp_options_size = tcp_syn_options\n          tcp_header_size = tcp_options_size + sizeof(struct tcphdr);\n          -> skb_push(skb, tcp_header_size)\n          -> skb_reset_transport_header\n          -> skb_orphan\n          skb->destructor = tcp_wfree;\n          -> tcp_options_write\n          -> tcp_v4_send_check (icsk->icsk_af_ops->send_check)\n            -> __tcp_v4_send_check\n              skb->ip_summed == CHECKSUM_PARTIAL\n          -> ip_queue_xmit (icsk->icsk_af_ops->queue_xmit)\n            -> skb_push\n            -> skb_reset_network_header\n            iph->frag_off = htons(IP_DF);\n            -> ip_copy_addrs\n            -> ip_select_ident_segs\n            -> ip_local_out\n              -> __ip_local_out\n                -> ip_send_check\n                  -> ip_fast_csum\n                -> nf_hook { return 1; }\n              -> dst_output\n                -> ip_output (skb_dst(skb)->output)\n        -> inet_csk_reset_xmit_timer\n    sock->state = SS_CONNECTING;\n    err = -EINPROGRESS;\n    timeo = sock_sndtimeo() // NULL\n    return err  After  connect()",
            "title": "connect"
        },
        {
            "location": "/kernel/callgraph/#receive-synack",
            "text": "tcp_v4_rcv\n  -> __inet_lookup_skb\n    -> __inet_lookup\n      -> __inet_lookup_established  // found\n  -> tcp_v4_do_rcv  // sk_state == TCP_SYN_SENT\n    -> tcp_rcv_state_process\n      case TCP_SYN_SENT:\n      -> tcp_rcv_synsent_state_process\n        -> tcp_parse_options\n        if (th->ack)  // true\n        -> tcp_ecn_rcv_synack\n        -> tcp_init_wl\n        -> tcp_ack(FLAG_SLOWPATH)\n          // FLAG_SLOWPATH\n          -> tcp_ack_update_window\n            -> tcp_may_update_window  // true\n            -> tcp_update_wln\n            -> tcp_fast_path_check\n            -> tcp_sync_mss\n            -> tcp_snd_una_update\n          -> tcp_ecn_rcv_ecn_echo  // false\n          -> tcp_in_ack_event\n          -> tcp_clean_rtx_queue\n            -> tcp_ack_update_rtt\n            -> tcp_rearm_rto\n          -> tcp_rate_gen\n          -> tcp_cong_control\n          -> tcp_xmit_recovery\n        -> tcp_mtup_init\n        -> tcp_sync_mss\n        -> tcp_initialize_rcv_mss\n        -> tcp_finish_connect\n          -> tcp_set_state(sk, TCP_ESTABLISHED);\n          -> inet_sk_rx_dst_set (icsk->icsk_af_ops->sk_rx_dst_set)\n          -> inet_sk_rebuild_header (icsk->icsk_af_ops->rebuild_header)\n          -> tcp_init_metrics\n          -> tcp_init_congestion_control\n          -> tcp_init_buffer_space\n            -> tcp_fixup_rcvbuf\n            -> tcp_sndbuf_expand\n            -> tcp_full_space\n        -> tcp_send_ack\n          -> skb_reserve\n          -> tcp_init_nondata_skb\n          -> skb_set_tcp_pure_ack\n          -> skb_mstamp_get\n          -> tcp_transmit_skb\n            -> tcp_options_size = tcp_established_options  // 12\n            ...\n      -> tcp_urg\n      -> __kfree_skb\n      -> tcp_data_snd_check\n      return 0;",
            "title": "Receive SYN+ACK"
        },
        {
            "location": "/kernel/callgraph/#accept",
            "text": "sys_accept4\n  -> newsock = sock_alloc\n  -> newfd = get_unused_fd_flags\n  -> newfile = sock_alloc_file(newsock, ...)\n  -> inet_accept (sock->ops->accept)\n    -> sk2 = inet_csk_accept (sk1->sk_prot->accept)\n      queue = &icsk->icsk_accept_queue;\n      req = reqsk_queue_remove(queue, sk);\n        req = queue->rskq_accept_head;\n        -> sk_acceptq_removed(parent);  // sk->sk_ack_backlog--;\n      newsk = req->sk\n      -> release_sock(sk)\n      -> reqsk_put(req) -> reqsk_free\n      return newsk\n    -> sock_graft(sk2, newsock)\n  -> fd_install(newfd, newfile)",
            "title": "accept"
        },
        {
            "location": "/kernel/callgraph/#read",
            "text": "",
            "title": "read"
        },
        {
            "location": "/kernel/callgraph/#write",
            "text": "",
            "title": "write"
        },
        {
            "location": "/kernel/reuseport/",
            "text": "SO_REUSEPORT\n\n\n\n\nLinux 4.5 \nimproves UDP SO_REUSEPORT\n,\nLinux 4.6 \nImproves TCP SO_REUSEPORT\n.",
            "title": "SO_REUSEPRT"
        },
        {
            "location": "/kernel/reuseport/#so_reuseport",
            "text": "Linux 4.5  improves UDP SO_REUSEPORT ,\nLinux 4.6  Improves TCP SO_REUSEPORT .",
            "title": "SO_REUSEPORT"
        },
        {
            "location": "/kernel/changes/",
            "text": "4.9 - 2016-12-11\n\n\nLinux 4.9\n\n\n\n\nBBR congestion control algorithm\n\n\ntcp: use an RB tree for ooo receive queue \ncommit 9f5afeae51\n\n\n\n\n4.6 - 2016-05-15\n\n\nLinux 4.6\n\n\n\n\nFaster SO_REUSEPORT for TCP\n\n\n\n\n4.5 - 2016-03-13\n\n\nLinux 4.5\n\n\n\n\nFaster SO_REUSEPORT for UDP\n\n\nBetter epoll multithread scalability\n\n\n\n\n4.4 - 2016-01-10\n\n\nLinux 4.4\n\n\n\n\nTCP scalability\n\n\nLockless TCP listener\n\n\nSO_INCOMING_CPU\n\n\nTCP_NEW_SYN_RECV\n\n\n\n\n\n\n\n\ncommit ca6fb06518836ef9b65dc0aac02ff97704d52a05\nAuthor: Eric Dumazet <edumazet@google.com>\nDate:   Fri Oct 2 11:43:35 2015 -0700\n\n    tcp: attach SYNACK messages to request sockets instead of listener\n\n    If a listen backlog is very big (to avoid syncookies), then\n    the listener sk->sk_wmem_alloc is the main source of false\n    sharing, as we need to touch it twice per SYNACK re-transmit\n    and TX completion.\n\n    (One SYN packet takes listener lock once, but up to 6 SYNACK\n    are generated)\n\n    By attaching the skb to the request socket, we remove this\n    source of contention.\n\n    Tested:\n\n     listen(fd, 10485760); // single listener (no SO_REUSEPORT)\n     16 RX/TX queue NIC\n     Sustain a SYNFLOOD attack of ~320,000 SYN per second,\n     Sending ~1,400,000 SYNACK per second.\n     Perf profiles now show listener spinlock being next bottleneck.\n\n        20.29%  [kernel]  [k] queued_spin_lock_slowpath\n        10.06%  [kernel]  [k] __inet_lookup_established\n         5.12%  [kernel]  [k] reqsk_timer_handler\n         3.22%  [kernel]  [k] get_next_timer_interrupt\n         3.00%  [kernel]  [k] tcp_make_synack\n         2.77%  [kernel]  [k] ipt_do_table\n         2.70%  [kernel]  [k] run_timer_softirq\n         2.50%  [kernel]  [k] ip_finish_output\n         2.04%  [kernel]  [k] cascade\n\n    Signed-off-by: Eric Dumazet <edumazet@google.com>\n    Signed-off-by: David S. Miller <davem@davemloft.net>\n\n\n\n\ncommit 079096f103faca2dd87342cca6f23d4b34da8871\nAuthor: Eric Dumazet <edumazet@google.com>\nDate:   Fri Oct 2 11:43:32 2015 -0700\n\n    tcp/dccp: install syn_recv requests into ehash table\n\n    In this patch, we insert request sockets into TCP/DCCP\n    regular ehash table (where ESTABLISHED and TIMEWAIT sockets\n    are) instead of using the per listener hash table.\n\n    ACK packets find SYN_RECV pseudo sockets without having\n    to find and lock the listener.\n\n    In nominal conditions, this halves pressure on listener lock.\n\n    Note that this will allow for SO_REUSEPORT refinements,\n    so that we can select a listener using cpu/numa affinities instead\n    of the prior 'consistent hash', since only SYN packets will\n    apply this selection logic.\n\n    We will shrink listen_sock in the following patch to ease\n    code review.\n\n    Signed-off-by: Eric Dumazet <edumazet@google.com>\n    Cc: Ying Cai <ycai@google.com>\n    Cc: Willem de Bruijn <willemb@google.com>\n    Signed-off-by: David S. Miller <davem@davemloft.net>\n\n\n\n\n4.3 - 2015-11-01\n\n\nLinux 4.3\n\n\ncommit 9dea5dc921b5f4045a18c63eb92e84dc274d17eb\nAuthor: Andy Lutomirski <luto@kernel.org>\nDate:   Tue Jul 14 15:24:24 2015 -0700\n\n    x86/entry/syscalls: Wire up 32-bit direct socket calls\n\n    On x86_64, there's no socketcall syscall; instead all of the\n    socket calls are real syscalls.  For 32-bit programs, we're\n    stuck offering the socketcall syscall, but it would be nice to\n    expose the direct calls as well.  This will enable seccomp to\n    filter socket calls (for new userspace only, but that's fine for\n    some applications) and it will provide a tiny performance boost.\n\n\n\n\nglibc 2.23\n 2016-02-19.\nUbuntu 16.04 supports it, Debian 8 doesn't.\n\n\ncommit e5a5315e2d290fe34e0fb80996c713b8b802dcc9\nAuthor: Joseph Myers <joseph@codesourcery.com>\nDate:   Wed Dec 9 20:59:43 2015 +0000\n\n    Use direct socket syscalls for new kernels on i386, m68k, microblaze, sh.\n\n    Now that we have __ASSUME_* macros for direct socket syscalls to use\n    them instead of socketcall when they can be assumed to be available on\n    socketcall architectures, this patch defines those macros when\n    appropriate for i386, m68k, microblaze and sh (for 4.3, 4.3, all\n    supported kernels and 2.6.37, respectively; the only use of socketcall\n    support on microblaze is it allows accept4 and sendmmsg to be\n    supported on a wider range of kernel versions).\n\n\n\n\n4.2 - 2015-08-30\n\n\nLinux 4.2\n\n\ncommit 90c337da1524863838658078ec34241f45d8394d\nAuthor: Eric Dumazet <edumazet@google.com>\nDate:   Sat Jun 6 21:17:57 2015 -0700\n\n    inet: add IP_BIND_ADDRESS_NO_PORT to overcome bind(0) limitations\n\n    When an application needs to force a source IP on an active TCP socket\n    it has to use bind(IP, port=x).\n\n    As most applications do not want to deal with already used ports, x is\n    often set to 0, meaning the kernel is in charge to find an available\n    port.\n    But kernel does not know yet if this socket is going to be a listener or\n    be connected.\n    It has very limited choices (no full knowledge of final 4-tuple for a\n    connect())\n\n    With limited ephemeral port range (about 32K ports), it is very easy to\n    fill the space.\n\n    This patch adds a new SOL_IP socket option, asking kernel to ignore\n    the 0 port provided by application in bind(IP, port=0) and only\n    remember the given IP address.\n\n    The port will be automatically chosen at connect() time, in a way\n    that allows sharing a source port as long as the 4-tuples are unique.\n\n    This new feature is available for both IPv4 and IPv6 (Thanks Neal)",
            "title": "Changes"
        },
        {
            "location": "/kernel/changes/#49-2016-12-11",
            "text": "Linux 4.9   BBR congestion control algorithm  tcp: use an RB tree for ooo receive queue  commit 9f5afeae51",
            "title": "4.9 - 2016-12-11"
        },
        {
            "location": "/kernel/changes/#46-2016-05-15",
            "text": "Linux 4.6   Faster SO_REUSEPORT for TCP",
            "title": "4.6 - 2016-05-15"
        },
        {
            "location": "/kernel/changes/#45-2016-03-13",
            "text": "Linux 4.5   Faster SO_REUSEPORT for UDP  Better epoll multithread scalability",
            "title": "4.5 - 2016-03-13"
        },
        {
            "location": "/kernel/changes/#44-2016-01-10",
            "text": "Linux 4.4   TCP scalability  Lockless TCP listener  SO_INCOMING_CPU  TCP_NEW_SYN_RECV     commit ca6fb06518836ef9b65dc0aac02ff97704d52a05\nAuthor: Eric Dumazet <edumazet@google.com>\nDate:   Fri Oct 2 11:43:35 2015 -0700\n\n    tcp: attach SYNACK messages to request sockets instead of listener\n\n    If a listen backlog is very big (to avoid syncookies), then\n    the listener sk->sk_wmem_alloc is the main source of false\n    sharing, as we need to touch it twice per SYNACK re-transmit\n    and TX completion.\n\n    (One SYN packet takes listener lock once, but up to 6 SYNACK\n    are generated)\n\n    By attaching the skb to the request socket, we remove this\n    source of contention.\n\n    Tested:\n\n     listen(fd, 10485760); // single listener (no SO_REUSEPORT)\n     16 RX/TX queue NIC\n     Sustain a SYNFLOOD attack of ~320,000 SYN per second,\n     Sending ~1,400,000 SYNACK per second.\n     Perf profiles now show listener spinlock being next bottleneck.\n\n        20.29%  [kernel]  [k] queued_spin_lock_slowpath\n        10.06%  [kernel]  [k] __inet_lookup_established\n         5.12%  [kernel]  [k] reqsk_timer_handler\n         3.22%  [kernel]  [k] get_next_timer_interrupt\n         3.00%  [kernel]  [k] tcp_make_synack\n         2.77%  [kernel]  [k] ipt_do_table\n         2.70%  [kernel]  [k] run_timer_softirq\n         2.50%  [kernel]  [k] ip_finish_output\n         2.04%  [kernel]  [k] cascade\n\n    Signed-off-by: Eric Dumazet <edumazet@google.com>\n    Signed-off-by: David S. Miller <davem@davemloft.net>  commit 079096f103faca2dd87342cca6f23d4b34da8871\nAuthor: Eric Dumazet <edumazet@google.com>\nDate:   Fri Oct 2 11:43:32 2015 -0700\n\n    tcp/dccp: install syn_recv requests into ehash table\n\n    In this patch, we insert request sockets into TCP/DCCP\n    regular ehash table (where ESTABLISHED and TIMEWAIT sockets\n    are) instead of using the per listener hash table.\n\n    ACK packets find SYN_RECV pseudo sockets without having\n    to find and lock the listener.\n\n    In nominal conditions, this halves pressure on listener lock.\n\n    Note that this will allow for SO_REUSEPORT refinements,\n    so that we can select a listener using cpu/numa affinities instead\n    of the prior 'consistent hash', since only SYN packets will\n    apply this selection logic.\n\n    We will shrink listen_sock in the following patch to ease\n    code review.\n\n    Signed-off-by: Eric Dumazet <edumazet@google.com>\n    Cc: Ying Cai <ycai@google.com>\n    Cc: Willem de Bruijn <willemb@google.com>\n    Signed-off-by: David S. Miller <davem@davemloft.net>",
            "title": "4.4 - 2016-01-10"
        },
        {
            "location": "/kernel/changes/#43-2015-11-01",
            "text": "Linux 4.3  commit 9dea5dc921b5f4045a18c63eb92e84dc274d17eb\nAuthor: Andy Lutomirski <luto@kernel.org>\nDate:   Tue Jul 14 15:24:24 2015 -0700\n\n    x86/entry/syscalls: Wire up 32-bit direct socket calls\n\n    On x86_64, there's no socketcall syscall; instead all of the\n    socket calls are real syscalls.  For 32-bit programs, we're\n    stuck offering the socketcall syscall, but it would be nice to\n    expose the direct calls as well.  This will enable seccomp to\n    filter socket calls (for new userspace only, but that's fine for\n    some applications) and it will provide a tiny performance boost.  glibc 2.23  2016-02-19.\nUbuntu 16.04 supports it, Debian 8 doesn't.  commit e5a5315e2d290fe34e0fb80996c713b8b802dcc9\nAuthor: Joseph Myers <joseph@codesourcery.com>\nDate:   Wed Dec 9 20:59:43 2015 +0000\n\n    Use direct socket syscalls for new kernels on i386, m68k, microblaze, sh.\n\n    Now that we have __ASSUME_* macros for direct socket syscalls to use\n    them instead of socketcall when they can be assumed to be available on\n    socketcall architectures, this patch defines those macros when\n    appropriate for i386, m68k, microblaze and sh (for 4.3, 4.3, all\n    supported kernels and 2.6.37, respectively; the only use of socketcall\n    support on microblaze is it allows accept4 and sendmmsg to be\n    supported on a wider range of kernel versions).",
            "title": "4.3 - 2015-11-01"
        },
        {
            "location": "/kernel/changes/#42-2015-08-30",
            "text": "Linux 4.2  commit 90c337da1524863838658078ec34241f45d8394d\nAuthor: Eric Dumazet <edumazet@google.com>\nDate:   Sat Jun 6 21:17:57 2015 -0700\n\n    inet: add IP_BIND_ADDRESS_NO_PORT to overcome bind(0) limitations\n\n    When an application needs to force a source IP on an active TCP socket\n    it has to use bind(IP, port=x).\n\n    As most applications do not want to deal with already used ports, x is\n    often set to 0, meaning the kernel is in charge to find an available\n    port.\n    But kernel does not know yet if this socket is going to be a listener or\n    be connected.\n    It has very limited choices (no full knowledge of final 4-tuple for a\n    connect())\n\n    With limited ephemeral port range (about 32K ports), it is very easy to\n    fill the space.\n\n    This patch adds a new SOL_IP socket option, asking kernel to ignore\n    the 0 port provided by application in bind(IP, port=0) and only\n    remember the given IP address.\n\n    The port will be automatically chosen at connect() time, in a way\n    that allows sharing a source port as long as the 4-tuples are unique.\n\n    This new feature is available for both IPv4 and IPv6 (Thanks Neal)",
            "title": "4.2 - 2015-08-30"
        },
        {
            "location": "/lcc/",
            "text": "Notes on LCC\n\n\nCallgraph of parsing expressions\n\n\n\n\nCallgraph of parsing statements\n\n\n\n\nCalltree of compiling an empty program\n\n\nCalltree of lcc 4.2\n for following simple program:\n\n\nint main()\n{\n  return 0;\n}",
            "title": "lcc"
        },
        {
            "location": "/lcc/#notes-on-lcc",
            "text": "",
            "title": "Notes on LCC"
        },
        {
            "location": "/lcc/#callgraph-of-parsing-expressions",
            "text": "",
            "title": "Callgraph of parsing expressions"
        },
        {
            "location": "/lcc/#callgraph-of-parsing-statements",
            "text": "",
            "title": "Callgraph of parsing statements"
        },
        {
            "location": "/lcc/#calltree-of-compiling-an-empty-program",
            "text": "Calltree of lcc 4.2  for following simple program:  int main()\n{\n  return 0;\n}",
            "title": "Calltree of compiling an empty program"
        },
        {
            "location": "/lua/",
            "text": "Notes on Lua implementation\n\n\nParser\n\n\nLua uses a recursive descent parser, which generates code on-the-fly, similar to PL/0.\n\n\nCallgraph:\n\n\n\nCalltree\n\n\nCalltree of Lua 5.3\n for following simple program:\n\n\n#include \"lua.hpp\"\n\nint main()\n{\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);  // open standard libraries\n  luaL_loadstring(L, R\"(\n      x = 10 * 5\n      print(x)\n      )\");\n  lua_pcall(L, 0, LUA_MULTRET, 0);\n  lua_close(L);\n}\n\n\n\n\nReleases",
            "title": "Lua"
        },
        {
            "location": "/lua/#notes-on-lua-implementation",
            "text": "",
            "title": "Notes on Lua implementation"
        },
        {
            "location": "/lua/#parser",
            "text": "Lua uses a recursive descent parser, which generates code on-the-fly, similar to PL/0.  Callgraph:",
            "title": "Parser"
        },
        {
            "location": "/lua/#calltree",
            "text": "Calltree of Lua 5.3  for following simple program:  #include \"lua.hpp\"\n\nint main()\n{\n  lua_State *L = luaL_newstate();\n  luaL_openlibs(L);  // open standard libraries\n  luaL_loadstring(L, R\"(\n      x = 10 * 5\n      print(x)\n      )\");\n  lua_pcall(L, 0, LUA_MULTRET, 0);\n  lua_close(L);\n}",
            "title": "Calltree"
        },
        {
            "location": "/lua/#releases",
            "text": "",
            "title": "Releases"
        },
        {
            "location": "/mem/",
            "text": "Notes on C/C++ memory model\n\n\n\n\nThreads and memory model for C++\n by Hans Boehm\n\n\nGCC 4.7 and above does the right thing!\n\n\n\n\n\n\nThe C11 and C++11 Concurrency Model\n by Mark John Batty\n\n\nC/C++11 mappings to processors\n by Alexander Terekhov, Paul McKenney, et al.\n\n\nAwesome Lock-Free",
            "title": "mem"
        },
        {
            "location": "/mem/#notes-on-cc-memory-model",
            "text": "Threads and memory model for C++  by Hans Boehm  GCC 4.7 and above does the right thing!    The C11 and C++11 Concurrency Model  by Mark John Batty  C/C++11 mappings to processors  by Alexander Terekhov, Paul McKenney, et al.  Awesome Lock-Free",
            "title": "Notes on C/C++ memory model"
        },
        {
            "location": "/ssl/",
            "text": "Notes on SSL/TLS\n\n\nChaCha20, Poly1305, X25519\n\n\n\n\nRFC7539\n defines ChaCha20 and Poly1305\n\n\nRFC7905\n adds TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (0xCCA8) etc to TLS 1.2\n\n\nThere is an old version of ECDHE_RSA_CHACHA20_POLY1305_OLD (0xCC13) exists in \ndraft\n and OpenSSL \ncode\n.\n\n\nOpenSSL will prefer AES if hardware supports it, otherwise prefer ChaCha20 over AES, in \nssl_create_cipher_list()\n.\n\n\nGo 1.8 will support TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 \ncommit 67d8226b48\n\n\n\n\ncommit 67d8226b4862f0f8deb4dc6fa8617017ecb0f32b\nAuthor: Adam Langley <agl@golang.org>\nDate:   Wed Oct 12 10:46:43 2016 -0700\n\n    crypto/tls: support ChaCha20-Poly1305.\n\n    This change adds support for the ChaCha20-Poly1305 AEAD to crypto/tls,\n    as specified in https://tools.ietf.org/html/rfc7905.\n\n    Fixes #15499.\n\n    Change-Id: Iaa689be90e03f208c40b574eca399e56f3c7ecf1\n    Reviewed-on: https://go-review.googlesource.com/30957\n    Run-TryBot: Adam Langley <agl@golang.org>\n    TryBot-Result: Gobot Gobot <gobot@golang.org>\n    Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org>\n\n\n\n\n\n\nGo perfers X25519 over P-256, P-384 and P-521. \ncommit 9e98e7e668\n\n\n\n\ncommit 9e98e7e6686a500f87352e3721038d194b1db33c\nAuthor: Adam Langley <agl@golang.org>\nDate:   Tue Oct 11 15:08:35 2016 -0700\n\n    crypto/tls: enable X25519 by default.\n\n    Since this changes the offered curves in the ClientHello, all the test\n    data needs to be updated too.\n\n    Change-Id: I227934711104349c0f0eab11d854e5a2adcbc363\n    Reviewed-on: https://go-review.googlesource.com/30825\n    Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org>\n\n\n\n\nAPI changes\n\n\n\n\nOpenSSL 1.0.2 has an undocumented \nSSL_get_server_tmp_key()\n function to get the curve used in handshaking, this is for \nopenssl s_client\n command. http://crypto.stackexchange.com/questions/11310/with-openssl-and-ecdhe-how-to-show-the-actual-curve-being-used\n\n\nOpenSSL 1.0.1 only allows setting one curve with \nSSL_CTX_set_tmp_ecdh()\n (or use callbacks), OpenSSL 1.0.2 allows setting curve list with \nSSL_CTX_set1_curves()\n and \nSSL_CTX_set1_curves_list()\n\n\nOpenSSL 1.0.2 adds \nSSL_CTX_set_ecdh_auto()\n, but OpenSSL 1.1.0 makes it a no-op.\n\n\n\n\nOpenSSL 1.1.0 provides \nSSL_SESSION_get_master_key()\n function.\n\n\n\n\n\n\nGo 1.8 supports KeyLogWriter \ncommit 320bd562cb\n\n\n\n\n\n\ncommit 320bd562cbb24a01beb02706c42d06a290160645\nAuthor: Joonas Kuorilehto <joneskoo@derbian.fi>\nDate:   Sat Aug 20 14:41:42 2016 +0300\n\n    crypto/tls: add KeyLogWriter for debugging\n\n    Add support for writing TLS client random and master secret\n    in NSS key log format.\n\n    https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format\n\n    Normally this is enabled by a developer debugging TLS based\n    applications, especially HTTP/2, by setting the KeyLogWriter\n    to an open file. The keys negotiated in handshake are then\n    logged and can be used to decrypt TLS sessions e.g. in Wireshark.\n\n    Applications may choose to add support similar to NSS where this\n    is enabled by environment variable, but no such mechanism is\n    built in to Go. Instead each application must explicitly enable.\n\n    Fixes #13057.\n\n    Change-Id: If6edd2d58999903e8390b1674ba4257ecc747ae1\n    Reviewed-on: https://go-review.googlesource.com/27434\n    Run-TryBot: Brad Fitzpatrick <bradfitz@golang.org>\n    TryBot-Result: Gobot Gobot <gobot@golang.org>\n    Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org>\n\n\n\n\nMemory footprint\n\n\n\n\nBefore OpenSSL 1.1.0, there is a free-list (~32k per SSL) unless disable with OPENSSL_NO_BUF_FREELISTS or set SSL_MODE_RELEASE_BUFFERS, the free list is freed in \nSSL_CTX_free()\n not \nSSL_free()\n.\n\n\n\n\ncommit 63c574f6a6\n in OpenSSL:\n\n\ncommit 63c574f6a639cfa3f53476080054526e6bfa3bc9\nAuthor: Rich Salz <rsalz@openssl.org>\nDate:   Tue Jan 27 16:43:53 2015 -0500\n\n    OPENSSL_NO_XXX cleanup: OPENSSL_NO_BUF_FREELISTS\n\n    Remove OPENSSL_NO_BUF_FREELISTS. This was turned on by default,\n    so the work here is removing the 'maintain our own freelist' code.\n    Also removed a minor old Windows-multibyte/widechar conversion flag.\n\n\n\n\ncommit 72e56bc494\n in LibreSSL:\n\n\ncommit 72e56bc4947e53cec535f2fc84e00a3c278edf29\nAuthor: tedu <>\nDate:   Wed Apr 16 21:16:33 2014 +0000\n\n    TANSTAAFL - delete the buf freelist code. if you need a better malloc, get\n    a better malloc. ok beck deraadt\n\ndiff --git a/src/lib/libssl/s3_both.c b/src/lib/libssl/s3_both.c\n\n\n\n\nTANSTAAFL - There ain't no such thing as a free lunch\n\n\ncommit 983f6bdb58\n in BoringSSL:\n\n\ncommit 983f6bdb5888d7074d7ee67d5e3741bcf1027108\nAuthor: Alex Chernyakhovsky <achernya@google.com>\nDate:   Sun Aug 3 15:48:35 2014 -0400\n\n    Set OPENSSL_NO_BUF_FREELISTS\n\n    The memory freelist maintained by OpenSSL claims to be a performance\n    optimization for platforms that have a slow malloc/free\n    implementation. This should not be the case on modern\n    linux/glibc. Remove the freelist as it poses a potential security\n    hazard of buffer-reuse that is of \"initialized\" memory that will not\n    be caught be tools such as valgrind.\n\n    Change-Id: I3cfa6a05f9bdfbbba7820060bae5a673dee43014\n    Reviewed-on: https://boringssl-review.googlesource.com/1385\n    Reviewed-by: Adam Langley <agl@google.com>\n\n\n\n\n\n\nAfter \ncommit b8d28cf532\n BoringSSL calls \nssl_write_buffer_flush()\n and \nssl_write_buffer_clear()\n for each \nSSL_write()\n, so its memory footprint is much smaller than other SSL libraries (~32k) when no data is pending.\n\n\n\n\nPerformance notes\n\n\nThe P-256 curve, also known as \nprime256v1\n or \nsecp256r1\n is widely used in ECDHE_RSA key exchange.\n\n\nFor x86-64, there is a faster implementation, enabled by \n./config enable-ec_nistp_64_gcc_128\n.\n\n\nFuther speed up of P-256 in OpenSSL 1.1.0 and BoringSSL:\n\n\n\n\ncommit 4d3fa06fce\n for OpenSSL 1.1.0\n\n\ncommit 3842a64d36\n backports to 1.0.2 branch\n\n\ncommit 1895493868\n for BoringSSL\n\n\n\n\ncommit 18954938684e269ccd59152027d2244040e2b819\nAuthor: Adam Langley <agl@google.com>\nDate:   Tue Nov 3 14:02:04 2015 -0800\n\n    Add Intel's P-256\n\n    This change incorporates Intel's P-256 implementation. The record of\n    Intel's submission under CLA is in internal bug number 25330687.\n\n    Before:\n    Did 3582 ECDH P-256 operations in 1049114us (3414.3 ops/sec)\n    Did 8525 ECDSA P-256 signing operations in 1028778us (8286.5 ops/sec)\n    Did 3487 ECDSA P-256 verify operations in 1008996us (3455.9 ops/sec)\n    build/tool/bssl is 1434704 bytes after strip -s\n\n    After:\n    Did 8618 ECDH P-256 operations in 1027884us (8384.2 ops/sec)\n    Did 21000 ECDSA P-256 signing operations in 1049490us (20009.7 ops/sec)\n    Did 8268 ECDSA P-256 verify operations in 1079481us (7659.2 ops/sec)\n    build/tool/bssl is 1567216 bytes after strip -s\n\n    Change-Id: I147971a8e19849779c8ed7e20310d41bd4962299\n    Reviewed-on: https://boringssl-review.googlesource.com/6371\n    Reviewed-by: Adam Langley <agl@google.com>\n\n\n\n\nNone of them are available in LibreSSL as of Jan 19, 2017. \nIssue 259\n.\n\n\nCryptography\n\n\n\n\ncs387 Applied Cryptography on udacity\n\n\nElliptic Curve Cryptography: ECDH and ECDSA\n\n\nEverything you need to know about cryptography in 1 hour",
            "title": "SSL"
        },
        {
            "location": "/ssl/#notes-on-ssltls",
            "text": "",
            "title": "Notes on SSL/TLS"
        },
        {
            "location": "/ssl/#chacha20-poly1305-x25519",
            "text": "RFC7539  defines ChaCha20 and Poly1305  RFC7905  adds TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (0xCCA8) etc to TLS 1.2  There is an old version of ECDHE_RSA_CHACHA20_POLY1305_OLD (0xCC13) exists in  draft  and OpenSSL  code .  OpenSSL will prefer AES if hardware supports it, otherwise prefer ChaCha20 over AES, in  ssl_create_cipher_list() .  Go 1.8 will support TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256  commit 67d8226b48   commit 67d8226b4862f0f8deb4dc6fa8617017ecb0f32b\nAuthor: Adam Langley <agl@golang.org>\nDate:   Wed Oct 12 10:46:43 2016 -0700\n\n    crypto/tls: support ChaCha20-Poly1305.\n\n    This change adds support for the ChaCha20-Poly1305 AEAD to crypto/tls,\n    as specified in https://tools.ietf.org/html/rfc7905.\n\n    Fixes #15499.\n\n    Change-Id: Iaa689be90e03f208c40b574eca399e56f3c7ecf1\n    Reviewed-on: https://go-review.googlesource.com/30957\n    Run-TryBot: Adam Langley <agl@golang.org>\n    TryBot-Result: Gobot Gobot <gobot@golang.org>\n    Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org>   Go perfers X25519 over P-256, P-384 and P-521.  commit 9e98e7e668   commit 9e98e7e6686a500f87352e3721038d194b1db33c\nAuthor: Adam Langley <agl@golang.org>\nDate:   Tue Oct 11 15:08:35 2016 -0700\n\n    crypto/tls: enable X25519 by default.\n\n    Since this changes the offered curves in the ClientHello, all the test\n    data needs to be updated too.\n\n    Change-Id: I227934711104349c0f0eab11d854e5a2adcbc363\n    Reviewed-on: https://go-review.googlesource.com/30825\n    Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org>",
            "title": "ChaCha20, Poly1305, X25519"
        },
        {
            "location": "/ssl/#api-changes",
            "text": "OpenSSL 1.0.2 has an undocumented  SSL_get_server_tmp_key()  function to get the curve used in handshaking, this is for  openssl s_client  command. http://crypto.stackexchange.com/questions/11310/with-openssl-and-ecdhe-how-to-show-the-actual-curve-being-used  OpenSSL 1.0.1 only allows setting one curve with  SSL_CTX_set_tmp_ecdh()  (or use callbacks), OpenSSL 1.0.2 allows setting curve list with  SSL_CTX_set1_curves()  and  SSL_CTX_set1_curves_list()  OpenSSL 1.0.2 adds  SSL_CTX_set_ecdh_auto() , but OpenSSL 1.1.0 makes it a no-op.   OpenSSL 1.1.0 provides  SSL_SESSION_get_master_key()  function.    Go 1.8 supports KeyLogWriter  commit 320bd562cb    commit 320bd562cbb24a01beb02706c42d06a290160645\nAuthor: Joonas Kuorilehto <joneskoo@derbian.fi>\nDate:   Sat Aug 20 14:41:42 2016 +0300\n\n    crypto/tls: add KeyLogWriter for debugging\n\n    Add support for writing TLS client random and master secret\n    in NSS key log format.\n\n    https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format\n\n    Normally this is enabled by a developer debugging TLS based\n    applications, especially HTTP/2, by setting the KeyLogWriter\n    to an open file. The keys negotiated in handshake are then\n    logged and can be used to decrypt TLS sessions e.g. in Wireshark.\n\n    Applications may choose to add support similar to NSS where this\n    is enabled by environment variable, but no such mechanism is\n    built in to Go. Instead each application must explicitly enable.\n\n    Fixes #13057.\n\n    Change-Id: If6edd2d58999903e8390b1674ba4257ecc747ae1\n    Reviewed-on: https://go-review.googlesource.com/27434\n    Run-TryBot: Brad Fitzpatrick <bradfitz@golang.org>\n    TryBot-Result: Gobot Gobot <gobot@golang.org>\n    Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org>",
            "title": "API changes"
        },
        {
            "location": "/ssl/#memory-footprint",
            "text": "Before OpenSSL 1.1.0, there is a free-list (~32k per SSL) unless disable with OPENSSL_NO_BUF_FREELISTS or set SSL_MODE_RELEASE_BUFFERS, the free list is freed in  SSL_CTX_free()  not  SSL_free() .   commit 63c574f6a6  in OpenSSL:  commit 63c574f6a639cfa3f53476080054526e6bfa3bc9\nAuthor: Rich Salz <rsalz@openssl.org>\nDate:   Tue Jan 27 16:43:53 2015 -0500\n\n    OPENSSL_NO_XXX cleanup: OPENSSL_NO_BUF_FREELISTS\n\n    Remove OPENSSL_NO_BUF_FREELISTS. This was turned on by default,\n    so the work here is removing the 'maintain our own freelist' code.\n    Also removed a minor old Windows-multibyte/widechar conversion flag.  commit 72e56bc494  in LibreSSL:  commit 72e56bc4947e53cec535f2fc84e00a3c278edf29\nAuthor: tedu <>\nDate:   Wed Apr 16 21:16:33 2014 +0000\n\n    TANSTAAFL - delete the buf freelist code. if you need a better malloc, get\n    a better malloc. ok beck deraadt\n\ndiff --git a/src/lib/libssl/s3_both.c b/src/lib/libssl/s3_both.c  TANSTAAFL - There ain't no such thing as a free lunch  commit 983f6bdb58  in BoringSSL:  commit 983f6bdb5888d7074d7ee67d5e3741bcf1027108\nAuthor: Alex Chernyakhovsky <achernya@google.com>\nDate:   Sun Aug 3 15:48:35 2014 -0400\n\n    Set OPENSSL_NO_BUF_FREELISTS\n\n    The memory freelist maintained by OpenSSL claims to be a performance\n    optimization for platforms that have a slow malloc/free\n    implementation. This should not be the case on modern\n    linux/glibc. Remove the freelist as it poses a potential security\n    hazard of buffer-reuse that is of \"initialized\" memory that will not\n    be caught be tools such as valgrind.\n\n    Change-Id: I3cfa6a05f9bdfbbba7820060bae5a673dee43014\n    Reviewed-on: https://boringssl-review.googlesource.com/1385\n    Reviewed-by: Adam Langley <agl@google.com>   After  commit b8d28cf532  BoringSSL calls  ssl_write_buffer_flush()  and  ssl_write_buffer_clear()  for each  SSL_write() , so its memory footprint is much smaller than other SSL libraries (~32k) when no data is pending.",
            "title": "Memory footprint"
        },
        {
            "location": "/ssl/#performance-notes",
            "text": "The P-256 curve, also known as  prime256v1  or  secp256r1  is widely used in ECDHE_RSA key exchange.  For x86-64, there is a faster implementation, enabled by  ./config enable-ec_nistp_64_gcc_128 .  Futher speed up of P-256 in OpenSSL 1.1.0 and BoringSSL:   commit 4d3fa06fce  for OpenSSL 1.1.0  commit 3842a64d36  backports to 1.0.2 branch  commit 1895493868  for BoringSSL   commit 18954938684e269ccd59152027d2244040e2b819\nAuthor: Adam Langley <agl@google.com>\nDate:   Tue Nov 3 14:02:04 2015 -0800\n\n    Add Intel's P-256\n\n    This change incorporates Intel's P-256 implementation. The record of\n    Intel's submission under CLA is in internal bug number 25330687.\n\n    Before:\n    Did 3582 ECDH P-256 operations in 1049114us (3414.3 ops/sec)\n    Did 8525 ECDSA P-256 signing operations in 1028778us (8286.5 ops/sec)\n    Did 3487 ECDSA P-256 verify operations in 1008996us (3455.9 ops/sec)\n    build/tool/bssl is 1434704 bytes after strip -s\n\n    After:\n    Did 8618 ECDH P-256 operations in 1027884us (8384.2 ops/sec)\n    Did 21000 ECDSA P-256 signing operations in 1049490us (20009.7 ops/sec)\n    Did 8268 ECDSA P-256 verify operations in 1079481us (7659.2 ops/sec)\n    build/tool/bssl is 1567216 bytes after strip -s\n\n    Change-Id: I147971a8e19849779c8ed7e20310d41bd4962299\n    Reviewed-on: https://boringssl-review.googlesource.com/6371\n    Reviewed-by: Adam Langley <agl@google.com>  None of them are available in LibreSSL as of Jan 19, 2017.  Issue 259 .",
            "title": "Performance notes"
        },
        {
            "location": "/ssl/#cryptography",
            "text": "cs387 Applied Cryptography on udacity  Elliptic Curve Cryptography: ECDH and ECDSA  Everything you need to know about cryptography in 1 hour",
            "title": "Cryptography"
        },
        {
            "location": "/links/",
            "text": "Links\n\n\nMaths\n\n\n\n\nTheory and Applications of Markov Chains to Finance\n by Kevin Atteson\n\n\n\n\nDFT/FFT\n\n\n\n\n X_k = \\sum_{n=0}^{N-1} x_n e^{-j 2 \\pi k n / N} \n\n\n\n\n\n\nWiki\n\n\nDFT matrix\n\n\nSmith's Guide to DSP, ch.8\n by Steven W. Smith\n\n\nMathematics of the Discrete Fourier Transform\n by Julius O. Smith\n\n\nThe Discrete Fourier Transform\n by Ivan W. Selenick and Gerald Schuller.  From chapter 2 of \nThe Transform and Data Compression Handbook\n ed. by \nKamisetty Ramam Rao\n and Patrick C. Yip\n\n\n\n\nDigital Sinusoid Generators\n\n\n\n\nDTMF Tone Generation and Detection\n by Gunter Schmer\n\n\nDigital Waveguide Oscillator\n by Julius O. Smith\n\n\nEffect Design Part 3 Oscillators: Sinusoidal and Pseudonoise\n by Jon Dattorro\n\n\nA sine generation algorithm for VLSI applications\n by John W. Gordon and Julius O. Smith\n\n\nThe Second-Order Digital Waveguide Oscillator\n by Julius O. Smith and Perry R. Cook\n\n\nAN-263 Sine Wave Generation Techniques\n\n\n5 ways to generate a sine wave",
            "title": "Links"
        },
        {
            "location": "/links/#links",
            "text": "",
            "title": "Links"
        },
        {
            "location": "/links/#maths",
            "text": "Theory and Applications of Markov Chains to Finance  by Kevin Atteson",
            "title": "Maths"
        },
        {
            "location": "/links/#dftfft",
            "text": "X_k = \\sum_{n=0}^{N-1} x_n e^{-j 2 \\pi k n / N}     Wiki  DFT matrix  Smith's Guide to DSP, ch.8  by Steven W. Smith  Mathematics of the Discrete Fourier Transform  by Julius O. Smith  The Discrete Fourier Transform  by Ivan W. Selenick and Gerald Schuller.  From chapter 2 of  The Transform and Data Compression Handbook  ed. by  Kamisetty Ramam Rao  and Patrick C. Yip",
            "title": "DFT/FFT"
        },
        {
            "location": "/links/#digital-sinusoid-generators",
            "text": "DTMF Tone Generation and Detection  by Gunter Schmer  Digital Waveguide Oscillator  by Julius O. Smith  Effect Design Part 3 Oscillators: Sinusoidal and Pseudonoise  by Jon Dattorro  A sine generation algorithm for VLSI applications  by John W. Gordon and Julius O. Smith  The Second-Order Digital Waveguide Oscillator  by Julius O. Smith and Perry R. Cook  AN-263 Sine Wave Generation Techniques  5 ways to generate a sine wave",
            "title": "Digital Sinusoid Generators"
        }
    ]
}