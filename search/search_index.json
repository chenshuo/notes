{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Shuo Chen's notes on various topics","title":"Home"},{"location":"#shuo-chens-notes-on-various-topics","text":"","title":"Shuo Chen's notes on various topics"},{"location":"bugs/","text":"Interesting bugs in open source projects GCC Bug 54812 : private =default destructor is public Delete expression doesn't respect access of defaulted destructor struct Base { private: ~Base() = default; }; int main() { Base* p = new Base; delete p; } Quote: The bug affects protected destructors too, and they're commonly used for base classes to prevent deletion via pointer-to-base. Fixed in 4.9.0, by r203985 . Test case added by r204057 . Glibc strstr(3) Since glibc 2.9, strstr(3) may use Two Way algorithm in some cases, but the impl. had several bugs: Bug 12092 Bug 12100 Bug 14602 More? getpid(2) no longer caches PID Since glibc 2.25 , getpid(2) no longer caches PID, released on 2017-02-05. Ubuntu 18.04, Debian 10 and CentOS 8 contain this change. Quote from man 2 getpid : From glibc version 2.3.4 up to and including version 2.24, the glibc wrapper function for getpid() cached PIDs, with the goal of avoiding additional system calls when a process calls getpid() repeatedly. ... Because of the aforementioned problems, since glibc version 2.25, the PID cache is removed: calls to getpid() always invoke the actual system call, rather than returning a cached value. In a tight loop, it takes about 200ns for getpid(2) on z420 (E5-1620 3.6GHz) running Linux 5.10. Kernel write(2) not thread-safe Fixed in v3.14, released in 2014-03-30. Ubuntu 14.04 has this bug, Debian 8 doesn't. commit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4 Author: Linus Torvalds <torvalds@linux-foundation.org> Date: Mon Mar 3 09:36:58 2014 -0800 vfs: atomic f_pos accesses as per POSIX Our write() system call has always been atomic in the sense that you get the expected thread-safe contiguous write, but we haven't actually guaranteed that concurrent writes are serialized wrt f_pos accesses, so threads (or processes) that share a file descriptor and use \"write()\" concurrently would quite likely overwrite each others data. This violates POSIX.1-2008/SUSv4 Section XSI 2.9.7 that says: \"2.9.7 Thread Interactions with Regular File Operations All of the following functions shall be atomic with respect to each other in the effects specified in POSIX.1-2008 when they operate on regular files or symbolic links: [...]\" and one of the effects is the file position update. This unprotected file position behavior is not new behavior, and nobody has ever cared. Until now. Yongzhi Pan reported unexpected behavior to Michael Kerrisk that was due to this. This resolves the issue with a f_pos-specific lock that is taken by read/write/lseek on file descriptors that may be shared across threads or processes. Reported-by: Yongzhi Pan <panyongzhi@gmail.com> Reported-by: Michael Kerrisk <mtk.manpages@gmail.com> Cc: Al Viro <viro@zeniv.linux.org.uk> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org> Signed-off-by: Al Viro <viro@zeniv.linux.org.uk> $ man 2 write BUGS According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 (\"Thread Interactions with Regular File Operations\"): All of the following functions shall be atomic with respect to each other in the effects specified in POSIX.1-2008 when they operate on regular files or symbolic links: ... Among the APIs subsequently listed are write() and writev(2). And among the effects that should be atomic across threads (and processes) are updates of the file offset. However, on Linux before version 3.14, this was not the case: if two processes that share an open file description (see open(2)) perform a write() (or writev(2)) at the same time, then the I/O operations were not atomic with respect updating the file offset, with the result that the blocks of data output by the two processes might (incorrectly) overlap. This problem was fixed in Linux 3.14. Java \"+=\" applied to String operands can provoke side effects Introduced in JDK9, fixed in JDK10 but not JDK9. Why does array[idx++]+=\u201ca\u201d increase idx once in Java 8 but twice in Java 9 and 10?","title":"Bugs"},{"location":"bugs/#interesting-bugs-in-open-source-projects","text":"","title":"Interesting bugs in open source projects"},{"location":"bugs/#gcc","text":"","title":"GCC"},{"location":"bugs/#bug-54812-private-default-destructor-is-public","text":"Delete expression doesn't respect access of defaulted destructor struct Base { private: ~Base() = default; }; int main() { Base* p = new Base; delete p; } Quote: The bug affects protected destructors too, and they're commonly used for base classes to prevent deletion via pointer-to-base. Fixed in 4.9.0, by r203985 . Test case added by r204057 .","title":"Bug 54812: private =default destructor is public"},{"location":"bugs/#glibc","text":"","title":"Glibc"},{"location":"bugs/#strstr3","text":"Since glibc 2.9, strstr(3) may use Two Way algorithm in some cases, but the impl. had several bugs: Bug 12092 Bug 12100 Bug 14602 More?","title":"strstr(3)"},{"location":"bugs/#getpid2-no-longer-caches-pid","text":"Since glibc 2.25 , getpid(2) no longer caches PID, released on 2017-02-05. Ubuntu 18.04, Debian 10 and CentOS 8 contain this change. Quote from man 2 getpid : From glibc version 2.3.4 up to and including version 2.24, the glibc wrapper function for getpid() cached PIDs, with the goal of avoiding additional system calls when a process calls getpid() repeatedly. ... Because of the aforementioned problems, since glibc version 2.25, the PID cache is removed: calls to getpid() always invoke the actual system call, rather than returning a cached value. In a tight loop, it takes about 200ns for getpid(2) on z420 (E5-1620 3.6GHz) running Linux 5.10.","title":"getpid(2) no longer caches PID"},{"location":"bugs/#kernel","text":"","title":"Kernel"},{"location":"bugs/#write2-not-thread-safe","text":"Fixed in v3.14, released in 2014-03-30. Ubuntu 14.04 has this bug, Debian 8 doesn't. commit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4 Author: Linus Torvalds <torvalds@linux-foundation.org> Date: Mon Mar 3 09:36:58 2014 -0800 vfs: atomic f_pos accesses as per POSIX Our write() system call has always been atomic in the sense that you get the expected thread-safe contiguous write, but we haven't actually guaranteed that concurrent writes are serialized wrt f_pos accesses, so threads (or processes) that share a file descriptor and use \"write()\" concurrently would quite likely overwrite each others data. This violates POSIX.1-2008/SUSv4 Section XSI 2.9.7 that says: \"2.9.7 Thread Interactions with Regular File Operations All of the following functions shall be atomic with respect to each other in the effects specified in POSIX.1-2008 when they operate on regular files or symbolic links: [...]\" and one of the effects is the file position update. This unprotected file position behavior is not new behavior, and nobody has ever cared. Until now. Yongzhi Pan reported unexpected behavior to Michael Kerrisk that was due to this. This resolves the issue with a f_pos-specific lock that is taken by read/write/lseek on file descriptors that may be shared across threads or processes. Reported-by: Yongzhi Pan <panyongzhi@gmail.com> Reported-by: Michael Kerrisk <mtk.manpages@gmail.com> Cc: Al Viro <viro@zeniv.linux.org.uk> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org> Signed-off-by: Al Viro <viro@zeniv.linux.org.uk> $ man 2 write BUGS According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 (\"Thread Interactions with Regular File Operations\"): All of the following functions shall be atomic with respect to each other in the effects specified in POSIX.1-2008 when they operate on regular files or symbolic links: ... Among the APIs subsequently listed are write() and writev(2). And among the effects that should be atomic across threads (and processes) are updates of the file offset. However, on Linux before version 3.14, this was not the case: if two processes that share an open file description (see open(2)) perform a write() (or writev(2)) at the same time, then the I/O operations were not atomic with respect updating the file offset, with the result that the blocks of data output by the two processes might (incorrectly) overlap. This problem was fixed in Linux 3.14.","title":"write(2) not thread-safe"},{"location":"bugs/#java","text":"","title":"Java"},{"location":"bugs/#applied-to-string-operands-can-provoke-side-effects","text":"Introduced in JDK9, fixed in JDK10 but not JDK9. Why does array[idx++]+=\u201ca\u201d increase idx once in Java 8 but twice in Java 9 and 10?","title":"\"+=\" applied to String operands can provoke side effects"},{"location":"dsp/","text":"Digital Signal Processing DFT/FFT DFT is a matrix multiplication, the naive implementation is O(N^2) . FFT is a much faster multiplication in O(N \\log N) , which makes it practical. X_k = \\sum_{n=0}^{N-1} x_n e^{-j 2 \\pi k n / N} Your browser does not support the video element. Wikipedia Wikibooks DFT matrix Smith's Guide to DSP, ch.8 by Steven W. Smith Mathematics of the Discrete Fourier Transform by Julius O. Smith The Discrete Fourier Transform by Ivan W. Selenick and Gerald Schuller. From chapter 2 of The Transform and Data Compression Handbook ed. by Kamisetty Ramam Rao and Patrick C. Yip The Discrete Fourier Transform by prof. Jeffrey A. Fessler from EECS 451, Digital Signal Processing and Analysis The Discrete Fourier Transform by prof. Stephen Roberts from Signal Processing & Filter Design Digital Sinusoid Generators DTMF Tone Generation and Detection by Gunter Schmer Second-order digital resonator in Python: fs = 8000 # sampling frequency fo = 700 # output frequency A = 1.0 # amplitude w = 2*pi*fo/fs # angular frequency of fo c = 2.0 * cos(w) # coefficient, controls the frequency, 1.70528 x = -A * sin(w) # initial value, controls the amplitude and phase, -0.522498 y = 0.0 for ever: emit(x) x, y = c*x - y, x First 100 data points: N = 4096 f = fft(signal[:N]) p = np.argmax(abs(f)[:N//2]) print(p*fs/N) => 699.21895 Hz FFT: Digital Waveguide Oscillator by Julius O. Smith Effect Design Part 3 Oscillators: Sinusoidal and Pseudonoise by Jon Dattorro A sine generation algorithm for VLSI applications by John W. Gordon and Julius O. Smith The Second-Order Digital Waveguide Oscillator by Julius O. Smith and Perry R. Cook AN-263 Sine Wave Generation Techniques 5 ways to generate a sine wave","title":"DSP"},{"location":"dsp/#digital-signal-processing","text":"","title":"Digital Signal Processing"},{"location":"dsp/#dftfft","text":"DFT is a matrix multiplication, the naive implementation is O(N^2) . FFT is a much faster multiplication in O(N \\log N) , which makes it practical. X_k = \\sum_{n=0}^{N-1} x_n e^{-j 2 \\pi k n / N} Your browser does not support the video element. Wikipedia Wikibooks DFT matrix Smith's Guide to DSP, ch.8 by Steven W. Smith Mathematics of the Discrete Fourier Transform by Julius O. Smith The Discrete Fourier Transform by Ivan W. Selenick and Gerald Schuller. From chapter 2 of The Transform and Data Compression Handbook ed. by Kamisetty Ramam Rao and Patrick C. Yip The Discrete Fourier Transform by prof. Jeffrey A. Fessler from EECS 451, Digital Signal Processing and Analysis The Discrete Fourier Transform by prof. Stephen Roberts from Signal Processing & Filter Design","title":"DFT/FFT"},{"location":"dsp/#digital-sinusoid-generators","text":"DTMF Tone Generation and Detection by Gunter Schmer Second-order digital resonator in Python: fs = 8000 # sampling frequency fo = 700 # output frequency A = 1.0 # amplitude w = 2*pi*fo/fs # angular frequency of fo c = 2.0 * cos(w) # coefficient, controls the frequency, 1.70528 x = -A * sin(w) # initial value, controls the amplitude and phase, -0.522498 y = 0.0 for ever: emit(x) x, y = c*x - y, x First 100 data points: N = 4096 f = fft(signal[:N]) p = np.argmax(abs(f)[:N//2]) print(p*fs/N) => 699.21895 Hz FFT: Digital Waveguide Oscillator by Julius O. Smith Effect Design Part 3 Oscillators: Sinusoidal and Pseudonoise by Jon Dattorro A sine generation algorithm for VLSI applications by John W. Gordon and Julius O. Smith The Second-Order Digital Waveguide Oscillator by Julius O. Smith and Perry R. Cook AN-263 Sine Wave Generation Techniques 5 ways to generate a sine wave","title":"Digital Sinusoid Generators"},{"location":"git/","text":"Git data model Essentially, Git is a content-addressable filesystem , Linus's one page explanation , correction: the SHA1 hash is NOT the hash of the compressed object. Git from the Bottom Up by John Wiegley, discuss . blob is content of file $ git cat-file -p 74576250e3c3a901bf06832bd0e4ee5e00422115 # Shuo's notes http://chenshuo.github.io/notes tree has one or more tree / blob , it's Merkle tree . blob are leaf nodes tree are internal nodes $ git cat-file -p 5d42664e3d812288b47795718d0e4faf26397bf9 100644 blob cde88fe0e10f265ed3cb2af0ea5422f607c1a37c .gitignore 100644 blob 74576250e3c3a901bf06832bd0e4ee5e00422115 README.md 040000 tree eabff4ee0b30f5d6a644ce508ba7fe47dc563aa4 docs 100644 blob 020682e2399c75cf3ad9636964c7501f27a0e893 mkdocs.yml commit : has one tree has one or more parent commit (s) $ git cat-file -p 3f08891b366c750d4739241874cfb1dbef56c398 tree 5d42664e3d812288b47795718d0e4faf26397bf9 parent 955f683cae5d2514d1c788fce9206451e2ac3334 author Shuo Chen <chenshuo@chenshuo.com> 1484903215 -0800 committer Shuo Chen <chenshuo@chenshuo.com> 1484903215 -0800 update ssl.md tag ??? Exceptions: initial commit has no parent empty file is empty blob empty directory is empty tree Pack file format Delta Pack index format","title":"Git"},{"location":"git/#git-data-model","text":"Essentially, Git is a content-addressable filesystem , Linus's one page explanation , correction: the SHA1 hash is NOT the hash of the compressed object. Git from the Bottom Up by John Wiegley, discuss . blob is content of file $ git cat-file -p 74576250e3c3a901bf06832bd0e4ee5e00422115 # Shuo's notes http://chenshuo.github.io/notes tree has one or more tree / blob , it's Merkle tree . blob are leaf nodes tree are internal nodes $ git cat-file -p 5d42664e3d812288b47795718d0e4faf26397bf9 100644 blob cde88fe0e10f265ed3cb2af0ea5422f607c1a37c .gitignore 100644 blob 74576250e3c3a901bf06832bd0e4ee5e00422115 README.md 040000 tree eabff4ee0b30f5d6a644ce508ba7fe47dc563aa4 docs 100644 blob 020682e2399c75cf3ad9636964c7501f27a0e893 mkdocs.yml commit : has one tree has one or more parent commit (s) $ git cat-file -p 3f08891b366c750d4739241874cfb1dbef56c398 tree 5d42664e3d812288b47795718d0e4faf26397bf9 parent 955f683cae5d2514d1c788fce9206451e2ac3334 author Shuo Chen <chenshuo@chenshuo.com> 1484903215 -0800 committer Shuo Chen <chenshuo@chenshuo.com> 1484903215 -0800 update ssl.md tag ??? Exceptions: initial commit has no parent empty file is empty blob empty directory is empty tree","title":"Git data model"},{"location":"git/#pack-file-format","text":"","title":"Pack file format"},{"location":"git/#delta","text":"","title":"Delta"},{"location":"git/#pack-index-format","text":"","title":"Pack index format"},{"location":"lcc/","text":"Notes on LCC Callgraph of parsing expressions Callgraph of parsing statements Calltree of compiling an empty program Calltree of lcc 4.2 for following simple program: int main() { return 0; }","title":"lcc"},{"location":"lcc/#notes-on-lcc","text":"","title":"Notes on LCC"},{"location":"lcc/#callgraph-of-parsing-expressions","text":"","title":"Callgraph of parsing expressions"},{"location":"lcc/#callgraph-of-parsing-statements","text":"","title":"Callgraph of parsing statements"},{"location":"lcc/#calltree-of-compiling-an-empty-program","text":"Calltree of lcc 4.2 for following simple program: int main() { return 0; }","title":"Calltree of compiling an empty program"},{"location":"links/","text":"Links 42 Years of Microprocessor Trend Data by Karl Rupp The Architecture of Open Source Applications Volumn I and II The Performance of Open Source Applications 500 Lines or Less Producing Wrong Data Without Doing Anything Obviously Wrong! Changing a seemingly innocuous aspect of an experimental setup can cause a systems researcher to draw wrong conclusions from an experiment. What appears to be an innocuous aspect in the experimental setup may in fact introduce a significant bias in an evaluation. (i) UNIX environment size, (ii) link order. Matthew Austern's list of publications Why you shouldn't use set (and what you should use instead) System programming Excuse me son, but your code is leaking !!! on Dan Walsh's Blog, about FD_CLOEXEC and O_CLOEXEC Secure File Descriptor Handling by Ulrich Drepper, about O_CLOEXEC , O_NONBLOCK . A fork() in the road from HotOS '19. LLNL Tutorials Introduction To Parallel Computing POSIX Threads Programming Compiler Old school strcpy(3) on modern compiler. std::reverse() a string on modern compiler. Run 32-bit ARM binary on ARM64 Time-keeping The Science of Timekeeping HP Application Note 1289. HP 5071A Primary Frequency Standard GPS and Precision Timing Applications HP Application Note 1272. Project GREAT: General Relativity Einstein/Essen Anniversary Test Leap Smear for applying leap seconds smoothly. Day of the weekday: Zeller's congruence , RFC3339 LZ77 and zlib http://zlib.net http://www.zlib.net/feldspar.html M$'s IIS http://www.zlib.net/zlib_faq.html#faq39 RFC1951 Mark Adler's post: https://stackoverflow.com/questions/20762094/how-are-zlib-gzip-and-zip-related-what-do-they-have-in-common-and-how-are-they https://en.wikipedia.org/wiki/Canonical_Huffman_code https://jvns.ca/blog/2013/10/24/day-16-gzip-plus-poetry-equals-awesome/ Dissecting the GZIP format Unix history Evolution of the Unix System Architecture: An Exploratory Case Study , Video from FOSDEM'18 by Diomidis Spinellis . A repository of Unix History and evolution Maths Theory and Applications of Markov Chains to Finance by Kevin Atteson","title":"Links"},{"location":"links/#links","text":"42 Years of Microprocessor Trend Data by Karl Rupp The Architecture of Open Source Applications Volumn I and II The Performance of Open Source Applications 500 Lines or Less Producing Wrong Data Without Doing Anything Obviously Wrong! Changing a seemingly innocuous aspect of an experimental setup can cause a systems researcher to draw wrong conclusions from an experiment. What appears to be an innocuous aspect in the experimental setup may in fact introduce a significant bias in an evaluation. (i) UNIX environment size, (ii) link order. Matthew Austern's list of publications Why you shouldn't use set (and what you should use instead)","title":"Links"},{"location":"links/#system-programming","text":"Excuse me son, but your code is leaking !!! on Dan Walsh's Blog, about FD_CLOEXEC and O_CLOEXEC Secure File Descriptor Handling by Ulrich Drepper, about O_CLOEXEC , O_NONBLOCK . A fork() in the road from HotOS '19. LLNL Tutorials Introduction To Parallel Computing POSIX Threads Programming","title":"System programming"},{"location":"links/#compiler","text":"Old school strcpy(3) on modern compiler. std::reverse() a string on modern compiler. Run 32-bit ARM binary on ARM64","title":"Compiler"},{"location":"links/#time-keeping","text":"The Science of Timekeeping HP Application Note 1289. HP 5071A Primary Frequency Standard GPS and Precision Timing Applications HP Application Note 1272. Project GREAT: General Relativity Einstein/Essen Anniversary Test Leap Smear for applying leap seconds smoothly. Day of the weekday: Zeller's congruence , RFC3339","title":"Time-keeping"},{"location":"links/#lz77-and-zlib","text":"http://zlib.net http://www.zlib.net/feldspar.html M$'s IIS http://www.zlib.net/zlib_faq.html#faq39 RFC1951 Mark Adler's post: https://stackoverflow.com/questions/20762094/how-are-zlib-gzip-and-zip-related-what-do-they-have-in-common-and-how-are-they https://en.wikipedia.org/wiki/Canonical_Huffman_code https://jvns.ca/blog/2013/10/24/day-16-gzip-plus-poetry-equals-awesome/ Dissecting the GZIP format","title":"LZ77 and zlib"},{"location":"links/#unix-history","text":"Evolution of the Unix System Architecture: An Exploratory Case Study , Video from FOSDEM'18 by Diomidis Spinellis . A repository of Unix History and evolution","title":"Unix history"},{"location":"links/#maths","text":"Theory and Applications of Markov Chains to Finance by Kevin Atteson","title":"Maths"},{"location":"lua/","text":"Notes on Lua implementation Parser Lua uses a recursive descent parser, which generates code on-the-fly, similar to PL/0. Callgraph: Calltree Calltree of Lua 5.3 for following simple program: #include \"lua.hpp\" int main() { lua_State *L = luaL_newstate(); luaL_openlibs(L); // open standard libraries luaL_loadstring(L, R\"( x = 10 * 5 print(x) )\"); lua_pcall(L, 0, LUA_MULTRET, 0); lua_close(L); } Releases","title":"Lua"},{"location":"lua/#notes-on-lua-implementation","text":"","title":"Notes on Lua implementation"},{"location":"lua/#parser","text":"Lua uses a recursive descent parser, which generates code on-the-fly, similar to PL/0. Callgraph:","title":"Parser"},{"location":"lua/#calltree","text":"Calltree of Lua 5.3 for following simple program: #include \"lua.hpp\" int main() { lua_State *L = luaL_newstate(); luaL_openlibs(L); // open standard libraries luaL_loadstring(L, R\"( x = 10 * 5 print(x) )\"); lua_pcall(L, 0, LUA_MULTRET, 0); lua_close(L); }","title":"Calltree"},{"location":"lua/#releases","text":"","title":"Releases"},{"location":"mem/","text":"Notes on C/C++ memory model Threads and memory model for C++ by Hans Boehm GCC 4.7 and above does the right thing! The C11 and C++11 Concurrency Model by Mark John Batty C/C++11 mappings to processors by Alexander Terekhov, Paul McKenney, et al. Awesome Lock-Free Lockless algorithms on LWN.net Linux-Kernel Memory Model Russ Cox explains Memory Models RISC-V memory consistency model","title":"Memory Model"},{"location":"mem/#notes-on-cc-memory-model","text":"Threads and memory model for C++ by Hans Boehm GCC 4.7 and above does the right thing! The C11 and C++11 Concurrency Model by Mark John Batty C/C++11 mappings to processors by Alexander Terekhov, Paul McKenney, et al. Awesome Lock-Free Lockless algorithms on LWN.net Linux-Kernel Memory Model Russ Cox explains Memory Models RISC-V memory consistency model","title":"Notes on C/C++ memory model"},{"location":"reed-solomon/","text":"Reed-Solomon Error Correction Codes There are two views of Reed-Solomon codes, Original view and BCH view , make sure which view you are reading about. It seems to me, BCH view is most common used (QR codes, CD/DVD, FEC in communications like DVB or 100GbE), and can do both erasure and error corrections. Original view is mainly used for erasure codes in (distributed) storage systems. Original view BCH view Message \\boldsymbol m = [m_0, m_1, \\ldots, m_{k-1}] As coefficients of polynomial p(x) = m_0 + m_1x + m_2x^2 + \\cdots + m_{k-1}x^{k-1} Codeword \\boldsymbol c = [c_0, c_1, \\ldots, c_{n-1}] As values of p(x) at a_0, a_1, \\ldots, a_{n-1} As coefficients of polynomial s(x) Characteristic Vandermonde matrix V Generator polynomial g(x) (n, k) Usuall small, for erasure codes in storage systems n=2^m-1 , usually n=255 Basic encoding V_{n \\times k} \\cdot \\boldsymbol m s(x) = p(x) \\cdot g(x) Systematic encoding \\begin{bmatrix}I_k\\\\G\\end{bmatrix} \\cdot \\boldsymbol m p(x) \\cdot x^{n-k} \\mod g(x) Implementation More memory for V or G linear feedback shift register (LFSR) Erasure decoding Inverse of matrix O(n^3) Forney algorithm O(n^2) Error correction decoding Berlekamp-Welch (1983), Shuhong Gao (2002) PGZ (1960), Berlekamp-Massey (1967) V_{n\\times k} = \\begin{pmatrix} 1 & a_0 & a_0^2 & \\cdots & a_0^{k-1} \\\\[1mm] 1 & a_1 & a_1^2 & \\cdots & a_1^{k-1} \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 1 & a_{n-1} & a_{n-1}^2 & \\cdots & a_{n-1}^{k-1} \\end{pmatrix}, \\quad g(x) = (x-\\alpha^i)(x-\\alpha^{i+1})\\cdots (x-\\alpha^{i+n-k-1}) Reed-Solomon error correction in Python https://github.com/chenshuo/notes/blob/master/notebooks/ReedSolomonErasureCodes.ipynb Reference https://en.wikipedia.org/wiki/Reed-Solomon_error_correction Tutorials Starts here \"Practical Reed-Solomon for Programmers\" https://berthub.eu/articles/posts/reed-solomon-for-programmers/ (BCH view) https://www.akalin.com/intro-erasure-codes (Original view) Polynomial visualize \"Reed-Solomon Error Correcting Codes from the Bottom Up\" https://tomverbeure.github.io/2022/08/07/Reed-Solomon.html \"Introduction to Reed-Solomon\" https://innovation.vivint.com/introduction-to-reed-solomon-bc264d0794f8 https://github.com/vivint/infectious Finite Field \"Finite Field Arithmetic and Reed-Solomon Coding\" https://research.swtch.com/field (BCH view) https://github.com/rsc/qr/blob/master/gf256/gf256.go \"The mathematics of RAID-6\" https://www.kernel.org/pub/linux/kernel/people/hpa/raid6.pdf (Finite Field Arithmetic) Error correction decoding in BCH view Reed\u2013Solomon codes for coders (BCH view with Python code) https://downloads.bbc.co.uk/rd/pubs/whp/whp-pdf-files/WHP031.pdf (BCH view) https://www.nayuki.io/page/reed-solomon-error-correcting-code-decoder (BCH view, PGZ decoder) Erasure decoding in original view Erasure Codes for Storage Applications https://web.eecs.utk.edu/~jplank/plank/papers/FAST-2005.pdf Tutorial: Erasure Coding for Storage Applications https://web.eecs.utk.edu/~jplank/plank/papers/FAST-2013-Tutorial.html All About Erasure Codes by James Plank https://web.eecs.utk.edu/~jplank/plank/classes/cs560/560/notes/Erasure/2004-ICL.pdf Videos vcubingx - What are Reed-Solomon Codes? Isabel Vogt - Error Correcting Curves - Numberphile Mary Wootters - Lecture 4: Reed-Solomon Codes! of Stanford CS250/EE387: Algebraic Error Correcting Codes Her 1-hr long public lecture for wider audience Course notes Stanford CS250/EE387: Algebraic Error Correcting Codes https://web.stanford.edu/class/cs250/ Berkeley CS 294-226: Advances in Error-Correcting Codes https://people.eecs.berkeley.edu/~venkatg/teaching/ECC-fall22/ MIT 6.451: Principles Of Digital Communication II https://ocw.mit.edu/courses/6-451-principles-of-digital-communication-ii-spring-2005/resources/mit6_451s05_fulllecnotes/ Open source Original view (Vandermonde Reed-Solomon) James S. Plank: A Tutorial on Reed-Solomon Coding for Fault-Tolerance in RAID-like Systems , SPE97 paper and correction 2003 . Luigi Rizzo: Software FEC in computer communications , RFC 5510 JavaReedSolomon by Backblaze. Blog post Backblaze Open-sources Reed-Solomon Erasure Coding Source Code and 5-minute video tutorial by Brian Beach Python pyfinite package. BCH view Error Correcting Codes (ECC) Page by Robert Morelos-Zaragoza. FEC Library by Phil Karn, KA9Q. Adapted into Linux kernel 2.6.10 by Thomas Gleixner. Russ Cox blog Finite Field Arithmetic and Reed-Solomon Coding with source code in Go . Python galois package. History and People https://en.wikipedia.org/wiki/Irving_S._Reed https://en.wikipedia.org/wiki/Gustave_Solomon https://en.wikipedia.org/wiki/Elwyn_Berlekamp https://en.wikipedia.org/wiki/James_Massey https://en.wikipedia.org/wiki/Lloyd_R._Welch https://en.wikipedia.org/wiki/Robert_Tienwen_Chien https://en.wikipedia.org/wiki/Dave_Forney","title":"Reed-Solomon"},{"location":"reed-solomon/#reed-solomon-error-correction-codes","text":"There are two views of Reed-Solomon codes, Original view and BCH view , make sure which view you are reading about. It seems to me, BCH view is most common used (QR codes, CD/DVD, FEC in communications like DVB or 100GbE), and can do both erasure and error corrections. Original view is mainly used for erasure codes in (distributed) storage systems. Original view BCH view Message \\boldsymbol m = [m_0, m_1, \\ldots, m_{k-1}] As coefficients of polynomial p(x) = m_0 + m_1x + m_2x^2 + \\cdots + m_{k-1}x^{k-1} Codeword \\boldsymbol c = [c_0, c_1, \\ldots, c_{n-1}] As values of p(x) at a_0, a_1, \\ldots, a_{n-1} As coefficients of polynomial s(x) Characteristic Vandermonde matrix V Generator polynomial g(x) (n, k) Usuall small, for erasure codes in storage systems n=2^m-1 , usually n=255 Basic encoding V_{n \\times k} \\cdot \\boldsymbol m s(x) = p(x) \\cdot g(x) Systematic encoding \\begin{bmatrix}I_k\\\\G\\end{bmatrix} \\cdot \\boldsymbol m p(x) \\cdot x^{n-k} \\mod g(x) Implementation More memory for V or G linear feedback shift register (LFSR) Erasure decoding Inverse of matrix O(n^3) Forney algorithm O(n^2) Error correction decoding Berlekamp-Welch (1983), Shuhong Gao (2002) PGZ (1960), Berlekamp-Massey (1967) V_{n\\times k} = \\begin{pmatrix} 1 & a_0 & a_0^2 & \\cdots & a_0^{k-1} \\\\[1mm] 1 & a_1 & a_1^2 & \\cdots & a_1^{k-1} \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 1 & a_{n-1} & a_{n-1}^2 & \\cdots & a_{n-1}^{k-1} \\end{pmatrix}, \\quad g(x) = (x-\\alpha^i)(x-\\alpha^{i+1})\\cdots (x-\\alpha^{i+n-k-1})","title":"Reed-Solomon Error Correction Codes"},{"location":"reed-solomon/#reed-solomon-error-correction-in-python","text":"https://github.com/chenshuo/notes/blob/master/notebooks/ReedSolomonErasureCodes.ipynb","title":"Reed-Solomon error correction in Python"},{"location":"reed-solomon/#reference","text":"https://en.wikipedia.org/wiki/Reed-Solomon_error_correction","title":"Reference"},{"location":"reed-solomon/#tutorials","text":"Starts here \"Practical Reed-Solomon for Programmers\" https://berthub.eu/articles/posts/reed-solomon-for-programmers/ (BCH view) https://www.akalin.com/intro-erasure-codes (Original view) Polynomial visualize \"Reed-Solomon Error Correcting Codes from the Bottom Up\" https://tomverbeure.github.io/2022/08/07/Reed-Solomon.html \"Introduction to Reed-Solomon\" https://innovation.vivint.com/introduction-to-reed-solomon-bc264d0794f8 https://github.com/vivint/infectious Finite Field \"Finite Field Arithmetic and Reed-Solomon Coding\" https://research.swtch.com/field (BCH view) https://github.com/rsc/qr/blob/master/gf256/gf256.go \"The mathematics of RAID-6\" https://www.kernel.org/pub/linux/kernel/people/hpa/raid6.pdf (Finite Field Arithmetic) Error correction decoding in BCH view Reed\u2013Solomon codes for coders (BCH view with Python code) https://downloads.bbc.co.uk/rd/pubs/whp/whp-pdf-files/WHP031.pdf (BCH view) https://www.nayuki.io/page/reed-solomon-error-correcting-code-decoder (BCH view, PGZ decoder) Erasure decoding in original view Erasure Codes for Storage Applications https://web.eecs.utk.edu/~jplank/plank/papers/FAST-2005.pdf Tutorial: Erasure Coding for Storage Applications https://web.eecs.utk.edu/~jplank/plank/papers/FAST-2013-Tutorial.html All About Erasure Codes by James Plank https://web.eecs.utk.edu/~jplank/plank/classes/cs560/560/notes/Erasure/2004-ICL.pdf","title":"Tutorials"},{"location":"reed-solomon/#videos","text":"vcubingx - What are Reed-Solomon Codes? Isabel Vogt - Error Correcting Curves - Numberphile Mary Wootters - Lecture 4: Reed-Solomon Codes! of Stanford CS250/EE387: Algebraic Error Correcting Codes Her 1-hr long public lecture for wider audience","title":"Videos"},{"location":"reed-solomon/#course-notes","text":"Stanford CS250/EE387: Algebraic Error Correcting Codes https://web.stanford.edu/class/cs250/ Berkeley CS 294-226: Advances in Error-Correcting Codes https://people.eecs.berkeley.edu/~venkatg/teaching/ECC-fall22/ MIT 6.451: Principles Of Digital Communication II https://ocw.mit.edu/courses/6-451-principles-of-digital-communication-ii-spring-2005/resources/mit6_451s05_fulllecnotes/","title":"Course notes"},{"location":"reed-solomon/#open-source","text":"","title":"Open source"},{"location":"reed-solomon/#original-view-vandermonde-reed-solomon","text":"James S. Plank: A Tutorial on Reed-Solomon Coding for Fault-Tolerance in RAID-like Systems , SPE97 paper and correction 2003 . Luigi Rizzo: Software FEC in computer communications , RFC 5510 JavaReedSolomon by Backblaze. Blog post Backblaze Open-sources Reed-Solomon Erasure Coding Source Code and 5-minute video tutorial by Brian Beach Python pyfinite package.","title":"Original view (Vandermonde Reed-Solomon)"},{"location":"reed-solomon/#bch-view","text":"Error Correcting Codes (ECC) Page by Robert Morelos-Zaragoza. FEC Library by Phil Karn, KA9Q. Adapted into Linux kernel 2.6.10 by Thomas Gleixner. Russ Cox blog Finite Field Arithmetic and Reed-Solomon Coding with source code in Go . Python galois package.","title":"BCH view"},{"location":"reed-solomon/#history-and-people","text":"https://en.wikipedia.org/wiki/Irving_S._Reed https://en.wikipedia.org/wiki/Gustave_Solomon https://en.wikipedia.org/wiki/Elwyn_Berlekamp https://en.wikipedia.org/wiki/James_Massey https://en.wikipedia.org/wiki/Lloyd_R._Welch https://en.wikipedia.org/wiki/Robert_Tienwen_Chien https://en.wikipedia.org/wiki/Dave_Forney","title":"History and People"},{"location":"ssl/","text":"Notes on SSL/TLS ChaCha20, Poly1305, X25519 RFC7539 defines ChaCha20 and Poly1305 RFC7905 adds TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (0xCCA8) etc to TLS 1.2 There is an old version of ECDHE_RSA_CHACHA20_POLY1305_OLD (0xCC13) exists in draft and OpenSSL code . OpenSSL will prefer AES if hardware supports it, otherwise prefer ChaCha20 over AES, in ssl_create_cipher_list() . Go 1.8 will support TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 commit 67d8226b48 commit 67d8226b4862f0f8deb4dc6fa8617017ecb0f32b Author: Adam Langley <agl@golang.org> Date: Wed Oct 12 10:46:43 2016 -0700 crypto/tls: support ChaCha20-Poly1305. This change adds support for the ChaCha20-Poly1305 AEAD to crypto/tls, as specified in https://tools.ietf.org/html/rfc7905. Fixes #15499. Change-Id: Iaa689be90e03f208c40b574eca399e56f3c7ecf1 Reviewed-on: https://go-review.googlesource.com/30957 Run-TryBot: Adam Langley <agl@golang.org> TryBot-Result: Gobot Gobot <gobot@golang.org> Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org> Go perfers X25519 over P-256, P-384 and P-521. commit 9e98e7e668 commit 9e98e7e6686a500f87352e3721038d194b1db33c Author: Adam Langley <agl@golang.org> Date: Tue Oct 11 15:08:35 2016 -0700 crypto/tls: enable X25519 by default. Since this changes the offered curves in the ClientHello, all the test data needs to be updated too. Change-Id: I227934711104349c0f0eab11d854e5a2adcbc363 Reviewed-on: https://go-review.googlesource.com/30825 Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org> API changes OpenSSL 1.0.2 has an undocumented SSL_get_server_tmp_key() function to get the curve used in handshaking, this is for openssl s_client command. http://crypto.stackexchange.com/questions/11310/with-openssl-and-ecdhe-how-to-show-the-actual-curve-being-used OpenSSL 1.0.1 only allows setting one curve with SSL_CTX_set_tmp_ecdh() (or use callbacks), OpenSSL 1.0.2 allows setting curve list with SSL_CTX_set1_curves() and SSL_CTX_set1_curves_list() OpenSSL 1.0.2 adds SSL_CTX_set_ecdh_auto() , but OpenSSL 1.1.0 makes it a no-op. OpenSSL 1.1.0 provides SSL_SESSION_get_master_key() function. Go 1.8 supports KeyLogWriter commit 320bd562cb commit 320bd562cbb24a01beb02706c42d06a290160645 Author: Joonas Kuorilehto <joneskoo@derbian.fi> Date: Sat Aug 20 14:41:42 2016 +0300 crypto/tls: add KeyLogWriter for debugging Add support for writing TLS client random and master secret in NSS key log format. https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format Normally this is enabled by a developer debugging TLS based applications, especially HTTP/2, by setting the KeyLogWriter to an open file. The keys negotiated in handshake are then logged and can be used to decrypt TLS sessions e.g. in Wireshark. Applications may choose to add support similar to NSS where this is enabled by environment variable, but no such mechanism is built in to Go. Instead each application must explicitly enable. Fixes #13057. Change-Id: If6edd2d58999903e8390b1674ba4257ecc747ae1 Reviewed-on: https://go-review.googlesource.com/27434 Run-TryBot: Brad Fitzpatrick <bradfitz@golang.org> TryBot-Result: Gobot Gobot <gobot@golang.org> Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org> Memory footprint Before OpenSSL 1.1.0, there is a free-list (~32k per SSL) unless disable with OPENSSL_NO_BUF_FREELISTS or set SSL_MODE_RELEASE_BUFFERS, the free list is freed in SSL_CTX_free() not SSL_free() . commit 63c574f6a6 in OpenSSL: commit 63c574f6a639cfa3f53476080054526e6bfa3bc9 Author: Rich Salz <rsalz@openssl.org> Date: Tue Jan 27 16:43:53 2015 -0500 OPENSSL_NO_XXX cleanup: OPENSSL_NO_BUF_FREELISTS Remove OPENSSL_NO_BUF_FREELISTS. This was turned on by default, so the work here is removing the 'maintain our own freelist' code. Also removed a minor old Windows-multibyte/widechar conversion flag. commit 72e56bc494 in LibreSSL: commit 72e56bc4947e53cec535f2fc84e00a3c278edf29 Author: tedu <> Date: Wed Apr 16 21:16:33 2014 +0000 TANSTAAFL - delete the buf freelist code. if you need a better malloc, get a better malloc. ok beck deraadt diff --git a/src/lib/libssl/s3_both.c b/src/lib/libssl/s3_both.c TANSTAAFL - There ain't no such thing as a free lunch commit 983f6bdb58 in BoringSSL: commit 983f6bdb5888d7074d7ee67d5e3741bcf1027108 Author: Alex Chernyakhovsky <achernya@google.com> Date: Sun Aug 3 15:48:35 2014 -0400 Set OPENSSL_NO_BUF_FREELISTS The memory freelist maintained by OpenSSL claims to be a performance optimization for platforms that have a slow malloc/free implementation. This should not be the case on modern linux/glibc. Remove the freelist as it poses a potential security hazard of buffer-reuse that is of \"initialized\" memory that will not be caught be tools such as valgrind. Change-Id: I3cfa6a05f9bdfbbba7820060bae5a673dee43014 Reviewed-on: https://boringssl-review.googlesource.com/1385 Reviewed-by: Adam Langley <agl@google.com> After commit b8d28cf532 BoringSSL calls ssl_write_buffer_flush() and ssl_write_buffer_clear() for each SSL_write() , so its memory footprint is much smaller than other SSL libraries (~32k) when no data is pending. Performance notes The P-256 curve, also known as prime256v1 or secp256r1 is widely used in ECDHE_RSA key exchange. For x86-64, there is a faster implementation, enabled by ./config enable-ec_nistp_64_gcc_128 . Futher speed up of P-256 in OpenSSL 1.1.0 and BoringSSL: commit 4d3fa06fce for OpenSSL 1.1.0 commit 3842a64d36 backports to 1.0.2 branch commit 1895493868 for BoringSSL commit 18954938684e269ccd59152027d2244040e2b819 Author: Adam Langley <agl@google.com> Date: Tue Nov 3 14:02:04 2015 -0800 Add Intel's P-256 This change incorporates Intel's P-256 implementation. The record of Intel's submission under CLA is in internal bug number 25330687. Before: Did 3582 ECDH P-256 operations in 1049114us (3414.3 ops/sec) Did 8525 ECDSA P-256 signing operations in 1028778us (8286.5 ops/sec) Did 3487 ECDSA P-256 verify operations in 1008996us (3455.9 ops/sec) build/tool/bssl is 1434704 bytes after strip -s After: Did 8618 ECDH P-256 operations in 1027884us (8384.2 ops/sec) Did 21000 ECDSA P-256 signing operations in 1049490us (20009.7 ops/sec) Did 8268 ECDSA P-256 verify operations in 1079481us (7659.2 ops/sec) build/tool/bssl is 1567216 bytes after strip -s Change-Id: I147971a8e19849779c8ed7e20310d41bd4962299 Reviewed-on: https://boringssl-review.googlesource.com/6371 Reviewed-by: Adam Langley <agl@google.com> None of them are available in LibreSSL as of Jan 19, 2017. Issue 259 . AEGIS-128 will replace AES-GCM One of winners of CAESAR cryptographic competitions . Cryptography cs387 Applied Cryptography on udacity Elliptic Curve Cryptography: ECDH and ECDSA Everything you need to know about cryptography in 1 hour","title":"SSL"},{"location":"ssl/#notes-on-ssltls","text":"","title":"Notes on SSL/TLS"},{"location":"ssl/#chacha20-poly1305-x25519","text":"RFC7539 defines ChaCha20 and Poly1305 RFC7905 adds TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (0xCCA8) etc to TLS 1.2 There is an old version of ECDHE_RSA_CHACHA20_POLY1305_OLD (0xCC13) exists in draft and OpenSSL code . OpenSSL will prefer AES if hardware supports it, otherwise prefer ChaCha20 over AES, in ssl_create_cipher_list() . Go 1.8 will support TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 commit 67d8226b48 commit 67d8226b4862f0f8deb4dc6fa8617017ecb0f32b Author: Adam Langley <agl@golang.org> Date: Wed Oct 12 10:46:43 2016 -0700 crypto/tls: support ChaCha20-Poly1305. This change adds support for the ChaCha20-Poly1305 AEAD to crypto/tls, as specified in https://tools.ietf.org/html/rfc7905. Fixes #15499. Change-Id: Iaa689be90e03f208c40b574eca399e56f3c7ecf1 Reviewed-on: https://go-review.googlesource.com/30957 Run-TryBot: Adam Langley <agl@golang.org> TryBot-Result: Gobot Gobot <gobot@golang.org> Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org> Go perfers X25519 over P-256, P-384 and P-521. commit 9e98e7e668 commit 9e98e7e6686a500f87352e3721038d194b1db33c Author: Adam Langley <agl@golang.org> Date: Tue Oct 11 15:08:35 2016 -0700 crypto/tls: enable X25519 by default. Since this changes the offered curves in the ClientHello, all the test data needs to be updated too. Change-Id: I227934711104349c0f0eab11d854e5a2adcbc363 Reviewed-on: https://go-review.googlesource.com/30825 Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org>","title":"ChaCha20, Poly1305, X25519"},{"location":"ssl/#api-changes","text":"OpenSSL 1.0.2 has an undocumented SSL_get_server_tmp_key() function to get the curve used in handshaking, this is for openssl s_client command. http://crypto.stackexchange.com/questions/11310/with-openssl-and-ecdhe-how-to-show-the-actual-curve-being-used OpenSSL 1.0.1 only allows setting one curve with SSL_CTX_set_tmp_ecdh() (or use callbacks), OpenSSL 1.0.2 allows setting curve list with SSL_CTX_set1_curves() and SSL_CTX_set1_curves_list() OpenSSL 1.0.2 adds SSL_CTX_set_ecdh_auto() , but OpenSSL 1.1.0 makes it a no-op. OpenSSL 1.1.0 provides SSL_SESSION_get_master_key() function. Go 1.8 supports KeyLogWriter commit 320bd562cb commit 320bd562cbb24a01beb02706c42d06a290160645 Author: Joonas Kuorilehto <joneskoo@derbian.fi> Date: Sat Aug 20 14:41:42 2016 +0300 crypto/tls: add KeyLogWriter for debugging Add support for writing TLS client random and master secret in NSS key log format. https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format Normally this is enabled by a developer debugging TLS based applications, especially HTTP/2, by setting the KeyLogWriter to an open file. The keys negotiated in handshake are then logged and can be used to decrypt TLS sessions e.g. in Wireshark. Applications may choose to add support similar to NSS where this is enabled by environment variable, but no such mechanism is built in to Go. Instead each application must explicitly enable. Fixes #13057. Change-Id: If6edd2d58999903e8390b1674ba4257ecc747ae1 Reviewed-on: https://go-review.googlesource.com/27434 Run-TryBot: Brad Fitzpatrick <bradfitz@golang.org> TryBot-Result: Gobot Gobot <gobot@golang.org> Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org>","title":"API changes"},{"location":"ssl/#memory-footprint","text":"Before OpenSSL 1.1.0, there is a free-list (~32k per SSL) unless disable with OPENSSL_NO_BUF_FREELISTS or set SSL_MODE_RELEASE_BUFFERS, the free list is freed in SSL_CTX_free() not SSL_free() . commit 63c574f6a6 in OpenSSL: commit 63c574f6a639cfa3f53476080054526e6bfa3bc9 Author: Rich Salz <rsalz@openssl.org> Date: Tue Jan 27 16:43:53 2015 -0500 OPENSSL_NO_XXX cleanup: OPENSSL_NO_BUF_FREELISTS Remove OPENSSL_NO_BUF_FREELISTS. This was turned on by default, so the work here is removing the 'maintain our own freelist' code. Also removed a minor old Windows-multibyte/widechar conversion flag. commit 72e56bc494 in LibreSSL: commit 72e56bc4947e53cec535f2fc84e00a3c278edf29 Author: tedu <> Date: Wed Apr 16 21:16:33 2014 +0000 TANSTAAFL - delete the buf freelist code. if you need a better malloc, get a better malloc. ok beck deraadt diff --git a/src/lib/libssl/s3_both.c b/src/lib/libssl/s3_both.c TANSTAAFL - There ain't no such thing as a free lunch commit 983f6bdb58 in BoringSSL: commit 983f6bdb5888d7074d7ee67d5e3741bcf1027108 Author: Alex Chernyakhovsky <achernya@google.com> Date: Sun Aug 3 15:48:35 2014 -0400 Set OPENSSL_NO_BUF_FREELISTS The memory freelist maintained by OpenSSL claims to be a performance optimization for platforms that have a slow malloc/free implementation. This should not be the case on modern linux/glibc. Remove the freelist as it poses a potential security hazard of buffer-reuse that is of \"initialized\" memory that will not be caught be tools such as valgrind. Change-Id: I3cfa6a05f9bdfbbba7820060bae5a673dee43014 Reviewed-on: https://boringssl-review.googlesource.com/1385 Reviewed-by: Adam Langley <agl@google.com> After commit b8d28cf532 BoringSSL calls ssl_write_buffer_flush() and ssl_write_buffer_clear() for each SSL_write() , so its memory footprint is much smaller than other SSL libraries (~32k) when no data is pending.","title":"Memory footprint"},{"location":"ssl/#performance-notes","text":"The P-256 curve, also known as prime256v1 or secp256r1 is widely used in ECDHE_RSA key exchange. For x86-64, there is a faster implementation, enabled by ./config enable-ec_nistp_64_gcc_128 . Futher speed up of P-256 in OpenSSL 1.1.0 and BoringSSL: commit 4d3fa06fce for OpenSSL 1.1.0 commit 3842a64d36 backports to 1.0.2 branch commit 1895493868 for BoringSSL commit 18954938684e269ccd59152027d2244040e2b819 Author: Adam Langley <agl@google.com> Date: Tue Nov 3 14:02:04 2015 -0800 Add Intel's P-256 This change incorporates Intel's P-256 implementation. The record of Intel's submission under CLA is in internal bug number 25330687. Before: Did 3582 ECDH P-256 operations in 1049114us (3414.3 ops/sec) Did 8525 ECDSA P-256 signing operations in 1028778us (8286.5 ops/sec) Did 3487 ECDSA P-256 verify operations in 1008996us (3455.9 ops/sec) build/tool/bssl is 1434704 bytes after strip -s After: Did 8618 ECDH P-256 operations in 1027884us (8384.2 ops/sec) Did 21000 ECDSA P-256 signing operations in 1049490us (20009.7 ops/sec) Did 8268 ECDSA P-256 verify operations in 1079481us (7659.2 ops/sec) build/tool/bssl is 1567216 bytes after strip -s Change-Id: I147971a8e19849779c8ed7e20310d41bd4962299 Reviewed-on: https://boringssl-review.googlesource.com/6371 Reviewed-by: Adam Langley <agl@google.com> None of them are available in LibreSSL as of Jan 19, 2017. Issue 259 .","title":"Performance notes"},{"location":"ssl/#aegis-128-will-replace-aes-gcm","text":"One of winners of CAESAR cryptographic competitions .","title":"AEGIS-128 will replace AES-GCM"},{"location":"ssl/#cryptography","text":"cs387 Applied Cryptography on udacity Elliptic Curve Cryptography: ECDH and ECDSA Everything you need to know about cryptography in 1 hour","title":"Cryptography"},{"location":"kernel/callgraph/","text":"tcp_sock tcp_hashinfo // include/linux/types.h struct hlist_head { struct hlist_node *first; }; struct hlist_node { struct hlist_node *next, **pprev; }; // include/linux/list_nulls.h struct hlist_nulls_head { struct hlist_nulls_node *first; }; struct hlist_nulls_node { struct hlist_nulls_node *next, **pprev; }; // include/net/inet_hashtables.h struct inet_ehash_bucket { struct hlist_nulls_head chain; }; struct inet_bind_hashbucket { spinlock_t lock; // empty struct hlist_head chain; }; struct inet_listen_hashbucket { spinlock_t lock; // empty struct hlist_head head; }; #define INET_LHTABLE_SIZE 32 /* Yes, really, this is all you need. */ struct inet_hashinfo { /* This is for sockets with full identity only. Sockets here will * always be without wildcards and will have the following invariant: * * TCP_ESTABLISHED <= sk->sk_state < TCP_CLOSE * */ struct inet_ehash_bucket *ehash; spinlock_t *ehash_locks; unsigned int ehash_mask; unsigned int ehash_locks_mask; /* Ok, let's try this, I give up, we do need a local binding * TCP hash as well as the others for fast bind/connect. */ struct inet_bind_hashbucket *bhash; unsigned int bhash_size; /* 4 bytes hole on 64 bit */ struct kmem_cache *bind_bucket_cachep; /* All the above members are written once at bootup and * never written again _or_ are predominantly read-access. * * Now align to a new cache line as all the following members * might be often dirty. */ /* All sockets in TCP_LISTEN state will be in here. This is the only * table where wildcard'd TCP sockets can exist. Hash function here * is just local port number. */ struct inet_listen_hashbucket listening_hash[INET_LHTABLE_SIZE] ____cacheline_aligned_in_smp; }; TCP state diagram in Linux 4.4+ bind sys_bind -> inet_bind -> inet_csk_get_port -> goto have_snum: -> goto tb_not_found: tb == NULL -> inet_bind_bucket_create -> goto success: -> inet_bind_hash -> sk_add_bind_node -> fput_light // tcp_hashinfo.bhash -> inet_bind_hashbucket -> inet_bind_bucket[port=2222] -> tcp_sock listen sys_listen -> inet_listen -> inet_csk_listen_start -> reqsk_queue_alloc -> inet_csk_delack_init -> set sk->sk_state = TCP_LISTEN -> inet_csk_get_port -> goto have_snum: -> goto tb_found: -> inet_csk_bind_conflict -> goto tb_not_found: tb != NULL -> inet_hash -> __inet_hash // tcp_hashinfo.listening_hash[X] add node After bind() and listen() Passive open Receive SYN tcp_v4_rcv -> __inet_lookup_skb -> __inet_lookup -> __inet_lookup_established -> __inet_lookup_listener // found -> tcp_v4_do_rcv // sk_state == TCP_LISTEN -> tcp_rcv_state_process -> tcp_v4_conn_request // icsk->icsk_af_ops->conn_request -> tcp_conn_request -> req = inet_reqsk_alloc -> reqsk_alloc req->rsk_listener = sk_listener; ireq->ireq_state = TCP_NEW_SYN_RECV; ireq->ireq_family = sk_listener->sk_family; -> tcp_parse_options -> tcp_openreq_init -> tcp_v4_init_req // af_ops->init_req -> tcp_v4_save_options -> isn = tcp_v4_init_sequence // af_ops->init_seq -> tcp_v4_route_req // af_ops->route_req -> inet_csk_route_req -> flowi4_init_output -> ip_route_output_flow -> tcp_ecn_create_request -> tcp_openreq_init_rwin -> tcp_select_initial_window -> tcp_reqsk_record_syn -> tcp_try_fastopen -> inet_csk_reqsk_queue_hash_add -> reqsk_queue_hash_req //*** -> inet_ehash_insert -> __sk_nulls_add_node_rcu -> inet_csk_reqsk_queue_added inet_csk(sk)->icsk_accept_queue.qlen++ -> tcp_v4_send_synack // af_ops->send_synack -> tcp_make_synack -> __tcp_v4_send_check -> ip_build_and_send_pkt -> ip_local_out -> __ip_local_out -> dst_output -> ip_output After receiving SYN Receive ACK tcp_v4_rcv -> __inet_lookup_skb -> __inet_lookup -> __inet_lookup_established // found tcp_request_sock -> sk->sk_state == TCP_NEW_SYN_RECV sk = req->rsk_listener; -> tcp_check_req -> tcp_parse_options -> tcp_paws_reject -> tcp_in_window -> tcp_v4_syn_recv_sock // inet_csk(sk)->icsk_af_ops->syn_recv_sock -> tcp_create_openreq_child -> inet_csk_clone_lock -> sk_clone_lock -> newsk = sk_prot_alloc // new tcp_sock -> sock_copy newsk->sk_state = TCP_SYN_RECV; -> tcp_init_xmit_timers -> inet_sk_rx_dst_set -> inet_csk_route_child_sock -> tcp_ca_openreq_child -> tcp_assign_congestion_control -> tcp_set_ca_state TCP_CA_Open -> tcp_sync_mss -> dst_mtu -> ipv4_mtu -> tcp_mtu_to_mss -> tcp_bound_to_half_wnd -> dst_metric_advmss -> ipv4_default_advmss -> tcp_initialize_rcv_mss -> __inet_inherit_port -> inet_bind_hash // put newsk in bind_bucket inet_csk(sk)->icsk_bind_hash = tb; -> inet_ehash_nolisten -> inet_ehash_insert(newsk, reqsk) -> sk_nulls_del_node_init_rcu(osk) -> __sk_nulls_add_node_rcu(sk, list) -> sock_prot_inuse_add -> tcp_move_syn -> sock_rps_save_rxhash -> tcp_synack_rtt_meas -> skb_mstamp_us_delta -> tcp_ack_update_rtt -> tcp_update_rtt_min -> tcp_rtt_estimator -> tcp_set_rto -> inet_csk_complete_hashdance -> inet_csk_reqsk_queue_drop -> reqsk_queue_unlink -> reqsk_put(req) return found(false) -> reqsk_queue_removed &inet_csk(sk)->icsk_accept_queue.qlen-- -> inet_csk_reqsk_queue_add queue->rskq_accept_head = req // first -> sk_acceptq_added sk->sk_ack_backlog++; // listen_sk -> tcp_child_process -> tcp_rcv_state_process(child, skb) -> tcp_validate_incoming -> tcp_ack -> tcp_ack_update_window -> tcp_ecn_rcv_ecn_echo // false -> tcp_in_ack_event return 1 switch(sk_state) case TCP_SYN_RECV: -> inet_sk_rebuild_header // icsk->icsk_af_ops->rebuild_header -> tcp_init_congestion_control -> tcp_mtup_init -> tcp_init_buffer_space -> tcp_fixup_rcvbuf -> tcp_sndbuf_expand -> tcp_full_space tcp_set_state(sk, TCP_ESTABLISHED) sk->sk_state_change -> sock_def_wakeup -> tcp_init_metrics -> tcp_update_pacing_rate -> tcp_initialize_rcv_mss -> tcp_fast_path_on // out of switch -> tcp_urg switch TCP_ESTABLISHED -> tcp_data_queue -> tcp_data_snd_check -> tcp_ack_snd_check -> parent->sk_data_ready -> sock_def_readable -> wake_up_interruptible_sync_poll After receiving ACK Active open connect sys_connect -> inet_stream_connect -> __inet_stream_connect -> tcp_v4_connect (sk->sk_prot->connect) -> ip_route_connect tcp_set_state(sk, TCP_SYN_SENT) -> inet_hash_connect -> port_offset = inet_sk_port_offset(sk) -> secure_ipv4_port_ephemeral(saddr, daddr, dport) -> md5_transform -> __inet_hash_connect(..., port_offset, __inet_check_established) static uint32_t hint // counter -> inet_get_local_port_range -> inet_bind_bucket_create -> inet_bind_hash -> sk_add_bind_node -> inet_ehash_nolisten -> inet_ehash_insert -> sk_ehashfn -> inet_ehashfn -> __inet_ehashfn -> jhash_3words -> sock_prot_inuse_add -> ip_route_newports -> ip_route_output_flow -> secure_tcp_sequence_number(saddr, daddr, sport, dport) -> md5_transform -> tcp_connect -> tcp_connect_init -> sk_stream_alloc_skb -> tcp_init_nondata_skb -> tcp_connect_queue_skb -> tcp_ecn_send_syn -> tcp_transmit_skb -> tcp_options_size = tcp_syn_options tcp_header_size = tcp_options_size + sizeof(struct tcphdr); -> skb_push(skb, tcp_header_size) -> skb_reset_transport_header -> skb_orphan skb->destructor = tcp_wfree; -> tcp_options_write -> tcp_v4_send_check (icsk->icsk_af_ops->send_check) -> __tcp_v4_send_check skb->ip_summed == CHECKSUM_PARTIAL -> ip_queue_xmit (icsk->icsk_af_ops->queue_xmit) -> skb_push -> skb_reset_network_header iph->frag_off = htons(IP_DF); -> ip_copy_addrs -> ip_select_ident_segs -> ip_local_out -> __ip_local_out -> ip_send_check -> ip_fast_csum -> nf_hook { return 1; } -> dst_output -> ip_output (skb_dst(skb)->output) -> inet_csk_reset_xmit_timer sock->state = SS_CONNECTING; err = -EINPROGRESS; timeo = sock_sndtimeo() // NULL return err After connect() Receive SYN+ACK tcp_v4_rcv -> __inet_lookup_skb -> __inet_lookup -> __inet_lookup_established // found -> tcp_v4_do_rcv // sk_state == TCP_SYN_SENT -> tcp_rcv_state_process case TCP_SYN_SENT: -> tcp_rcv_synsent_state_process -> tcp_parse_options if (th->ack) // true -> tcp_ecn_rcv_synack -> tcp_init_wl -> tcp_ack(FLAG_SLOWPATH) // FLAG_SLOWPATH -> tcp_ack_update_window -> tcp_may_update_window // true -> tcp_update_wln -> tcp_fast_path_check -> tcp_sync_mss -> tcp_snd_una_update -> tcp_ecn_rcv_ecn_echo // false -> tcp_in_ack_event -> tcp_clean_rtx_queue -> tcp_ack_update_rtt -> tcp_rearm_rto -> tcp_rate_gen -> tcp_cong_control -> tcp_xmit_recovery -> tcp_mtup_init -> tcp_sync_mss -> tcp_initialize_rcv_mss -> tcp_finish_connect -> tcp_set_state(sk, TCP_ESTABLISHED); -> inet_sk_rx_dst_set (icsk->icsk_af_ops->sk_rx_dst_set) -> inet_sk_rebuild_header (icsk->icsk_af_ops->rebuild_header) -> tcp_init_metrics -> tcp_init_congestion_control -> tcp_init_buffer_space -> tcp_fixup_rcvbuf -> tcp_sndbuf_expand -> tcp_full_space -> tcp_send_ack -> skb_reserve -> tcp_init_nondata_skb -> skb_set_tcp_pure_ack -> skb_mstamp_get -> tcp_transmit_skb -> tcp_options_size = tcp_established_options // 12 ... -> tcp_urg -> __kfree_skb -> tcp_data_snd_check return 0; accept sys_accept4 -> newsock = sock_alloc -> newfd = get_unused_fd_flags -> newfile = sock_alloc_file(newsock, ...) -> inet_accept (sock->ops->accept) -> sk2 = inet_csk_accept (sk1->sk_prot->accept) queue = &icsk->icsk_accept_queue; req = reqsk_queue_remove(queue, sk); req = queue->rskq_accept_head; -> sk_acceptq_removed(parent); // sk->sk_ack_backlog--; newsk = req->sk -> release_sock(sk) -> reqsk_put(req) -> reqsk_free return newsk -> sock_graft(sk2, newsock) -> fd_install(newfd, newfile) read write do_syscall_64 -> __x64_sys_write -> ksys_write -> vfs_write -> __vfs_write -> new_sync_write -> sock_write_iter -> sock_sendmsg -> inet_sendmsg -> tcp_sendmsg -> tcp_sendmsg_locked -> tcp_push_one -> tcp_write_xmit tcp_sendmsg_locked -> __tcp_push_pending_frames -> tcp_write_xmit tcp_sendmsg_locked -> tcp_push -> __tcp_push_pending_frames -> tcp_write_xmit Receive net_rx_action -> napi_poll -> mlx4_en_poll_rx_cq -> napi_complete_done -> gro_normal_list -> netif_receive_skb_list_internal -> __netif_receive_skb_list -> __netif_receive_skb_list_core -> __netif_receive_skb_list_ptype -> ip_list_rcv -> ip_sublist_rcv -> ip_list_rcv_finish -> ip_sublist_rcv_finish -> dst_input -> ip_local_deliver -> NF_HOOK -> ip_local_deliver_finish -> ip_protocol_deliver_rcu -> tcp_v4_rcv netif_receive_skb -> __netif_receive_skb -> __netif_receive_skb_one_core -> ip_rcv_finish_core -> ip_rcv -> ip_rcv_finish -> ip_protocol_deliver_rcu -> ip_local_deliver -> ip_local_deliver_finish -> ip_protocol_deliver_rcu _> tcp_v4_rcv transmit tcp_v4_rcv -> tcp_v4_do_rcv -> tcp_rcv_established -> __tcp_push_pending_frames -> tcp_write_xmit tcp_write_xmit -> tcp_transmit_skb -> __tcp_transmit_skb -> ip_queue_xmit -> __ip_queue_xmit -> ip_local_out -> __ip_local_out -> ip_output","title":"Call Graphs"},{"location":"kernel/callgraph/#tcp_sock","text":"","title":"tcp_sock"},{"location":"kernel/callgraph/#tcp_hashinfo","text":"// include/linux/types.h struct hlist_head { struct hlist_node *first; }; struct hlist_node { struct hlist_node *next, **pprev; }; // include/linux/list_nulls.h struct hlist_nulls_head { struct hlist_nulls_node *first; }; struct hlist_nulls_node { struct hlist_nulls_node *next, **pprev; }; // include/net/inet_hashtables.h struct inet_ehash_bucket { struct hlist_nulls_head chain; }; struct inet_bind_hashbucket { spinlock_t lock; // empty struct hlist_head chain; }; struct inet_listen_hashbucket { spinlock_t lock; // empty struct hlist_head head; }; #define INET_LHTABLE_SIZE 32 /* Yes, really, this is all you need. */ struct inet_hashinfo { /* This is for sockets with full identity only. Sockets here will * always be without wildcards and will have the following invariant: * * TCP_ESTABLISHED <= sk->sk_state < TCP_CLOSE * */ struct inet_ehash_bucket *ehash; spinlock_t *ehash_locks; unsigned int ehash_mask; unsigned int ehash_locks_mask; /* Ok, let's try this, I give up, we do need a local binding * TCP hash as well as the others for fast bind/connect. */ struct inet_bind_hashbucket *bhash; unsigned int bhash_size; /* 4 bytes hole on 64 bit */ struct kmem_cache *bind_bucket_cachep; /* All the above members are written once at bootup and * never written again _or_ are predominantly read-access. * * Now align to a new cache line as all the following members * might be often dirty. */ /* All sockets in TCP_LISTEN state will be in here. This is the only * table where wildcard'd TCP sockets can exist. Hash function here * is just local port number. */ struct inet_listen_hashbucket listening_hash[INET_LHTABLE_SIZE] ____cacheline_aligned_in_smp; };","title":"tcp_hashinfo"},{"location":"kernel/callgraph/#tcp-state-diagram-in-linux-44","text":"","title":"TCP state diagram in Linux 4.4+"},{"location":"kernel/callgraph/#bind","text":"sys_bind -> inet_bind -> inet_csk_get_port -> goto have_snum: -> goto tb_not_found: tb == NULL -> inet_bind_bucket_create -> goto success: -> inet_bind_hash -> sk_add_bind_node -> fput_light // tcp_hashinfo.bhash -> inet_bind_hashbucket -> inet_bind_bucket[port=2222] -> tcp_sock","title":"bind"},{"location":"kernel/callgraph/#listen","text":"sys_listen -> inet_listen -> inet_csk_listen_start -> reqsk_queue_alloc -> inet_csk_delack_init -> set sk->sk_state = TCP_LISTEN -> inet_csk_get_port -> goto have_snum: -> goto tb_found: -> inet_csk_bind_conflict -> goto tb_not_found: tb != NULL -> inet_hash -> __inet_hash // tcp_hashinfo.listening_hash[X] add node After bind() and listen()","title":"listen"},{"location":"kernel/callgraph/#passive-open","text":"","title":"Passive open"},{"location":"kernel/callgraph/#receive-syn","text":"tcp_v4_rcv -> __inet_lookup_skb -> __inet_lookup -> __inet_lookup_established -> __inet_lookup_listener // found -> tcp_v4_do_rcv // sk_state == TCP_LISTEN -> tcp_rcv_state_process -> tcp_v4_conn_request // icsk->icsk_af_ops->conn_request -> tcp_conn_request -> req = inet_reqsk_alloc -> reqsk_alloc req->rsk_listener = sk_listener; ireq->ireq_state = TCP_NEW_SYN_RECV; ireq->ireq_family = sk_listener->sk_family; -> tcp_parse_options -> tcp_openreq_init -> tcp_v4_init_req // af_ops->init_req -> tcp_v4_save_options -> isn = tcp_v4_init_sequence // af_ops->init_seq -> tcp_v4_route_req // af_ops->route_req -> inet_csk_route_req -> flowi4_init_output -> ip_route_output_flow -> tcp_ecn_create_request -> tcp_openreq_init_rwin -> tcp_select_initial_window -> tcp_reqsk_record_syn -> tcp_try_fastopen -> inet_csk_reqsk_queue_hash_add -> reqsk_queue_hash_req //*** -> inet_ehash_insert -> __sk_nulls_add_node_rcu -> inet_csk_reqsk_queue_added inet_csk(sk)->icsk_accept_queue.qlen++ -> tcp_v4_send_synack // af_ops->send_synack -> tcp_make_synack -> __tcp_v4_send_check -> ip_build_and_send_pkt -> ip_local_out -> __ip_local_out -> dst_output -> ip_output After receiving SYN","title":"Receive SYN"},{"location":"kernel/callgraph/#receive-ack","text":"tcp_v4_rcv -> __inet_lookup_skb -> __inet_lookup -> __inet_lookup_established // found tcp_request_sock -> sk->sk_state == TCP_NEW_SYN_RECV sk = req->rsk_listener; -> tcp_check_req -> tcp_parse_options -> tcp_paws_reject -> tcp_in_window -> tcp_v4_syn_recv_sock // inet_csk(sk)->icsk_af_ops->syn_recv_sock -> tcp_create_openreq_child -> inet_csk_clone_lock -> sk_clone_lock -> newsk = sk_prot_alloc // new tcp_sock -> sock_copy newsk->sk_state = TCP_SYN_RECV; -> tcp_init_xmit_timers -> inet_sk_rx_dst_set -> inet_csk_route_child_sock -> tcp_ca_openreq_child -> tcp_assign_congestion_control -> tcp_set_ca_state TCP_CA_Open -> tcp_sync_mss -> dst_mtu -> ipv4_mtu -> tcp_mtu_to_mss -> tcp_bound_to_half_wnd -> dst_metric_advmss -> ipv4_default_advmss -> tcp_initialize_rcv_mss -> __inet_inherit_port -> inet_bind_hash // put newsk in bind_bucket inet_csk(sk)->icsk_bind_hash = tb; -> inet_ehash_nolisten -> inet_ehash_insert(newsk, reqsk) -> sk_nulls_del_node_init_rcu(osk) -> __sk_nulls_add_node_rcu(sk, list) -> sock_prot_inuse_add -> tcp_move_syn -> sock_rps_save_rxhash -> tcp_synack_rtt_meas -> skb_mstamp_us_delta -> tcp_ack_update_rtt -> tcp_update_rtt_min -> tcp_rtt_estimator -> tcp_set_rto -> inet_csk_complete_hashdance -> inet_csk_reqsk_queue_drop -> reqsk_queue_unlink -> reqsk_put(req) return found(false) -> reqsk_queue_removed &inet_csk(sk)->icsk_accept_queue.qlen-- -> inet_csk_reqsk_queue_add queue->rskq_accept_head = req // first -> sk_acceptq_added sk->sk_ack_backlog++; // listen_sk -> tcp_child_process -> tcp_rcv_state_process(child, skb) -> tcp_validate_incoming -> tcp_ack -> tcp_ack_update_window -> tcp_ecn_rcv_ecn_echo // false -> tcp_in_ack_event return 1 switch(sk_state) case TCP_SYN_RECV: -> inet_sk_rebuild_header // icsk->icsk_af_ops->rebuild_header -> tcp_init_congestion_control -> tcp_mtup_init -> tcp_init_buffer_space -> tcp_fixup_rcvbuf -> tcp_sndbuf_expand -> tcp_full_space tcp_set_state(sk, TCP_ESTABLISHED) sk->sk_state_change -> sock_def_wakeup -> tcp_init_metrics -> tcp_update_pacing_rate -> tcp_initialize_rcv_mss -> tcp_fast_path_on // out of switch -> tcp_urg switch TCP_ESTABLISHED -> tcp_data_queue -> tcp_data_snd_check -> tcp_ack_snd_check -> parent->sk_data_ready -> sock_def_readable -> wake_up_interruptible_sync_poll After receiving ACK","title":"Receive ACK"},{"location":"kernel/callgraph/#active-open","text":"","title":"Active open"},{"location":"kernel/callgraph/#connect","text":"sys_connect -> inet_stream_connect -> __inet_stream_connect -> tcp_v4_connect (sk->sk_prot->connect) -> ip_route_connect tcp_set_state(sk, TCP_SYN_SENT) -> inet_hash_connect -> port_offset = inet_sk_port_offset(sk) -> secure_ipv4_port_ephemeral(saddr, daddr, dport) -> md5_transform -> __inet_hash_connect(..., port_offset, __inet_check_established) static uint32_t hint // counter -> inet_get_local_port_range -> inet_bind_bucket_create -> inet_bind_hash -> sk_add_bind_node -> inet_ehash_nolisten -> inet_ehash_insert -> sk_ehashfn -> inet_ehashfn -> __inet_ehashfn -> jhash_3words -> sock_prot_inuse_add -> ip_route_newports -> ip_route_output_flow -> secure_tcp_sequence_number(saddr, daddr, sport, dport) -> md5_transform -> tcp_connect -> tcp_connect_init -> sk_stream_alloc_skb -> tcp_init_nondata_skb -> tcp_connect_queue_skb -> tcp_ecn_send_syn -> tcp_transmit_skb -> tcp_options_size = tcp_syn_options tcp_header_size = tcp_options_size + sizeof(struct tcphdr); -> skb_push(skb, tcp_header_size) -> skb_reset_transport_header -> skb_orphan skb->destructor = tcp_wfree; -> tcp_options_write -> tcp_v4_send_check (icsk->icsk_af_ops->send_check) -> __tcp_v4_send_check skb->ip_summed == CHECKSUM_PARTIAL -> ip_queue_xmit (icsk->icsk_af_ops->queue_xmit) -> skb_push -> skb_reset_network_header iph->frag_off = htons(IP_DF); -> ip_copy_addrs -> ip_select_ident_segs -> ip_local_out -> __ip_local_out -> ip_send_check -> ip_fast_csum -> nf_hook { return 1; } -> dst_output -> ip_output (skb_dst(skb)->output) -> inet_csk_reset_xmit_timer sock->state = SS_CONNECTING; err = -EINPROGRESS; timeo = sock_sndtimeo() // NULL return err After connect()","title":"connect"},{"location":"kernel/callgraph/#receive-synack","text":"tcp_v4_rcv -> __inet_lookup_skb -> __inet_lookup -> __inet_lookup_established // found -> tcp_v4_do_rcv // sk_state == TCP_SYN_SENT -> tcp_rcv_state_process case TCP_SYN_SENT: -> tcp_rcv_synsent_state_process -> tcp_parse_options if (th->ack) // true -> tcp_ecn_rcv_synack -> tcp_init_wl -> tcp_ack(FLAG_SLOWPATH) // FLAG_SLOWPATH -> tcp_ack_update_window -> tcp_may_update_window // true -> tcp_update_wln -> tcp_fast_path_check -> tcp_sync_mss -> tcp_snd_una_update -> tcp_ecn_rcv_ecn_echo // false -> tcp_in_ack_event -> tcp_clean_rtx_queue -> tcp_ack_update_rtt -> tcp_rearm_rto -> tcp_rate_gen -> tcp_cong_control -> tcp_xmit_recovery -> tcp_mtup_init -> tcp_sync_mss -> tcp_initialize_rcv_mss -> tcp_finish_connect -> tcp_set_state(sk, TCP_ESTABLISHED); -> inet_sk_rx_dst_set (icsk->icsk_af_ops->sk_rx_dst_set) -> inet_sk_rebuild_header (icsk->icsk_af_ops->rebuild_header) -> tcp_init_metrics -> tcp_init_congestion_control -> tcp_init_buffer_space -> tcp_fixup_rcvbuf -> tcp_sndbuf_expand -> tcp_full_space -> tcp_send_ack -> skb_reserve -> tcp_init_nondata_skb -> skb_set_tcp_pure_ack -> skb_mstamp_get -> tcp_transmit_skb -> tcp_options_size = tcp_established_options // 12 ... -> tcp_urg -> __kfree_skb -> tcp_data_snd_check return 0;","title":"Receive SYN+ACK"},{"location":"kernel/callgraph/#accept","text":"sys_accept4 -> newsock = sock_alloc -> newfd = get_unused_fd_flags -> newfile = sock_alloc_file(newsock, ...) -> inet_accept (sock->ops->accept) -> sk2 = inet_csk_accept (sk1->sk_prot->accept) queue = &icsk->icsk_accept_queue; req = reqsk_queue_remove(queue, sk); req = queue->rskq_accept_head; -> sk_acceptq_removed(parent); // sk->sk_ack_backlog--; newsk = req->sk -> release_sock(sk) -> reqsk_put(req) -> reqsk_free return newsk -> sock_graft(sk2, newsock) -> fd_install(newfd, newfile)","title":"accept"},{"location":"kernel/callgraph/#read","text":"","title":"read"},{"location":"kernel/callgraph/#write","text":"do_syscall_64 -> __x64_sys_write -> ksys_write -> vfs_write -> __vfs_write -> new_sync_write -> sock_write_iter -> sock_sendmsg -> inet_sendmsg -> tcp_sendmsg -> tcp_sendmsg_locked -> tcp_push_one -> tcp_write_xmit tcp_sendmsg_locked -> __tcp_push_pending_frames -> tcp_write_xmit tcp_sendmsg_locked -> tcp_push -> __tcp_push_pending_frames -> tcp_write_xmit","title":"write"},{"location":"kernel/callgraph/#receive","text":"net_rx_action -> napi_poll -> mlx4_en_poll_rx_cq -> napi_complete_done -> gro_normal_list -> netif_receive_skb_list_internal -> __netif_receive_skb_list -> __netif_receive_skb_list_core -> __netif_receive_skb_list_ptype -> ip_list_rcv -> ip_sublist_rcv -> ip_list_rcv_finish -> ip_sublist_rcv_finish -> dst_input -> ip_local_deliver -> NF_HOOK -> ip_local_deliver_finish -> ip_protocol_deliver_rcu -> tcp_v4_rcv netif_receive_skb -> __netif_receive_skb -> __netif_receive_skb_one_core -> ip_rcv_finish_core -> ip_rcv -> ip_rcv_finish -> ip_protocol_deliver_rcu -> ip_local_deliver -> ip_local_deliver_finish -> ip_protocol_deliver_rcu _> tcp_v4_rcv","title":"Receive"},{"location":"kernel/callgraph/#transmit","text":"tcp_v4_rcv -> tcp_v4_do_rcv -> tcp_rcv_established -> __tcp_push_pending_frames -> tcp_write_xmit tcp_write_xmit -> tcp_transmit_skb -> __tcp_transmit_skb -> ip_queue_xmit -> __ip_queue_xmit -> ip_local_out -> __ip_local_out -> ip_output","title":"transmit"},{"location":"kernel/changes/","text":"Kernel changes 5.6 - 2020-03-29 Linux 5.6 Adds pidfd_getfd(2) syscall. Grabbing file descriptors with pidfd_getfd() 5.4 - 2019-11-24 Linux 5.4 waitid() syscall supports P_PIDFD flag. Adding the pidfd abstraction to the kernel snd_wnd added to TCP_INFO . netdev thread . Ubuntu 20.04 and Debian 11 have it. iperf3 shows it in 3.10 . SOMAXCONN increased from 128 to 4096. commit , https://lkml.org/lkml/2019/11/13/510 5.3 - 2019-09-15 Linux 5.3 Adds new pidfd_open(2) syscall. New system calls: pidfd_open() and close_range() 5.2 - 2019-07-07 Linux 5.2 Adds the CLONE_PIDFD flag to clone(2) . Rethinking race-free process signaling 5.1 - 2019-05-05 Linux 5.1 Adds pidfd_send_signal(2) syscall. Toward race-free process signaling 4.17 - 2018-06-03 Linux 4.17 Kernel TLS receive path 4.15 - 2018-01-28 Linux 4.15 tcp: implement rb-tree based retransmit queue commit 75c119afe14f7 diff --git a/include/net/sock.h b/include/net/sock.h index a6b9a8d1a6df..4827094f1db4 100644 --- a/include/net/sock.h +++ b/include/net/sock.h @@ -397,7 +397,10 @@ struct sock { int sk_wmem_queued; refcount_t sk_wmem_alloc; unsigned long sk_tsq_flags; - struct sk_buff *sk_send_head; + union { + struct sk_buff *sk_send_head; // Front of stuff to transmit + struct rb_root tcp_rtx_queue; // TCP re-transmit queue + }; struct sk_buff_head sk_write_queue; // Packet sending queue __s32 sk_peek_off; int sk_write_pending; TUN: enable NAPI for TUN/TAP driver commit 1 , commit 2 4.13 - 2017-09-03 Linux 4.13 TLS in the kernel , sending only. 4.12 - 2017-07-02 Linux 4.12 Removed net.ipv4.tcp_tw_recycle option from Kernel commit . Ref. Coping with the TCP TIME-WAIT state on busy Linux servers by Vincent Bernat. 4.10 - 2017-02-19 Linux 4.10 tcp: sender chronographs instrumentation tcp: drop SYN packets if accept queue is full commit . 4.9 - 2016-12-11 Linux 4.9 BBR congestion control algorithm tcp: use an RB tree for ooo receive queue commit 9f5afeae51 diff --git a/include/linux/tcp.h b/include/linux/tcp.h index 7be9b1242354..c723a465125d 100644 --- a/include/linux/tcp.h +++ b/include/linux/tcp.h @@ -281,10 +281,9 @@ struct tcp_sock { struct sk_buff* lost_skb_hint; struct sk_buff *retransmit_skb_hint; - /* OOO segments go in this list. Note that socket lock must be held, - * as we do not use sk_buff_head lock. - */ - struct sk_buff_head out_of_order_queue; + /* OOO segments go in this rbtree. Socket lock must be held. */ + struct rb_root out_of_order_queue; + struct sk_buff *ooo_last_skb; /* cache rb_last(out_of_order_queue) */ 4.8 - 2016-10-02 Linux 4.8 Reinventing the timer wheel merge 4.6 - 2016-05-15 Linux 4.6 Faster SO_REUSEPORT for TCP 4.5 - 2016-03-13 Linux 4.5 Faster SO_REUSEPORT for UDP Better epoll multithread scalability 4.4 - 2016-01-10 Linux 4.4 TCP scalability Lockless TCP listener SO_INCOMING_CPU TCP_NEW_SYN_RECV commit ca6fb06518836ef9b65dc0aac02ff97704d52a05 Author: Eric Dumazet <edumazet@google.com> Date: Fri Oct 2 11:43:35 2015 -0700 tcp: attach SYNACK messages to request sockets instead of listener If a listen backlog is very big (to avoid syncookies), then the listener sk->sk_wmem_alloc is the main source of false sharing, as we need to touch it twice per SYNACK re-transmit and TX completion. (One SYN packet takes listener lock once, but up to 6 SYNACK are generated) By attaching the skb to the request socket, we remove this source of contention. Tested: listen(fd, 10485760); // single listener (no SO_REUSEPORT) 16 RX/TX queue NIC Sustain a SYNFLOOD attack of ~320,000 SYN per second, Sending ~1,400,000 SYNACK per second. Perf profiles now show listener spinlock being next bottleneck. 20.29% [kernel] [k] queued_spin_lock_slowpath 10.06% [kernel] [k] __inet_lookup_established 5.12% [kernel] [k] reqsk_timer_handler 3.22% [kernel] [k] get_next_timer_interrupt 3.00% [kernel] [k] tcp_make_synack 2.77% [kernel] [k] ipt_do_table 2.70% [kernel] [k] run_timer_softirq 2.50% [kernel] [k] ip_finish_output 2.04% [kernel] [k] cascade Signed-off-by: Eric Dumazet <edumazet@google.com> Signed-off-by: David S. Miller <davem@davemloft.net> commit 079096f103faca2dd87342cca6f23d4b34da8871 Author: Eric Dumazet <edumazet@google.com> Date: Fri Oct 2 11:43:32 2015 -0700 tcp/dccp: install syn_recv requests into ehash table In this patch, we insert request sockets into TCP/DCCP regular ehash table (where ESTABLISHED and TIMEWAIT sockets are) instead of using the per listener hash table. ACK packets find SYN_RECV pseudo sockets without having to find and lock the listener. In nominal conditions, this halves pressure on listener lock. Note that this will allow for SO_REUSEPORT refinements, so that we can select a listener using cpu/numa affinities instead of the prior 'consistent hash', since only SYN packets will apply this selection logic. We will shrink listen_sock in the following patch to ease code review. Signed-off-by: Eric Dumazet <edumazet@google.com> Cc: Ying Cai <ycai@google.com> Cc: Willem de Bruijn <willemb@google.com> Signed-off-by: David S. Miller <davem@davemloft.net> 4.3 - 2015-11-01 Linux 4.3 Adds direct Sockets syscalls to i386. commit 9dea5dc921b5f4045a18c63eb92e84dc274d17eb Author: Andy Lutomirski <luto@kernel.org> Date: Tue Jul 14 15:24:24 2015 -0700 x86/entry/syscalls: Wire up 32-bit direct socket calls On x86_64, there's no socketcall syscall; instead all of the socket calls are real syscalls. For 32-bit programs, we're stuck offering the socketcall syscall, but it would be nice to expose the direct calls as well. This will enable seccomp to filter socket calls (for new userspace only, but that's fine for some applications) and it will provide a tiny performance boost. glibc 2.23 2016-02-19. Ubuntu 16.04 supports it, Debian 8 doesn't. https://github.com/bminor/glibc/commit/e5a5315e2d290fe34e0fb80996c713b8b802dcc9 commit e5a5315e2d290fe34e0fb80996c713b8b802dcc9 Author: Joseph Myers <joseph@codesourcery.com> Date: Wed Dec 9 20:59:43 2015 +0000 Use direct socket syscalls for new kernels on i386, m68k, microblaze, sh. Now that we have __ASSUME_* macros for direct socket syscalls to use them instead of socketcall when they can be assumed to be available on socketcall architectures, this patch defines those macros when appropriate for i386, m68k, microblaze and sh (for 4.3, 4.3, all supported kernels and 2.6.37, respectively; the only use of socketcall support on microblaze is it allows accept4 and sendmmsg to be supported on a wider range of kernel versions). 4.2 - 2015-08-30 Linux 4.2 commit 90c337da1524863838658078ec34241f45d8394d Author: Eric Dumazet <edumazet@google.com> Date: Sat Jun 6 21:17:57 2015 -0700 inet: add IP_BIND_ADDRESS_NO_PORT to overcome bind(0) limitations When an application needs to force a source IP on an active TCP socket it has to use bind(IP, port=x). As most applications do not want to deal with already used ports, x is often set to 0, meaning the kernel is in charge to find an available port. But kernel does not know yet if this socket is going to be a listener or be connected. It has very limited choices (no full knowledge of final 4-tuple for a connect()) With limited ephemeral port range (about 32K ports), it is very easy to fill the space. This patch adds a new SOL_IP socket option, asking kernel to ignore the 0 port provided by application in bind(IP, port=0) and only remember the given IP address. The port will be automatically chosen at connect() time, in a way that allows sharing a source port as long as the 4-tuples are unique. This new feature is available for both IPv4 and IPv6 (Thanks Neal)","title":"Changes"},{"location":"kernel/changes/#kernel-changes","text":"","title":"Kernel changes"},{"location":"kernel/changes/#56-2020-03-29","text":"Linux 5.6 Adds pidfd_getfd(2) syscall. Grabbing file descriptors with pidfd_getfd()","title":"5.6 - 2020-03-29"},{"location":"kernel/changes/#54-2019-11-24","text":"Linux 5.4 waitid() syscall supports P_PIDFD flag. Adding the pidfd abstraction to the kernel snd_wnd added to TCP_INFO . netdev thread . Ubuntu 20.04 and Debian 11 have it. iperf3 shows it in 3.10 . SOMAXCONN increased from 128 to 4096. commit , https://lkml.org/lkml/2019/11/13/510","title":"5.4 - 2019-11-24"},{"location":"kernel/changes/#53-2019-09-15","text":"Linux 5.3 Adds new pidfd_open(2) syscall. New system calls: pidfd_open() and close_range()","title":"5.3 - 2019-09-15"},{"location":"kernel/changes/#52-2019-07-07","text":"Linux 5.2 Adds the CLONE_PIDFD flag to clone(2) . Rethinking race-free process signaling","title":"5.2 - 2019-07-07"},{"location":"kernel/changes/#51-2019-05-05","text":"Linux 5.1 Adds pidfd_send_signal(2) syscall. Toward race-free process signaling","title":"5.1 - 2019-05-05"},{"location":"kernel/changes/#417-2018-06-03","text":"Linux 4.17 Kernel TLS receive path","title":"4.17 - 2018-06-03"},{"location":"kernel/changes/#415-2018-01-28","text":"Linux 4.15 tcp: implement rb-tree based retransmit queue commit 75c119afe14f7 diff --git a/include/net/sock.h b/include/net/sock.h index a6b9a8d1a6df..4827094f1db4 100644 --- a/include/net/sock.h +++ b/include/net/sock.h @@ -397,7 +397,10 @@ struct sock { int sk_wmem_queued; refcount_t sk_wmem_alloc; unsigned long sk_tsq_flags; - struct sk_buff *sk_send_head; + union { + struct sk_buff *sk_send_head; // Front of stuff to transmit + struct rb_root tcp_rtx_queue; // TCP re-transmit queue + }; struct sk_buff_head sk_write_queue; // Packet sending queue __s32 sk_peek_off; int sk_write_pending; TUN: enable NAPI for TUN/TAP driver commit 1 , commit 2","title":"4.15 - 2018-01-28"},{"location":"kernel/changes/#413-2017-09-03","text":"Linux 4.13 TLS in the kernel , sending only.","title":"4.13 - 2017-09-03"},{"location":"kernel/changes/#412-2017-07-02","text":"Linux 4.12 Removed net.ipv4.tcp_tw_recycle option from Kernel commit . Ref. Coping with the TCP TIME-WAIT state on busy Linux servers by Vincent Bernat.","title":"4.12 - 2017-07-02"},{"location":"kernel/changes/#410-2017-02-19","text":"Linux 4.10 tcp: sender chronographs instrumentation tcp: drop SYN packets if accept queue is full commit .","title":"4.10 - 2017-02-19"},{"location":"kernel/changes/#49-2016-12-11","text":"Linux 4.9 BBR congestion control algorithm tcp: use an RB tree for ooo receive queue commit 9f5afeae51 diff --git a/include/linux/tcp.h b/include/linux/tcp.h index 7be9b1242354..c723a465125d 100644 --- a/include/linux/tcp.h +++ b/include/linux/tcp.h @@ -281,10 +281,9 @@ struct tcp_sock { struct sk_buff* lost_skb_hint; struct sk_buff *retransmit_skb_hint; - /* OOO segments go in this list. Note that socket lock must be held, - * as we do not use sk_buff_head lock. - */ - struct sk_buff_head out_of_order_queue; + /* OOO segments go in this rbtree. Socket lock must be held. */ + struct rb_root out_of_order_queue; + struct sk_buff *ooo_last_skb; /* cache rb_last(out_of_order_queue) */","title":"4.9 - 2016-12-11"},{"location":"kernel/changes/#48-2016-10-02","text":"Linux 4.8 Reinventing the timer wheel merge","title":"4.8 - 2016-10-02"},{"location":"kernel/changes/#46-2016-05-15","text":"Linux 4.6 Faster SO_REUSEPORT for TCP","title":"4.6 - 2016-05-15"},{"location":"kernel/changes/#45-2016-03-13","text":"Linux 4.5 Faster SO_REUSEPORT for UDP Better epoll multithread scalability","title":"4.5 - 2016-03-13"},{"location":"kernel/changes/#44-2016-01-10","text":"Linux 4.4 TCP scalability Lockless TCP listener SO_INCOMING_CPU TCP_NEW_SYN_RECV commit ca6fb06518836ef9b65dc0aac02ff97704d52a05 Author: Eric Dumazet <edumazet@google.com> Date: Fri Oct 2 11:43:35 2015 -0700 tcp: attach SYNACK messages to request sockets instead of listener If a listen backlog is very big (to avoid syncookies), then the listener sk->sk_wmem_alloc is the main source of false sharing, as we need to touch it twice per SYNACK re-transmit and TX completion. (One SYN packet takes listener lock once, but up to 6 SYNACK are generated) By attaching the skb to the request socket, we remove this source of contention. Tested: listen(fd, 10485760); // single listener (no SO_REUSEPORT) 16 RX/TX queue NIC Sustain a SYNFLOOD attack of ~320,000 SYN per second, Sending ~1,400,000 SYNACK per second. Perf profiles now show listener spinlock being next bottleneck. 20.29% [kernel] [k] queued_spin_lock_slowpath 10.06% [kernel] [k] __inet_lookup_established 5.12% [kernel] [k] reqsk_timer_handler 3.22% [kernel] [k] get_next_timer_interrupt 3.00% [kernel] [k] tcp_make_synack 2.77% [kernel] [k] ipt_do_table 2.70% [kernel] [k] run_timer_softirq 2.50% [kernel] [k] ip_finish_output 2.04% [kernel] [k] cascade Signed-off-by: Eric Dumazet <edumazet@google.com> Signed-off-by: David S. Miller <davem@davemloft.net> commit 079096f103faca2dd87342cca6f23d4b34da8871 Author: Eric Dumazet <edumazet@google.com> Date: Fri Oct 2 11:43:32 2015 -0700 tcp/dccp: install syn_recv requests into ehash table In this patch, we insert request sockets into TCP/DCCP regular ehash table (where ESTABLISHED and TIMEWAIT sockets are) instead of using the per listener hash table. ACK packets find SYN_RECV pseudo sockets without having to find and lock the listener. In nominal conditions, this halves pressure on listener lock. Note that this will allow for SO_REUSEPORT refinements, so that we can select a listener using cpu/numa affinities instead of the prior 'consistent hash', since only SYN packets will apply this selection logic. We will shrink listen_sock in the following patch to ease code review. Signed-off-by: Eric Dumazet <edumazet@google.com> Cc: Ying Cai <ycai@google.com> Cc: Willem de Bruijn <willemb@google.com> Signed-off-by: David S. Miller <davem@davemloft.net>","title":"4.4 - 2016-01-10"},{"location":"kernel/changes/#43-2015-11-01","text":"Linux 4.3 Adds direct Sockets syscalls to i386. commit 9dea5dc921b5f4045a18c63eb92e84dc274d17eb Author: Andy Lutomirski <luto@kernel.org> Date: Tue Jul 14 15:24:24 2015 -0700 x86/entry/syscalls: Wire up 32-bit direct socket calls On x86_64, there's no socketcall syscall; instead all of the socket calls are real syscalls. For 32-bit programs, we're stuck offering the socketcall syscall, but it would be nice to expose the direct calls as well. This will enable seccomp to filter socket calls (for new userspace only, but that's fine for some applications) and it will provide a tiny performance boost. glibc 2.23 2016-02-19. Ubuntu 16.04 supports it, Debian 8 doesn't. https://github.com/bminor/glibc/commit/e5a5315e2d290fe34e0fb80996c713b8b802dcc9 commit e5a5315e2d290fe34e0fb80996c713b8b802dcc9 Author: Joseph Myers <joseph@codesourcery.com> Date: Wed Dec 9 20:59:43 2015 +0000 Use direct socket syscalls for new kernels on i386, m68k, microblaze, sh. Now that we have __ASSUME_* macros for direct socket syscalls to use them instead of socketcall when they can be assumed to be available on socketcall architectures, this patch defines those macros when appropriate for i386, m68k, microblaze and sh (for 4.3, 4.3, all supported kernels and 2.6.37, respectively; the only use of socketcall support on microblaze is it allows accept4 and sendmmsg to be supported on a wider range of kernel versions).","title":"4.3 - 2015-11-01"},{"location":"kernel/changes/#42-2015-08-30","text":"Linux 4.2 commit 90c337da1524863838658078ec34241f45d8394d Author: Eric Dumazet <edumazet@google.com> Date: Sat Jun 6 21:17:57 2015 -0700 inet: add IP_BIND_ADDRESS_NO_PORT to overcome bind(0) limitations When an application needs to force a source IP on an active TCP socket it has to use bind(IP, port=x). As most applications do not want to deal with already used ports, x is often set to 0, meaning the kernel is in charge to find an available port. But kernel does not know yet if this socket is going to be a listener or be connected. It has very limited choices (no full knowledge of final 4-tuple for a connect()) With limited ephemeral port range (about 32K ports), it is very easy to fill the space. This patch adds a new SOL_IP socket option, asking kernel to ignore the 0 port provided by application in bind(IP, port=0) and only remember the given IP address. The port will be automatically chosen at connect() time, in a way that allows sharing a source port as long as the 4-tuples are unique. This new feature is available for both IPv4 and IPv6 (Thanks Neal)","title":"4.2 - 2015-08-30"},{"location":"kernel/data-structures/","text":"File Descriptor Table // include/linux/sched.h struct task_struct { // ... /* open file information */ struct files_struct *files; // ... }; // include/linux/fdtable.h struct fdtable { unsigned int max_fds; struct file __rcu **fd; /* current fd array */ unsigned long *close_on_exec; unsigned long *open_fds; unsigned long *full_fds_bits; struct rcu_head rcu; }; /* * Open file table structure */ struct files_struct { /* * read mostly part */ atomic_t count; bool resize_in_progress; wait_queue_head_t resize_wait; struct fdtable __rcu *fdt; struct fdtable fdtab; /* * written part on a separate cache line in SMP */ spinlock_t file_lock ____cacheline_aligned_in_smp; unsigned int next_fd; unsigned long close_on_exec_init[1]; unsigned long open_fds_init[1]; unsigned long full_fds_bits_init[1]; struct file __rcu * fd_array[NR_OPEN_DEFAULT]; }; // include/linux/fs.h struct file { union { struct llist_node fu_llist; struct rcu_head fu_rcuhead; } f_u; struct path f_path; struct inode *f_inode; /* cached value */ const struct file_operations *f_op; // ... atomic_long_t f_count; // ... /* needed for tty driver, and maybe others */ void *private_data; #ifdef CONFIG_EPOLL /* Used by fs/eventpoll.c to link all the hooks to this file */ struct list_head f_ep_links; struct list_head f_tfile_llink; #endif }; struct socket{} // include/linux/net.h struct socket_wq { /* Note: wait MUST be first field of socket_wq */ wait_queue_head_t wait; struct fasync_struct *fasync_list; unsigned long flags; /* %SOCKWQ_ASYNC_NOSPACE, etc */ struct rcu_head rcu; } ____cacheline_aligned_in_smp; /** * struct socket - general BSD socket * @state: socket state (%SS_CONNECTED, etc) * @type: socket type (%SOCK_STREAM, etc) * @flags: socket flags (%SOCK_NOSPACE, etc) * @ops: protocol specific socket operations * @file: File back pointer for gc * @sk: internal networking protocol agnostic socket representation * @wq: wait queue for several uses */ struct socket { socket_state state; kmemcheck_bitfield_begin(type); short type; kmemcheck_bitfield_end(type); unsigned long flags; struct socket_wq __rcu *wq; struct file *file; struct sock *sk; const struct proto_ops *ops; }; // include/net/sock.h struct socket_alloc { struct socket socket; struct inode vfs_inode; }; // include/linux/fs.h struct inode { umode_t i_mode; // S_IFSOCK | S_IRWXUGO; unsigned short i_opflags; kuid_t i_uid; kgid_t i_gid; unsigned int i_flags; // ... const struct inode_operations *i_op; struct super_block *i_sb; // ... unsigned long i_ino; // sockfs_dname: \"socket:[%lu]\" // ... union { struct hlist_head i_dentry; struct rcu_head i_rcu; }; // ... }; socket(2) int sys_socket(int family, int type, int protocol) -> struct socket* sock_create(family, type, protocol) -> __sock_create(family, type, protocol) -> struct socket* sock = sock_alloc() -> inode = new_inode_pseudo(super_block of sockfs) // fs/inode.c -> alloc_inode -> sock_alloc_inode (sb->s_op->alloc_inod) -> socket_alloc *ei = kmem_cache_alloc(sock_inode_cachep) // 306B -> socket_wq *wq = kmalloc(sizeof(*wq)) // 24B ei->socket.wq = wq; ei->socket.state = SS_UNCONNECTED; -> inode_init_always sock = SOCKET_I(inode); inode->i_op = &sockfs_inode_ops; // .listxattr = sockfs_listxattr, -> net_families[family]->create(sock, protocol) -> inet_create(sock, protocol) // net/ipv4/af_inet.c -> sock_map_fd() -> get_unused_fd_flags -> sock_alloc_file -> d_alloc_pseudo // sizeof(struct dentry) == 128 -> file = alloc_file(..., &socket_file_ops); // sizeof(struct file) == 140 -> get_empty_filp file.f_op = &socket_file_ops sock->file = file; file->private_data = sock; -> fd_install inet_create(sock, protocol) -> find inet_protosw for sock->type & protocol -> struct sock* sk = sk_alloc() -> sk_prot_alloc -> kmem_cache_alloc (tcp_prot is 1360B) -> sock_init_data sk->sk_socket = sock; sock->sk = sk; -> sk->sk_prot->init(sk) -> tcp_v4_init_sock -> tcp_init_sock -> tcp_init_xmit_timers -> tcp_prequeue_init -> tcp_enable_early_retrans -> tcp_assign_congestion_control sk->sk_state = TCP_CLOSE; icsk->icsk_af_ops = &ipv4_specific; After socket() Memory usage On x86-64 Deiban 8, Linux 3.16, /proc/slabinfo struct size slab cache name file 256 \"filp\" dentry 192 \"dentry\" socket_alloc 640 \"sock_inode_cache\" tcp_sock 1792 \"TCP\" socket_wq 64 \"kmalloc-64\" inet_bind_bucket 64 \"tcp_bind_bucket\" tcp_request_sock 256 \"request_sock_TCP\" inet_timewait_sock 192 \"tw_sock_TCP\" epitem 128 \"eventpoll_epi\" Total : 2944 bytes/socket, not including send/receive buffers. For client sockets, +64B for inet_bind_bucket . net_proto_family family type protocol AF_UNIX=1 SOCK_STREAM=1 0 AF_UNIX SOCK_DGRAM=2 0 AF_INET=2 SOCK_STREAM IPPROTO_TCP=6 AF_INET SOCK_DGRAM IPPROTO_UDP=17 AF_INET SOCK_DGRAM IPPROTO_ICMP=1 AF_INET SOCK_RAW=3 IPPROTO_IP=0 NPROTO=AF_MAX=41 SOCK_MAX=11 no max? // include/linux/net.h // How to create a socket for an address family struct net_proto_family { int family; // AF_INET, AF_UNIX, AF_INET6, etc. must: 0 <= family < NPROTO int (*create)(struct net *net, struct socket *sock, int protocol, int kern); struct module *owner; }; // net/socket.c static const struct net_proto_family *net_families[NPROTO]; // net/ipv4/af_inet.c static int inet_create(struct net *net, struct socket *sock, int protocol, int kern); static const struct net_proto_family inet_family_ops = { .family = PF_INET, .create = inet_create, .owner = THIS_MODULE }; // inet_init() calls sock_register(): net_families[AF_INET] = &inet_family_ops; inet_protosw // include/net/protocol.h /* This is used to register socket interfaces for IP protocols. */ struct inet_protosw { struct list_head list; /* These two fields form the lookup key. */ unsigned short type; /* This is the 2nd argument to socket(2). eg. SOCK_STREAM, SOCK_DGRAM */ unsigned short protocol; /* This is the L4 protocol number. eg. IPPROTO_TCP, IPPROTO_TCP */ struct proto *prot; const struct proto_ops *ops; unsigned char flags; /* See INET_PROTOSW_* below. */ }; #define INET_PROTOSW_REUSE 0x01 /* Are ports automatically reusable? */ #define INET_PROTOSW_PERMANENT 0x02 /* Permanent protocols are unremovable. */ #define INET_PROTOSW_ICSK 0x04 /* Is this an inet_connection_sock? */ // net/ipv4/af_inet.c /* The inetsw table contains everything that inet_create needs to * build a new socket. */ static struct list_head inetsw[SOCK_MAX]; static DEFINE_SPINLOCK(inetsw_lock); /* Upon startup we insert all the elements in inetsw_array[] into * the linked list inetsw. */ static struct inet_protosw inetsw_array[] = { { .type = SOCK_STREAM, .protocol = IPPROTO_TCP, .prot = &tcp_prot, .ops = &inet_stream_ops, .flags = INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK, }, { .type = SOCK_DGRAM, .protocol = IPPROTO_UDP, .prot = &udp_prot, .ops = &inet_dgram_ops, .flags = INET_PROTOSW_PERMANENT, }, { .type = SOCK_DGRAM, .protocol = IPPROTO_ICMP, .prot = &ping_prot, .ops = &inet_dgram_ops, .flags = INET_PROTOSW_REUSE, }, { .type = SOCK_RAW, .protocol = IPPROTO_IP, /* wild card */ .prot = &raw_prot, .ops = &inet_sockraw_ops, .flags = INET_PROTOSW_REUSE, } }; #define INETSW_ARRAY_LEN ARRAY_SIZE(inetsw_array) // inet_init() sock_register(&inet_family_ops); /* Register the socket-side information for inet_create. */ for (struct list_head *r = &inetsw[0]; r < &inetsw[SOCK_MAX]; ++r) INIT_LIST_HEAD(r); for (struct inet_protosw *q = inetsw_array; q < &inetsw_array[INETSW_ARRAY_LEN]; ++q) inet_register_protosw(q); After Initialization: skbuff A sample of receive skb for TCP SYN segment:","title":"Data Structures"},{"location":"kernel/data-structures/#file-descriptor-table","text":"// include/linux/sched.h struct task_struct { // ... /* open file information */ struct files_struct *files; // ... }; // include/linux/fdtable.h struct fdtable { unsigned int max_fds; struct file __rcu **fd; /* current fd array */ unsigned long *close_on_exec; unsigned long *open_fds; unsigned long *full_fds_bits; struct rcu_head rcu; }; /* * Open file table structure */ struct files_struct { /* * read mostly part */ atomic_t count; bool resize_in_progress; wait_queue_head_t resize_wait; struct fdtable __rcu *fdt; struct fdtable fdtab; /* * written part on a separate cache line in SMP */ spinlock_t file_lock ____cacheline_aligned_in_smp; unsigned int next_fd; unsigned long close_on_exec_init[1]; unsigned long open_fds_init[1]; unsigned long full_fds_bits_init[1]; struct file __rcu * fd_array[NR_OPEN_DEFAULT]; }; // include/linux/fs.h struct file { union { struct llist_node fu_llist; struct rcu_head fu_rcuhead; } f_u; struct path f_path; struct inode *f_inode; /* cached value */ const struct file_operations *f_op; // ... atomic_long_t f_count; // ... /* needed for tty driver, and maybe others */ void *private_data; #ifdef CONFIG_EPOLL /* Used by fs/eventpoll.c to link all the hooks to this file */ struct list_head f_ep_links; struct list_head f_tfile_llink; #endif };","title":"File Descriptor Table"},{"location":"kernel/data-structures/#struct-socket","text":"// include/linux/net.h struct socket_wq { /* Note: wait MUST be first field of socket_wq */ wait_queue_head_t wait; struct fasync_struct *fasync_list; unsigned long flags; /* %SOCKWQ_ASYNC_NOSPACE, etc */ struct rcu_head rcu; } ____cacheline_aligned_in_smp; /** * struct socket - general BSD socket * @state: socket state (%SS_CONNECTED, etc) * @type: socket type (%SOCK_STREAM, etc) * @flags: socket flags (%SOCK_NOSPACE, etc) * @ops: protocol specific socket operations * @file: File back pointer for gc * @sk: internal networking protocol agnostic socket representation * @wq: wait queue for several uses */ struct socket { socket_state state; kmemcheck_bitfield_begin(type); short type; kmemcheck_bitfield_end(type); unsigned long flags; struct socket_wq __rcu *wq; struct file *file; struct sock *sk; const struct proto_ops *ops; }; // include/net/sock.h struct socket_alloc { struct socket socket; struct inode vfs_inode; }; // include/linux/fs.h struct inode { umode_t i_mode; // S_IFSOCK | S_IRWXUGO; unsigned short i_opflags; kuid_t i_uid; kgid_t i_gid; unsigned int i_flags; // ... const struct inode_operations *i_op; struct super_block *i_sb; // ... unsigned long i_ino; // sockfs_dname: \"socket:[%lu]\" // ... union { struct hlist_head i_dentry; struct rcu_head i_rcu; }; // ... };","title":"struct socket{}"},{"location":"kernel/data-structures/#socket2","text":"int sys_socket(int family, int type, int protocol) -> struct socket* sock_create(family, type, protocol) -> __sock_create(family, type, protocol) -> struct socket* sock = sock_alloc() -> inode = new_inode_pseudo(super_block of sockfs) // fs/inode.c -> alloc_inode -> sock_alloc_inode (sb->s_op->alloc_inod) -> socket_alloc *ei = kmem_cache_alloc(sock_inode_cachep) // 306B -> socket_wq *wq = kmalloc(sizeof(*wq)) // 24B ei->socket.wq = wq; ei->socket.state = SS_UNCONNECTED; -> inode_init_always sock = SOCKET_I(inode); inode->i_op = &sockfs_inode_ops; // .listxattr = sockfs_listxattr, -> net_families[family]->create(sock, protocol) -> inet_create(sock, protocol) // net/ipv4/af_inet.c -> sock_map_fd() -> get_unused_fd_flags -> sock_alloc_file -> d_alloc_pseudo // sizeof(struct dentry) == 128 -> file = alloc_file(..., &socket_file_ops); // sizeof(struct file) == 140 -> get_empty_filp file.f_op = &socket_file_ops sock->file = file; file->private_data = sock; -> fd_install inet_create(sock, protocol) -> find inet_protosw for sock->type & protocol -> struct sock* sk = sk_alloc() -> sk_prot_alloc -> kmem_cache_alloc (tcp_prot is 1360B) -> sock_init_data sk->sk_socket = sock; sock->sk = sk; -> sk->sk_prot->init(sk) -> tcp_v4_init_sock -> tcp_init_sock -> tcp_init_xmit_timers -> tcp_prequeue_init -> tcp_enable_early_retrans -> tcp_assign_congestion_control sk->sk_state = TCP_CLOSE; icsk->icsk_af_ops = &ipv4_specific; After socket()","title":"socket(2)"},{"location":"kernel/data-structures/#memory-usage","text":"On x86-64 Deiban 8, Linux 3.16, /proc/slabinfo struct size slab cache name file 256 \"filp\" dentry 192 \"dentry\" socket_alloc 640 \"sock_inode_cache\" tcp_sock 1792 \"TCP\" socket_wq 64 \"kmalloc-64\" inet_bind_bucket 64 \"tcp_bind_bucket\" tcp_request_sock 256 \"request_sock_TCP\" inet_timewait_sock 192 \"tw_sock_TCP\" epitem 128 \"eventpoll_epi\" Total : 2944 bytes/socket, not including send/receive buffers. For client sockets, +64B for inet_bind_bucket .","title":"Memory usage"},{"location":"kernel/data-structures/#net_proto_family","text":"family type protocol AF_UNIX=1 SOCK_STREAM=1 0 AF_UNIX SOCK_DGRAM=2 0 AF_INET=2 SOCK_STREAM IPPROTO_TCP=6 AF_INET SOCK_DGRAM IPPROTO_UDP=17 AF_INET SOCK_DGRAM IPPROTO_ICMP=1 AF_INET SOCK_RAW=3 IPPROTO_IP=0 NPROTO=AF_MAX=41 SOCK_MAX=11 no max? // include/linux/net.h // How to create a socket for an address family struct net_proto_family { int family; // AF_INET, AF_UNIX, AF_INET6, etc. must: 0 <= family < NPROTO int (*create)(struct net *net, struct socket *sock, int protocol, int kern); struct module *owner; }; // net/socket.c static const struct net_proto_family *net_families[NPROTO]; // net/ipv4/af_inet.c static int inet_create(struct net *net, struct socket *sock, int protocol, int kern); static const struct net_proto_family inet_family_ops = { .family = PF_INET, .create = inet_create, .owner = THIS_MODULE }; // inet_init() calls sock_register(): net_families[AF_INET] = &inet_family_ops;","title":"net_proto_family"},{"location":"kernel/data-structures/#inet_protosw","text":"// include/net/protocol.h /* This is used to register socket interfaces for IP protocols. */ struct inet_protosw { struct list_head list; /* These two fields form the lookup key. */ unsigned short type; /* This is the 2nd argument to socket(2). eg. SOCK_STREAM, SOCK_DGRAM */ unsigned short protocol; /* This is the L4 protocol number. eg. IPPROTO_TCP, IPPROTO_TCP */ struct proto *prot; const struct proto_ops *ops; unsigned char flags; /* See INET_PROTOSW_* below. */ }; #define INET_PROTOSW_REUSE 0x01 /* Are ports automatically reusable? */ #define INET_PROTOSW_PERMANENT 0x02 /* Permanent protocols are unremovable. */ #define INET_PROTOSW_ICSK 0x04 /* Is this an inet_connection_sock? */ // net/ipv4/af_inet.c /* The inetsw table contains everything that inet_create needs to * build a new socket. */ static struct list_head inetsw[SOCK_MAX]; static DEFINE_SPINLOCK(inetsw_lock); /* Upon startup we insert all the elements in inetsw_array[] into * the linked list inetsw. */ static struct inet_protosw inetsw_array[] = { { .type = SOCK_STREAM, .protocol = IPPROTO_TCP, .prot = &tcp_prot, .ops = &inet_stream_ops, .flags = INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK, }, { .type = SOCK_DGRAM, .protocol = IPPROTO_UDP, .prot = &udp_prot, .ops = &inet_dgram_ops, .flags = INET_PROTOSW_PERMANENT, }, { .type = SOCK_DGRAM, .protocol = IPPROTO_ICMP, .prot = &ping_prot, .ops = &inet_dgram_ops, .flags = INET_PROTOSW_REUSE, }, { .type = SOCK_RAW, .protocol = IPPROTO_IP, /* wild card */ .prot = &raw_prot, .ops = &inet_sockraw_ops, .flags = INET_PROTOSW_REUSE, } }; #define INETSW_ARRAY_LEN ARRAY_SIZE(inetsw_array) // inet_init() sock_register(&inet_family_ops); /* Register the socket-side information for inet_create. */ for (struct list_head *r = &inetsw[0]; r < &inetsw[SOCK_MAX]; ++r) INIT_LIST_HEAD(r); for (struct inet_protosw *q = inetsw_array; q < &inetsw_array[INETSW_ARRAY_LEN]; ++q) inet_register_protosw(q); After Initialization:","title":"inet_protosw"},{"location":"kernel/data-structures/#skbuff","text":"A sample of receive skb for TCP SYN segment:","title":"skbuff"},{"location":"kernel/docs/","text":"Links to kernel docs Ext2 filesystem Design and Implementation of the Second Extended Filesystem by R\u00e9my Card, Theodore Ts'o, and Stephen Tweedie, 1994 Dec. Second Extended File System by Dave Poirier John's spec of the second extended filesystem OS Classes ops-class.org/ Release history http://web.soccerlab.polymtl.ca/ser-repos/public/data-sets/linux-kernels/kernel-history/","title":"Docs"},{"location":"kernel/docs/#links-to-kernel-docs","text":"","title":"Links to kernel docs"},{"location":"kernel/docs/#ext2-filesystem","text":"Design and Implementation of the Second Extended Filesystem by R\u00e9my Card, Theodore Ts'o, and Stephen Tweedie, 1994 Dec. Second Extended File System by Dave Poirier John's spec of the second extended filesystem","title":"Ext2 filesystem"},{"location":"kernel/docs/#os-classes","text":"ops-class.org/","title":"OS Classes"},{"location":"kernel/docs/#release-history","text":"http://web.soccerlab.polymtl.ca/ser-repos/public/data-sets/linux-kernels/kernel-history/","title":"Release history"},{"location":"kernel/epoll/","text":"EPOLL(7) data structures After epoll_create() After epoll_ctl(ADD, socketfd) pipe()","title":"Epoll"},{"location":"kernel/epoll/#epoll7-data-structures","text":"","title":"EPOLL(7) data structures"},{"location":"kernel/epoll/#after-epoll_create","text":"","title":"After epoll_create()"},{"location":"kernel/epoll/#after-epoll_ctladd-socketfd","text":"","title":"After epoll_ctl(ADD, socketfd)"},{"location":"kernel/epoll/#pipe","text":"","title":"pipe()"},{"location":"kernel/eventpoll/","text":"epoll Data structures eventpoll{} epitem{} eppoll_entry epoll_create() epoll_create1(flags) CHECK(only valid flags is O_CLOEXEC) struct eventpool* ep = ep_alloc(); int fd = get_unused_fd_flags() -> __alloc_fd fd = find_next_fd() __set_open_fd(fd, fdt) struct file* file = anon_inode_getfile(name, fops, ep) path.dentry = d_alloc_pseudo() path.mnt = mntget() d_instantiate(path.dentry) file = alloc_file(&path, flags, fops) file->private_data = ep ep->file = file fd_install(fd, file) return fd close() close(fd) -> __close_fd(current->files, fd) struct fdtable* fdt = files_fdtable(files) struct file* file = fdt->fd[fd] fdt->fd[fd] = NULL -> __put_unused_fd(files, fd) -> __clear_open_fd(fd, fdt) // clear bit masks -> filp_close(file, files) -> fput(file) if (file_count(file) == 0) return 0 if (--file->f_count == 0) __fput(file) // delayed -> file->f_op->release(inode, file) struct eventpoll *ep = file->private_data if (ep) ep_free(ep) -> ep_remove(ep, epi) -> epi_rcu_free epoll_ctl(ADD/DEL/MOD) epoll_ctl(epfd, op, fd event) f = fdget(epfd) // epoll itself tf = fdget(fd) // target eventpoll* ep = f.file->private_data if (ADD) -> ep_look_check(ep, tf.file) epitem* epi = ep_find(ep, tf.file, fd) if (ADD && epi == NULL) -> ep_insert(ep, event, tf.file, fd, ) if (DEL && epi != NULL) -> ep_remove(ep, epi) if (MOD && epi != NULL && !(event & EXCLUSIVE)) -> ep_modify(ep, epi, event) ep_insert -> ep_insert ep_remove -> ep_remove ep_modify -> ep_modify epoll_wait()","title":"epoll"},{"location":"kernel/eventpoll/#epoll","text":"","title":"epoll"},{"location":"kernel/eventpoll/#data-structures","text":"","title":"Data structures"},{"location":"kernel/eventpoll/#eventpoll","text":"","title":"eventpoll{}"},{"location":"kernel/eventpoll/#epitem","text":"","title":"epitem{}"},{"location":"kernel/eventpoll/#eppoll_entry","text":"","title":"eppoll_entry"},{"location":"kernel/eventpoll/#epoll_create","text":"epoll_create1(flags) CHECK(only valid flags is O_CLOEXEC) struct eventpool* ep = ep_alloc(); int fd = get_unused_fd_flags() -> __alloc_fd fd = find_next_fd() __set_open_fd(fd, fdt) struct file* file = anon_inode_getfile(name, fops, ep) path.dentry = d_alloc_pseudo() path.mnt = mntget() d_instantiate(path.dentry) file = alloc_file(&path, flags, fops) file->private_data = ep ep->file = file fd_install(fd, file) return fd","title":"epoll_create()"},{"location":"kernel/eventpoll/#close","text":"close(fd) -> __close_fd(current->files, fd) struct fdtable* fdt = files_fdtable(files) struct file* file = fdt->fd[fd] fdt->fd[fd] = NULL -> __put_unused_fd(files, fd) -> __clear_open_fd(fd, fdt) // clear bit masks -> filp_close(file, files) -> fput(file) if (file_count(file) == 0) return 0 if (--file->f_count == 0) __fput(file) // delayed -> file->f_op->release(inode, file) struct eventpoll *ep = file->private_data if (ep) ep_free(ep) -> ep_remove(ep, epi) -> epi_rcu_free","title":"close()"},{"location":"kernel/eventpoll/#epoll_ctladddelmod","text":"epoll_ctl(epfd, op, fd event) f = fdget(epfd) // epoll itself tf = fdget(fd) // target eventpoll* ep = f.file->private_data if (ADD) -> ep_look_check(ep, tf.file) epitem* epi = ep_find(ep, tf.file, fd) if (ADD && epi == NULL) -> ep_insert(ep, event, tf.file, fd, ) if (DEL && epi != NULL) -> ep_remove(ep, epi) if (MOD && epi != NULL && !(event & EXCLUSIVE)) -> ep_modify(ep, epi, event)","title":"epoll_ctl(ADD/DEL/MOD)"},{"location":"kernel/eventpoll/#ep_insert","text":"-> ep_insert","title":"ep_insert"},{"location":"kernel/eventpoll/#ep_remove","text":"-> ep_remove","title":"ep_remove"},{"location":"kernel/eventpoll/#ep_modify","text":"-> ep_modify","title":"ep_modify"},{"location":"kernel/eventpoll/#epoll_wait","text":"","title":"epoll_wait()"},{"location":"kernel/file-descriptor-table/","text":"Evolution of File Descriptor Table in Linux Kernel 0.01 to 1.1.10 filp is a fixed length array in struct task_struct . // // linux-0.99 // // // include/linux/sched.h // struct task_struct { // ... struct file * filp[NR_OPEN]; fd_set close_on_exec; // ... }; // // include/linux/fs.h // struct file { mode_t f_mode; dev_t f_rdev; off_t f_pos; // each opened file has its own offset unsigned short f_flags; unsigned short f_count; unsigned short f_reada; struct inode * f_inode; struct file_operations * f_op; }; struct inode { dev_t i_dev; unsigned long i_ino; umode_t i_mode; nlink_t i_nlink; uid_t i_uid; gid_t i_gid; dev_t i_rdev; off_t i_size; // each disk file has one size time_t i_atime; time_t i_mtime; time_t i_ctime; unsigned long i_blksize; unsigned long i_blocks; struct inode_operations * i_op; struct super_block * i_sb; // ... }; // // fs/file_table.c // struct file file_table[NR_FILE]; struct file * get_empty_filp(void) { int i; struct file * f = file_table+0; for (i = 0; i++ < NR_FILE; f++) if (!f->f_count) { memset(f,0,sizeof(*f)); f->f_count = 1; return f; } return NULL; } // // fs/inode.c // static struct inode inode_table[NR_INODE]; See https://en.wikipedia.org/wiki/File_descriptor for per-process file descriptor table , system-wide file table and inode table . Relation of three tables: Thie simplest case is one process opens one disk file (e.g. open(\"/var/log/access.log\", O_WRONLY) ), it uses one entry from each table. Then the process does a dup() , the old and new file descriptors may be used interchangeably. Two file descriptors refer to the same open file, and thus share file offset and file status flags. However, the two file descriptors do not share file descriptor flags ( close_on_exec ). Later, the process does a open(\"/var/log/access.log\", O_RDONLY) , a new file descriptor and new file description is created, and pointing to the same inode entry. Therefore, it sees the same file size as the first two fds, but different offset. Sizes of those three tables in early Linux NR_OPEN : How many files can a process open? NR_FILE : How many files can all processes open? NR_INODE : How many disk files can all processes open? Version Date NR_OPEN NR_FILE NR_INODE 0.01 1991-09-17 20 64 32 0.12 1992-01-15 20 64 64 0.95 1992-03-08 20 64 128 0.96a.3 1992-05-22 32 64 128 0.96c.1 1992-07-04 32 128 128 0.97 1992-08-01 32 128 128 0.98.4 1992-11-09 256 128 128 0.99.10 1993-06-07 256 1024 2048 Note 1: file_table and inode_table were made dynamic in 0.99.10. [PATCH] Linux-0.99.10 (June 7, 1993) The \"struct file\" file_table is made dynamic, instaed of a static allocation. For the first time you can have _lots_ of files open. diff --git a/fs/file_table.c b/fs/file_table.c --- a/fs/file_table.c +++ b/fs/file_table.c -struct file file_table[NR_FILE]; +struct file * first_file; +int nr_files = 0; Note 2: ext2 file system was added 0.99.7. 1.1.11 to 1.3.21 Split into struct files_struct . 1.1.11 was released in 1995/05. // include/linux/sched.h of linux-1.3.21 struct files_struct { int count; fd_set close_on_exec; struct file * fd[NR_OPEN]; }; struct task_struct { // ... /* filesystem information */ struct fs_struct fs[1]; /* open file information */ struct files_struct files[1]; /* memory management info */ struct mm_struct mm[1]; // ... }; 1.3.22 to 2.1.89 Change files from a struct[1] to a pointer, so it can be shared by threads within a process. 1.3.22 was released in 1995/09. LinuxThreads needs 2.0 kernel, which was released in 1996/07. // include/linux/sched.h of linux-2.0.2 /* Open file table structure */ struct files_struct { int count; fd_set close_on_exec; fd_set open_fds; struct file * fd[NR_OPEN]; }; struct task_struct { // ... /* filesystem information */ - struct fs_struct fs[1]; + struct fs_struct *fs; /* open file information */ - struct files_struct files[1]; + struct files_struct *files; /* memory management info */ - struct mm_struct mm[1]; + struct mm_struct *mm; // ... }; 2.1.90 to 2.6.13 Change fixed-length array fd to dynamic array. 2.2.0 was released in 1999/01. // include/linux/sched.h of linux-2.2.0 /* * Open file table structure */ struct files_struct { atomic_t count; + int max_fds; + struct file ** fd; /* current fd array */ fd_set close_on_exec; // changed to fd_set* in 2.2.12 fd_set open_fds; - struct file * fd[NR_OPEN]; }; struct task_struct { // ... /* open file information */ struct files_struct *files; // ... }; 2.6.14 to now (4.15.7) Introduce struct fdtable for RCU. 2.6.15 was released in 2006/01, Ubuntu 6.04 LTS and Debian 4 ship it. // include/linux/fdtable.h of linux-2.6.37 struct fdtable { unsigned int max_fds; struct file __rcu **fd; /* current fd array */ fd_set *close_on_exec; fd_set *open_fds; struct rcu_head rcu; struct fdtable *next; }; /* * Open file table structure */ struct files_struct { /* * read mostly part */ atomic_t count; struct fdtable __rcu *fdt; struct fdtable fdtab; /* * written part on a separate cache line in SMP */ spinlock_t file_lock ____cacheline_aligned_in_smp; int next_fd; struct embedded_fd_set close_on_exec_init; struct embedded_fd_set open_fds_init; struct file __rcu * fd_array[NR_OPEN_DEFAULT]; }; struct task_struct { // ... /* open file information */ struct files_struct *files; // ... }; struct file itself. // include/linux/fs.h of linux-4.9 struct file { union { struct llist_node fu_llist; struct rcu_head fu_rcuhead; } f_u; struct path f_path; struct inode *f_inode; /* cached value */ // added back in 3.9, same as f_path.dentry->d_inode const struct file_operations *f_op; /* * Protects f_ep_links, f_flags. * Must not be taken from IRQ context. */ spinlock_t f_lock; atomic_long_t f_count; unsigned int f_flags; fmode_t f_mode; struct mutex f_pos_lock; // Fixed in 3.14 loff_t f_pos; struct fown_struct f_owner; const struct cred *f_cred; struct file_ra_state f_ra; u64 f_version; #ifdef CONFIG_SECURITY void *f_security; #endif /* needed for tty driver, and maybe others */ void *private_data; #ifdef CONFIG_EPOLL /* Used by fs/eventpoll.c to link all the hooks to this file */ struct list_head f_ep_links; struct list_head f_tfile_llink; #endif /* #ifdef CONFIG_EPOLL */ struct address_space *f_mapping; } __attribute__((aligned(4))); /* lest something weird decides that 2 is OK */ FreeBSD up to 9.3 4.3BSD-Reno and older BSDes use fixed-length array of struct file* . struct user { // ... struct file *u_ofile[NOFILE]; /* file structures for open files */ // ... }; From BSD Net/2 up to FreeBSD 9.3 use a similiar dynamic array data structure of Linux 2.0 (see diagram above.), where proc == task_struct , filedesc == files_struct , file == file . // sys/proc.h /* * Process structure. */ struct proc { // ... struct filedesc *p_fd; /* (b) Open files. */ // ... }; // sys/filedesc.h struct filedesc { struct file **fd_ofiles; /* file structures for open files */ char *fd_ofileflags; /* per-process open file flags */ struct vnode *fd_cdir; /* current directory */ struct vnode *fd_rdir; /* root directory */ struct vnode *fd_jdir; /* jail root directory */ int fd_nfiles; /* number of open files allocated */ NDSLOTTYPE *fd_map; /* bitmap of free fds */ int fd_lastfile; /* high-water mark of fd_ofiles */ int fd_freefile; /* approx. next free file */ u_short fd_cmask; /* mask for file creation */ u_short fd_refcnt; /* thread reference count */ u_short fd_holdcnt; /* hold count on structure + mutex */ struct sx fd_sx; /* protects members of this struct */ struct kqlist fd_kqlist; /* list of kqueues on this filedesc */ int fd_holdleaderscount; /* block fdfree() for shared close() */ int fd_holdleaderswakeup; /* fdfree() needs wakeup */ }; // sys/file.h struct file { void *f_data; /* file descriptor specific data */ struct fileops *f_ops; /* File operations */ struct ucred *f_cred; /* associated credentials. */ struct vnode *f_vnode; /* NULL or applicable vnode */ short f_type; /* descriptor type */ short f_vnread_flags; /* (f) Sleep lock for f_offset */ volatile u_int f_flag; /* see fcntl.h */ volatile u_int f_count; /* reference count */ // ... off_t f_offset; // ... };","title":"File Descriptor Table"},{"location":"kernel/file-descriptor-table/#evolution-of-file-descriptor-table-in-linux-kernel","text":"","title":"Evolution of File Descriptor Table in Linux Kernel"},{"location":"kernel/file-descriptor-table/#001-to-1110","text":"filp is a fixed length array in struct task_struct . // // linux-0.99 // // // include/linux/sched.h // struct task_struct { // ... struct file * filp[NR_OPEN]; fd_set close_on_exec; // ... }; // // include/linux/fs.h // struct file { mode_t f_mode; dev_t f_rdev; off_t f_pos; // each opened file has its own offset unsigned short f_flags; unsigned short f_count; unsigned short f_reada; struct inode * f_inode; struct file_operations * f_op; }; struct inode { dev_t i_dev; unsigned long i_ino; umode_t i_mode; nlink_t i_nlink; uid_t i_uid; gid_t i_gid; dev_t i_rdev; off_t i_size; // each disk file has one size time_t i_atime; time_t i_mtime; time_t i_ctime; unsigned long i_blksize; unsigned long i_blocks; struct inode_operations * i_op; struct super_block * i_sb; // ... }; // // fs/file_table.c // struct file file_table[NR_FILE]; struct file * get_empty_filp(void) { int i; struct file * f = file_table+0; for (i = 0; i++ < NR_FILE; f++) if (!f->f_count) { memset(f,0,sizeof(*f)); f->f_count = 1; return f; } return NULL; } // // fs/inode.c // static struct inode inode_table[NR_INODE]; See https://en.wikipedia.org/wiki/File_descriptor for per-process file descriptor table , system-wide file table and inode table . Relation of three tables: Thie simplest case is one process opens one disk file (e.g. open(\"/var/log/access.log\", O_WRONLY) ), it uses one entry from each table. Then the process does a dup() , the old and new file descriptors may be used interchangeably. Two file descriptors refer to the same open file, and thus share file offset and file status flags. However, the two file descriptors do not share file descriptor flags ( close_on_exec ). Later, the process does a open(\"/var/log/access.log\", O_RDONLY) , a new file descriptor and new file description is created, and pointing to the same inode entry. Therefore, it sees the same file size as the first two fds, but different offset. Sizes of those three tables in early Linux NR_OPEN : How many files can a process open? NR_FILE : How many files can all processes open? NR_INODE : How many disk files can all processes open? Version Date NR_OPEN NR_FILE NR_INODE 0.01 1991-09-17 20 64 32 0.12 1992-01-15 20 64 64 0.95 1992-03-08 20 64 128 0.96a.3 1992-05-22 32 64 128 0.96c.1 1992-07-04 32 128 128 0.97 1992-08-01 32 128 128 0.98.4 1992-11-09 256 128 128 0.99.10 1993-06-07 256 1024 2048 Note 1: file_table and inode_table were made dynamic in 0.99.10. [PATCH] Linux-0.99.10 (June 7, 1993) The \"struct file\" file_table is made dynamic, instaed of a static allocation. For the first time you can have _lots_ of files open. diff --git a/fs/file_table.c b/fs/file_table.c --- a/fs/file_table.c +++ b/fs/file_table.c -struct file file_table[NR_FILE]; +struct file * first_file; +int nr_files = 0; Note 2: ext2 file system was added 0.99.7.","title":"0.01 to 1.1.10"},{"location":"kernel/file-descriptor-table/#1111-to-1321","text":"Split into struct files_struct . 1.1.11 was released in 1995/05. // include/linux/sched.h of linux-1.3.21 struct files_struct { int count; fd_set close_on_exec; struct file * fd[NR_OPEN]; }; struct task_struct { // ... /* filesystem information */ struct fs_struct fs[1]; /* open file information */ struct files_struct files[1]; /* memory management info */ struct mm_struct mm[1]; // ... };","title":"1.1.11 to 1.3.21"},{"location":"kernel/file-descriptor-table/#1322-to-2189","text":"Change files from a struct[1] to a pointer, so it can be shared by threads within a process. 1.3.22 was released in 1995/09. LinuxThreads needs 2.0 kernel, which was released in 1996/07. // include/linux/sched.h of linux-2.0.2 /* Open file table structure */ struct files_struct { int count; fd_set close_on_exec; fd_set open_fds; struct file * fd[NR_OPEN]; }; struct task_struct { // ... /* filesystem information */ - struct fs_struct fs[1]; + struct fs_struct *fs; /* open file information */ - struct files_struct files[1]; + struct files_struct *files; /* memory management info */ - struct mm_struct mm[1]; + struct mm_struct *mm; // ... };","title":"1.3.22 to 2.1.89"},{"location":"kernel/file-descriptor-table/#2190-to-2613","text":"Change fixed-length array fd to dynamic array. 2.2.0 was released in 1999/01. // include/linux/sched.h of linux-2.2.0 /* * Open file table structure */ struct files_struct { atomic_t count; + int max_fds; + struct file ** fd; /* current fd array */ fd_set close_on_exec; // changed to fd_set* in 2.2.12 fd_set open_fds; - struct file * fd[NR_OPEN]; }; struct task_struct { // ... /* open file information */ struct files_struct *files; // ... };","title":"2.1.90 to 2.6.13"},{"location":"kernel/file-descriptor-table/#2614-to-now-4157","text":"Introduce struct fdtable for RCU. 2.6.15 was released in 2006/01, Ubuntu 6.04 LTS and Debian 4 ship it. // include/linux/fdtable.h of linux-2.6.37 struct fdtable { unsigned int max_fds; struct file __rcu **fd; /* current fd array */ fd_set *close_on_exec; fd_set *open_fds; struct rcu_head rcu; struct fdtable *next; }; /* * Open file table structure */ struct files_struct { /* * read mostly part */ atomic_t count; struct fdtable __rcu *fdt; struct fdtable fdtab; /* * written part on a separate cache line in SMP */ spinlock_t file_lock ____cacheline_aligned_in_smp; int next_fd; struct embedded_fd_set close_on_exec_init; struct embedded_fd_set open_fds_init; struct file __rcu * fd_array[NR_OPEN_DEFAULT]; }; struct task_struct { // ... /* open file information */ struct files_struct *files; // ... }; struct file itself. // include/linux/fs.h of linux-4.9 struct file { union { struct llist_node fu_llist; struct rcu_head fu_rcuhead; } f_u; struct path f_path; struct inode *f_inode; /* cached value */ // added back in 3.9, same as f_path.dentry->d_inode const struct file_operations *f_op; /* * Protects f_ep_links, f_flags. * Must not be taken from IRQ context. */ spinlock_t f_lock; atomic_long_t f_count; unsigned int f_flags; fmode_t f_mode; struct mutex f_pos_lock; // Fixed in 3.14 loff_t f_pos; struct fown_struct f_owner; const struct cred *f_cred; struct file_ra_state f_ra; u64 f_version; #ifdef CONFIG_SECURITY void *f_security; #endif /* needed for tty driver, and maybe others */ void *private_data; #ifdef CONFIG_EPOLL /* Used by fs/eventpoll.c to link all the hooks to this file */ struct list_head f_ep_links; struct list_head f_tfile_llink; #endif /* #ifdef CONFIG_EPOLL */ struct address_space *f_mapping; } __attribute__((aligned(4))); /* lest something weird decides that 2 is OK */","title":"2.6.14 to now (4.15.7)"},{"location":"kernel/file-descriptor-table/#freebsd-up-to-93","text":"4.3BSD-Reno and older BSDes use fixed-length array of struct file* . struct user { // ... struct file *u_ofile[NOFILE]; /* file structures for open files */ // ... }; From BSD Net/2 up to FreeBSD 9.3 use a similiar dynamic array data structure of Linux 2.0 (see diagram above.), where proc == task_struct , filedesc == files_struct , file == file . // sys/proc.h /* * Process structure. */ struct proc { // ... struct filedesc *p_fd; /* (b) Open files. */ // ... }; // sys/filedesc.h struct filedesc { struct file **fd_ofiles; /* file structures for open files */ char *fd_ofileflags; /* per-process open file flags */ struct vnode *fd_cdir; /* current directory */ struct vnode *fd_rdir; /* root directory */ struct vnode *fd_jdir; /* jail root directory */ int fd_nfiles; /* number of open files allocated */ NDSLOTTYPE *fd_map; /* bitmap of free fds */ int fd_lastfile; /* high-water mark of fd_ofiles */ int fd_freefile; /* approx. next free file */ u_short fd_cmask; /* mask for file creation */ u_short fd_refcnt; /* thread reference count */ u_short fd_holdcnt; /* hold count on structure + mutex */ struct sx fd_sx; /* protects members of this struct */ struct kqlist fd_kqlist; /* list of kqueues on this filedesc */ int fd_holdleaderscount; /* block fdfree() for shared close() */ int fd_holdleaderswakeup; /* fdfree() needs wakeup */ }; // sys/file.h struct file { void *f_data; /* file descriptor specific data */ struct fileops *f_ops; /* File operations */ struct ucred *f_cred; /* associated credentials. */ struct vnode *f_vnode; /* NULL or applicable vnode */ short f_type; /* descriptor type */ short f_vnread_flags; /* (f) Sleep lock for f_offset */ volatile u_int f_flag; /* see fcntl.h */ volatile u_int f_count; /* reference count */ // ... off_t f_offset; // ... };","title":"FreeBSD up to 9.3"},{"location":"kernel/profiles/","text":"Kernel profiles z420$ lscpu Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian Address sizes: 46 bits physical, 48 bits virtual CPU(s): 8 On-line CPU(s) list: 0-7 Thread(s) per core: 2 Core(s) per socket: 4 Socket(s): 1 NUMA node(s): 1 Vendor ID: GenuineIntel CPU family: 6 Model: 45 Model name: Intel(R) Xeon(R) CPU E5-1620 0 @ 3.60GHz Stepping: 7 CPU MHz: 2393.980 CPU max MHz: 3800.0000 CPU min MHz: 1200.0000 BogoMIPS: 7182.25 Virtualization: VT-x L1d cache: 128 KiB L1i cache: 128 KiB L2 cache: 1 MiB L3 cache: 10 MiB NUMA node0 CPU(s): 0-7 Vulnerability Itlb multihit: KVM: Mitigation: VMX disabled Vulnerability L1tf: Mitigation; PTE Inversion; VMX conditional cache flushes, SMT vulnerable Vulnerability Mds: Vulnerable: Clear CPU buffers attempted, no microcode; SMT vulnerable Vulnerability Meltdown: Mitigation; PTI Vulnerability Spec store bypass: Vulnerable Vulnerability Spectre v1: Mitigation; usercopy/swapgs barriers and __user pointer sanitization Vulnerability Spectre v2: Mitigation; Full generic retpoline, STIBP disabled, RSB filling Vulnerability Srbds: Not affected Vulnerability Tsx async abort: Not affected Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_ tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 cx16 xtpr pdcm pcid d ca sse4_1 sse4_2 x2apic popcnt tsc_deadline_timer aes xsave avx lahf_lm epb pti tpr_shadow vnmi flexpriority ept vpid xsaveopt dtherm ida arat pln pts dd if=/dev/zero of=/dev/null Writing to /dev/null is a no-op, it doesn't even touch the buffer. That is, even if you pass a NULL pointer to write(2) , e.g. write(null_fd, NULL, 1048576) , it won't segfault. // drivers/char/mem.c static ssize_t write_null(struct file *file, const char __user *buf, size_t count, loff_t *ppos) { return count; } profile of sudo perf record -g dd if=/dev/zero of=/dev/null bs=1 count=10M $ sudo perf record -g -o bs1.data dd if=/dev/zero of=/dev/null bs=1 count=10M 10485760+0 records in 10485760+0 records out 10485760 bytes (10 MB, 10 MiB) copied, 5.82431 s, 1.8 MB/s [ perf record: Woken up 9 times to write data ] [ perf record: Captured and wrote 2.153 MB bs1.data (23322 samples) ] ddbs1b10M.pb.gz profile of sudo perf record -g dd if=/dev/zero of=/dev/null bs=128k count=1M $ sudo perf record -g -o bs128k.data dd if=/dev/zero of=/dev/null bs=128k count=1M 1048576+0 records in 1048576+0 records out 137438953472 bytes (137 GB, 128 GiB) copied, 6.35848 s, 21.6 GB/s [ perf record: Woken up 12 times to write data ] [ perf record: Captured and wrote 3.052 MB bs128k.data (25460 samples) ] ddbs128k1M.pb.gz","title":"Profiles"},{"location":"kernel/profiles/#kernel-profiles","text":"z420$ lscpu Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian Address sizes: 46 bits physical, 48 bits virtual CPU(s): 8 On-line CPU(s) list: 0-7 Thread(s) per core: 2 Core(s) per socket: 4 Socket(s): 1 NUMA node(s): 1 Vendor ID: GenuineIntel CPU family: 6 Model: 45 Model name: Intel(R) Xeon(R) CPU E5-1620 0 @ 3.60GHz Stepping: 7 CPU MHz: 2393.980 CPU max MHz: 3800.0000 CPU min MHz: 1200.0000 BogoMIPS: 7182.25 Virtualization: VT-x L1d cache: 128 KiB L1i cache: 128 KiB L2 cache: 1 MiB L3 cache: 10 MiB NUMA node0 CPU(s): 0-7 Vulnerability Itlb multihit: KVM: Mitigation: VMX disabled Vulnerability L1tf: Mitigation; PTE Inversion; VMX conditional cache flushes, SMT vulnerable Vulnerability Mds: Vulnerable: Clear CPU buffers attempted, no microcode; SMT vulnerable Vulnerability Meltdown: Mitigation; PTI Vulnerability Spec store bypass: Vulnerable Vulnerability Spectre v1: Mitigation; usercopy/swapgs barriers and __user pointer sanitization Vulnerability Spectre v2: Mitigation; Full generic retpoline, STIBP disabled, RSB filling Vulnerability Srbds: Not affected Vulnerability Tsx async abort: Not affected Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_ tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 cx16 xtpr pdcm pcid d ca sse4_1 sse4_2 x2apic popcnt tsc_deadline_timer aes xsave avx lahf_lm epb pti tpr_shadow vnmi flexpriority ept vpid xsaveopt dtherm ida arat pln pts","title":"Kernel profiles"},{"location":"kernel/profiles/#dd-ifdevzero-ofdevnull","text":"Writing to /dev/null is a no-op, it doesn't even touch the buffer. That is, even if you pass a NULL pointer to write(2) , e.g. write(null_fd, NULL, 1048576) , it won't segfault. // drivers/char/mem.c static ssize_t write_null(struct file *file, const char __user *buf, size_t count, loff_t *ppos) { return count; } profile of sudo perf record -g dd if=/dev/zero of=/dev/null bs=1 count=10M $ sudo perf record -g -o bs1.data dd if=/dev/zero of=/dev/null bs=1 count=10M 10485760+0 records in 10485760+0 records out 10485760 bytes (10 MB, 10 MiB) copied, 5.82431 s, 1.8 MB/s [ perf record: Woken up 9 times to write data ] [ perf record: Captured and wrote 2.153 MB bs1.data (23322 samples) ] ddbs1b10M.pb.gz profile of sudo perf record -g dd if=/dev/zero of=/dev/null bs=128k count=1M $ sudo perf record -g -o bs128k.data dd if=/dev/zero of=/dev/null bs=128k count=1M 1048576+0 records in 1048576+0 records out 137438953472 bytes (137 GB, 128 GiB) copied, 6.35848 s, 21.6 GB/s [ perf record: Woken up 12 times to write data ] [ perf record: Captured and wrote 3.052 MB bs128k.data (25460 samples) ] ddbs128k1M.pb.gz","title":"dd if=/dev/zero of=/dev/null"},{"location":"kernel/reuseport/","text":"SO_REUSEPORT Linux 4.5 improves UDP SO_REUSEPORT , Linux 4.6 Improves TCP SO_REUSEPORT .","title":"SO_REUSEPRT"},{"location":"kernel/reuseport/#so_reuseport","text":"Linux 4.5 improves UDP SO_REUSEPORT , Linux 4.6 Improves TCP SO_REUSEPORT .","title":"SO_REUSEPORT"},{"location":"kernel/study/","text":"Study Kernel source Build kernel from source for debugging Generally, Linux kernel doesn't compile with -O0 , which is unfortunate for debugging and steping through in GDB. For parts I (Chen Shuo) care mostly, i.e. networking, I manage to compile those parts with -O0 and the rest with -Og , so GDB works much smoother. I created a git repository for my own convenience. It has some tweaks in kernel/configs/study.config to make building and debugging faster. $ cd ~/kernel $ git clone https://github.com/chenshuo/linux-study.git $ cd linux-study $ study/config.sh ... To build: cd ../build-g make -j8 $ cd ../build-g $ make -j24 ... BUILD arch/x86/boot/bzImage Kernel: arch/x86/boot/bzImage is ready Debugging QEMU and virtme Traditionally, you need to build a disk image with root filesystem , but with virtme , it's not needed anymore. Virtme shares host filesystem with guest OS using 9p protocol, so it doesn't interfere with networking stack. $ virtme/virtme-run --kdir ~/kernel/build-g --mods=auto --pwd --qemu-opts -s In another window $ gdb vmlinux (gdb) target remote :1234 0xffffffff818de078 in default_idle () at /home/chenshuo/kernel/linux-study/arch/x86/kernel/process.c:718 718 } (gdb) b sock_alloc (gdb) continue To exit, in QEMU window: Ctrl-A C then quit . ftrace() to show call graph Steven Rostedt - Learning the Linux Kernel with tracing Sample function graph trace for tcp_sendmsg() : 0) | tcp_sendmsg() { 0) | lock_sock_nested() { 0) 2.032 us | } 0) | tcp_sendmsg_locked() { 0) 0.753 us | tcp_rate_check_app_limited(); 0) | tcp_send_mss() { 0) | tcp_current_mss() { 0) 1.826 us | } 0) 0.387 us | tcp_xmit_size_goal(); 0) 2.858 us | } 0) | sk_stream_alloc_skb() { 0) 7.404 us | } 0) | skb_entail() { 0) 2.389 us | } 0) | sk_page_frag_refill() { 0) 6.727 us | } 0) | __sk_mem_schedule() { 0) 1.750 us | } 0) | tcp_push_one() { 0) | tcp_write_xmit() { 0) | tcp_mstamp_refresh() { 0) 0.629 us | } 0) | tcp_tso_segs() { 0) 0.158 us | tcp_tso_autosize(); 0) 0.569 us | } 0) 0.498 us | tcp_pacing_check(); 0) | tcp_init_tso_segs() { 0) 0.166 us | tcp_set_skb_tso_segs(); 0) 0.618 us | } 0) 0.328 us | tcp_snd_wnd_test(); 0) 0.233 us | tcp_mss_split_point(); 0) | tso_fragment(); 0) 0.240 us | tcp_small_queue_check(); 0) | tcp_transmit_skb() { 0) | __tcp_transmit_skb() { 0) | skb_clone() 0) 0.216 us | tcp_established_options(); 0) 0.184 us | skb_push(); 0) | tcp_options_write() 0) | tcp_select_window() 0) 0.167 us | tcp_ecn_send(); 0) 0.148 us | bpf_skops_write_hdr_opt(); 0) | tcp_v6_send_check() 0) | tcp_event_data_sent() 0) | inet6_csk_xmit() { 0) | inet6_csk_route_socket() 0) | ip6_xmit() { 0) 0.173 us | skb_push(); 0) | ip6_dst_hoplimit() 0) 0.188 us | ip6_autoflowlabel(); 0) | ip6_mtu() 0) | ip6_output() { 0) | ip6_finish_output() { 0) | __ip6_finish_output() { 0) | ip6_mtu() 0) | skb_gso_validate_network_len() 0) | ip6_finish_output2() { 0) | neigh_connected_output() { 0) | dev_queue_xmit() { 0) | __dev_queue_xmit() { 0) 0.531 us | qdisc_pkt_len_init(); 0) 0.227 us | netdev_core_pick_tx(); 0) 0.160 us | _raw_spin_lock(); 0) | sch_direct_xmit() { 0) | validate_xmit_skb_list() 0) | dev_hard_start_xmit() { 0) | xmit_one() { 0) 0.197 us | dev_nit_active(); 0) | dev_queue_xmit_nit() 0) | tun_net_xmit() { 0) 0.165 us | tun_automq_xmit(); 0) 0.155 us | check_filter(); 0) 0.421 us | run_ebpf_filter(); 0) | tcp_wfree() { 0) 1.247 us | } 0) 4.366 us | } 0) + 11.675 us | } 0) + 12.107 us | } 0) 0.144 us | _raw_spin_lock(); 0) + 16.900 us | } 0) | __qdisc_run() { 0) 0.255 us | dequeue_skb(); 0) 0.602 us | } 0) 0.160 us | __local_bh_enable_ip(); 0) + 20.803 us | } 0) + 21.102 us | } 0) + 21.831 us | } 0) 0.180 us | __local_bh_enable_ip(); 0) + 22.979 us | } 0) + 25.719 us | } 0) + 26.057 us | } 0) + 26.430 us | } 0) + 29.684 us | } 0) 0.164 us | rcu_read_unlock_strict(); 0) + 35.114 us | } 0) 0.334 us | tcp_update_skb_after_send(); 0) 0.302 us | tcp_rate_skb_sent(); 0) + 44.667 us | } 0) + 45.075 us | } ... Clearly shows the call chain: Transport layer tcp_sendmsg() -> tcp_sendmsg_locked() -> tcp_push_one() -> tcp_write_xmit() -> tcp_transmit_skb() -> __tcp_transmit_skb() Network layer inet6_csk_xmit() -> ip6_xmit() -> ip6_output() -> ip6_finish_output() -> __ip6_finish_output() -> ip6_finish_output2() Device layer neigh_connected_output() -> dev_queue_xmit() -> __dev_queue_xmit() -> sch_direct_xmit() -> dev_hard_start_xmit() -> xmit_one() Driver layer tun_net_xmit() Debug FreeBSD kernel in QEMU on Linux Download FreeBSD VM image FreeBSD-13.2-RELEASE-amd64.qcow2.xz from https://download.freebsd.org/releases/VM-IMAGES/13.2-RELEASE/amd64/Latest/ . Decompress and run FreeBSD VM in QEMU. $ qemu-system-x86_64 -m 12G -hda FreeBSD-13.2-RELEASE-amd64.qcow2 --enable-kvm -machine accel=kvm:tcg \\ -netdev user,id=n0 -device e1000,netdev=n0 -device virtio-net-pci,netdev=n1 -netdev tap,id=n1 -s -cpu host -echr 17 a. enable serial console, so later we can run with -nographic . Edit /boot/loader.conf . b. resize disk to 20G, so we can build custom kernel later. gpart and growfs c. sudo pkg install gmake git screen vim ncdu Build gdb that support FreeBSD kernel. $ sudo apt install libsource-highlight-dev libgmp-dev libncursesw6-dev $ # Download and extract gdb tarball to ~/freebsd13/gdb, then $ ./configure --enable-source-highlight --enable-tui --target=x86_64-portbld-freebsd13.2 Download FreeBSD kernel-dbg.txz and src.txz from https://download.freebsd.org/releases/amd64/13.2-RELEASE/ , and extract them on Linux host. FreeBSD kernel source will be in ~/freebsd13/usr/src/sys/ . Attach gdb to QEMU ~/freebsd13 $ gdb usr/lib/debug/boot/kernel/kernel.debug Reading symbols from ./kernel.debug... (gdb) target remote :1234 Set breakpoints, and step through the code. Build a custom kernel Follow handbook chapter 9 copy src.txz to FreeBSD VM, extract src.txz to root. disable optimization for stepping through, __attribute__((optnone)) for a given function, e.g. tcp_output() . config & build % cd /usr/src/sys/amd64/conf % cp GENERIC MYKERNEL % cd /usr/src/ % sudo make -D NO_CLEAN buildkernel KERNCONF=MYKERNEL % sudo make -D NO_CLEAN installkernel KERNCONF=MYKERNEL copy /usr/lib/debug/boot/kernel/kernel.debug to Linux gdb kernel.debug and attach to QEMU VM running custom kernel. Recent FreeBSD kernel can be cross compiled on Linux host: https://wiki.freebsd.org/BuildingOnNonFreeBSD, but I didn't succeed.","title":"Study"},{"location":"kernel/study/#study-kernel-source","text":"","title":"Study Kernel source"},{"location":"kernel/study/#build-kernel-from-source-for-debugging","text":"Generally, Linux kernel doesn't compile with -O0 , which is unfortunate for debugging and steping through in GDB. For parts I (Chen Shuo) care mostly, i.e. networking, I manage to compile those parts with -O0 and the rest with -Og , so GDB works much smoother. I created a git repository for my own convenience. It has some tweaks in kernel/configs/study.config to make building and debugging faster. $ cd ~/kernel $ git clone https://github.com/chenshuo/linux-study.git $ cd linux-study $ study/config.sh ... To build: cd ../build-g make -j8 $ cd ../build-g $ make -j24 ... BUILD arch/x86/boot/bzImage Kernel: arch/x86/boot/bzImage is ready","title":"Build kernel from source for debugging"},{"location":"kernel/study/#debugging-qemu-and-virtme","text":"Traditionally, you need to build a disk image with root filesystem , but with virtme , it's not needed anymore. Virtme shares host filesystem with guest OS using 9p protocol, so it doesn't interfere with networking stack. $ virtme/virtme-run --kdir ~/kernel/build-g --mods=auto --pwd --qemu-opts -s In another window $ gdb vmlinux (gdb) target remote :1234 0xffffffff818de078 in default_idle () at /home/chenshuo/kernel/linux-study/arch/x86/kernel/process.c:718 718 } (gdb) b sock_alloc (gdb) continue To exit, in QEMU window: Ctrl-A C then quit .","title":"Debugging QEMU and virtme"},{"location":"kernel/study/#ftrace-to-show-call-graph","text":"Steven Rostedt - Learning the Linux Kernel with tracing Sample function graph trace for tcp_sendmsg() : 0) | tcp_sendmsg() { 0) | lock_sock_nested() { 0) 2.032 us | } 0) | tcp_sendmsg_locked() { 0) 0.753 us | tcp_rate_check_app_limited(); 0) | tcp_send_mss() { 0) | tcp_current_mss() { 0) 1.826 us | } 0) 0.387 us | tcp_xmit_size_goal(); 0) 2.858 us | } 0) | sk_stream_alloc_skb() { 0) 7.404 us | } 0) | skb_entail() { 0) 2.389 us | } 0) | sk_page_frag_refill() { 0) 6.727 us | } 0) | __sk_mem_schedule() { 0) 1.750 us | } 0) | tcp_push_one() { 0) | tcp_write_xmit() { 0) | tcp_mstamp_refresh() { 0) 0.629 us | } 0) | tcp_tso_segs() { 0) 0.158 us | tcp_tso_autosize(); 0) 0.569 us | } 0) 0.498 us | tcp_pacing_check(); 0) | tcp_init_tso_segs() { 0) 0.166 us | tcp_set_skb_tso_segs(); 0) 0.618 us | } 0) 0.328 us | tcp_snd_wnd_test(); 0) 0.233 us | tcp_mss_split_point(); 0) | tso_fragment(); 0) 0.240 us | tcp_small_queue_check(); 0) | tcp_transmit_skb() { 0) | __tcp_transmit_skb() { 0) | skb_clone() 0) 0.216 us | tcp_established_options(); 0) 0.184 us | skb_push(); 0) | tcp_options_write() 0) | tcp_select_window() 0) 0.167 us | tcp_ecn_send(); 0) 0.148 us | bpf_skops_write_hdr_opt(); 0) | tcp_v6_send_check() 0) | tcp_event_data_sent() 0) | inet6_csk_xmit() { 0) | inet6_csk_route_socket() 0) | ip6_xmit() { 0) 0.173 us | skb_push(); 0) | ip6_dst_hoplimit() 0) 0.188 us | ip6_autoflowlabel(); 0) | ip6_mtu() 0) | ip6_output() { 0) | ip6_finish_output() { 0) | __ip6_finish_output() { 0) | ip6_mtu() 0) | skb_gso_validate_network_len() 0) | ip6_finish_output2() { 0) | neigh_connected_output() { 0) | dev_queue_xmit() { 0) | __dev_queue_xmit() { 0) 0.531 us | qdisc_pkt_len_init(); 0) 0.227 us | netdev_core_pick_tx(); 0) 0.160 us | _raw_spin_lock(); 0) | sch_direct_xmit() { 0) | validate_xmit_skb_list() 0) | dev_hard_start_xmit() { 0) | xmit_one() { 0) 0.197 us | dev_nit_active(); 0) | dev_queue_xmit_nit() 0) | tun_net_xmit() { 0) 0.165 us | tun_automq_xmit(); 0) 0.155 us | check_filter(); 0) 0.421 us | run_ebpf_filter(); 0) | tcp_wfree() { 0) 1.247 us | } 0) 4.366 us | } 0) + 11.675 us | } 0) + 12.107 us | } 0) 0.144 us | _raw_spin_lock(); 0) + 16.900 us | } 0) | __qdisc_run() { 0) 0.255 us | dequeue_skb(); 0) 0.602 us | } 0) 0.160 us | __local_bh_enable_ip(); 0) + 20.803 us | } 0) + 21.102 us | } 0) + 21.831 us | } 0) 0.180 us | __local_bh_enable_ip(); 0) + 22.979 us | } 0) + 25.719 us | } 0) + 26.057 us | } 0) + 26.430 us | } 0) + 29.684 us | } 0) 0.164 us | rcu_read_unlock_strict(); 0) + 35.114 us | } 0) 0.334 us | tcp_update_skb_after_send(); 0) 0.302 us | tcp_rate_skb_sent(); 0) + 44.667 us | } 0) + 45.075 us | } ... Clearly shows the call chain: Transport layer tcp_sendmsg() -> tcp_sendmsg_locked() -> tcp_push_one() -> tcp_write_xmit() -> tcp_transmit_skb() -> __tcp_transmit_skb() Network layer inet6_csk_xmit() -> ip6_xmit() -> ip6_output() -> ip6_finish_output() -> __ip6_finish_output() -> ip6_finish_output2() Device layer neigh_connected_output() -> dev_queue_xmit() -> __dev_queue_xmit() -> sch_direct_xmit() -> dev_hard_start_xmit() -> xmit_one() Driver layer tun_net_xmit()","title":"ftrace() to show call graph"},{"location":"kernel/study/#debug-freebsd-kernel-in-qemu-on-linux","text":"Download FreeBSD VM image FreeBSD-13.2-RELEASE-amd64.qcow2.xz from https://download.freebsd.org/releases/VM-IMAGES/13.2-RELEASE/amd64/Latest/ . Decompress and run FreeBSD VM in QEMU. $ qemu-system-x86_64 -m 12G -hda FreeBSD-13.2-RELEASE-amd64.qcow2 --enable-kvm -machine accel=kvm:tcg \\ -netdev user,id=n0 -device e1000,netdev=n0 -device virtio-net-pci,netdev=n1 -netdev tap,id=n1 -s -cpu host -echr 17 a. enable serial console, so later we can run with -nographic . Edit /boot/loader.conf . b. resize disk to 20G, so we can build custom kernel later. gpart and growfs c. sudo pkg install gmake git screen vim ncdu Build gdb that support FreeBSD kernel. $ sudo apt install libsource-highlight-dev libgmp-dev libncursesw6-dev $ # Download and extract gdb tarball to ~/freebsd13/gdb, then $ ./configure --enable-source-highlight --enable-tui --target=x86_64-portbld-freebsd13.2 Download FreeBSD kernel-dbg.txz and src.txz from https://download.freebsd.org/releases/amd64/13.2-RELEASE/ , and extract them on Linux host. FreeBSD kernel source will be in ~/freebsd13/usr/src/sys/ . Attach gdb to QEMU ~/freebsd13 $ gdb usr/lib/debug/boot/kernel/kernel.debug Reading symbols from ./kernel.debug... (gdb) target remote :1234 Set breakpoints, and step through the code.","title":"Debug FreeBSD kernel in QEMU on Linux"},{"location":"kernel/study/#build-a-custom-kernel","text":"Follow handbook chapter 9 copy src.txz to FreeBSD VM, extract src.txz to root. disable optimization for stepping through, __attribute__((optnone)) for a given function, e.g. tcp_output() . config & build % cd /usr/src/sys/amd64/conf % cp GENERIC MYKERNEL % cd /usr/src/ % sudo make -D NO_CLEAN buildkernel KERNCONF=MYKERNEL % sudo make -D NO_CLEAN installkernel KERNCONF=MYKERNEL copy /usr/lib/debug/boot/kernel/kernel.debug to Linux gdb kernel.debug and attach to QEMU VM running custom kernel. Recent FreeBSD kernel can be cross compiled on Linux host: https://wiki.freebsd.org/BuildingOnNonFreeBSD, but I didn't succeed.","title":"Build a custom kernel"}]}