{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Shuo Chen's notes on various topics","title":"Home"},{"location":"#shuo-chens-notes-on-various-topics","text":"","title":"Shuo Chen's notes on various topics"},{"location":"bugs/","text":"Interesting bugs in open source projects GCC Bug 54812 : private =default destructor is public Delete expression doesn't respect access of defaulted destructor struct Base { private: ~Base() = default; }; int main() { Base* p = new Base; delete p; } Quote: The bug affects protected destructors too, and they're commonly used for base classes to prevent deletion via pointer-to-base. Fixed in 4.9.0, by r203985 . Test case added by r204057 . Glibc strstr(3) Since glibc 2.9, strstr(3) may use Two Way algorithm in some cases, but the impl. had several bugs: Bug 12092 Bug 12100 Bug 14602 More? getpid(2) no longer caches PID Since glibc 2.25 , getpid(2) no longer caches PID, released on 2017-02-05. Ubuntu 18.04, Debian 10 and CentOS 8 contain this change. Quote from man 2 getpid : From glibc version 2.3.4 up to and including version 2.24, the glibc wrapper function for getpid() cached PIDs, with the goal of avoiding additional system calls when a process calls getpid() repeatedly. ... Because of the aforementioned problems, since glibc version 2.25, the PID cache is removed: calls to getpid() always invoke the actual system call, rather than returning a cached value. Kernel write(2) not thread-safe Fixed in v3.14, released in 2014-03-30. Ubuntu 14.04 has this bug, Debian 8 doesn't. commit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4 Author: Linus Torvalds <torvalds@linux-foundation.org> Date: Mon Mar 3 09:36:58 2014 -0800 vfs: atomic f_pos accesses as per POSIX Our write() system call has always been atomic in the sense that you get the expected thread-safe contiguous write, but we haven't actually guaranteed that concurrent writes are serialized wrt f_pos accesses, so threads (or processes) that share a file descriptor and use \"write()\" concurrently would quite likely overwrite each others data. This violates POSIX.1-2008/SUSv4 Section XSI 2.9.7 that says: \"2.9.7 Thread Interactions with Regular File Operations All of the following functions shall be atomic with respect to each other in the effects specified in POSIX.1-2008 when they operate on regular files or symbolic links: [...]\" and one of the effects is the file position update. This unprotected file position behavior is not new behavior, and nobody has ever cared. Until now. Yongzhi Pan reported unexpected behavior to Michael Kerrisk that was due to this. This resolves the issue with a f_pos-specific lock that is taken by read/write/lseek on file descriptors that may be shared across threads or processes. Reported-by: Yongzhi Pan <panyongzhi@gmail.com> Reported-by: Michael Kerrisk <mtk.manpages@gmail.com> Cc: Al Viro <viro@zeniv.linux.org.uk> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org> Signed-off-by: Al Viro <viro@zeniv.linux.org.uk> $ man 2 write BUGS According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 (\"Thread Interactions with Regular File Operations\"): All of the following functions shall be atomic with respect to each other in the effects specified in POSIX.1-2008 when they operate on regular files or symbolic links: ... Among the APIs subsequently listed are write() and writev(2). And among the effects that should be atomic across threads (and processes) are updates of the file offset. However, on Linux before version 3.14, this was not the case: if two processes that share an open file description (see open(2)) perform a write() (or writev(2)) at the same time, then the I/O operations were not atomic with respect updating the file offset, with the result that the blocks of data output by the two processes might (incorrectly) overlap. This problem was fixed in Linux 3.14. Java \"+=\" applied to String operands can provoke side effects Introduced in JDK9, fixed in JDK10 but not JDK9. Why does array[idx++]+=\u201ca\u201d increase idx once in Java 8 but twice in Java 9 and 10?","title":"Bugs"},{"location":"bugs/#interesting-bugs-in-open-source-projects","text":"","title":"Interesting bugs in open source projects"},{"location":"bugs/#gcc","text":"","title":"GCC"},{"location":"bugs/#bug-54812-private-default-destructor-is-public","text":"Delete expression doesn't respect access of defaulted destructor struct Base { private: ~Base() = default; }; int main() { Base* p = new Base; delete p; } Quote: The bug affects protected destructors too, and they're commonly used for base classes to prevent deletion via pointer-to-base. Fixed in 4.9.0, by r203985 . Test case added by r204057 .","title":"Bug 54812: private =default destructor is public"},{"location":"bugs/#glibc","text":"","title":"Glibc"},{"location":"bugs/#strstr3","text":"Since glibc 2.9, strstr(3) may use Two Way algorithm in some cases, but the impl. had several bugs: Bug 12092 Bug 12100 Bug 14602 More?","title":"strstr(3)"},{"location":"bugs/#getpid2-no-longer-caches-pid","text":"Since glibc 2.25 , getpid(2) no longer caches PID, released on 2017-02-05. Ubuntu 18.04, Debian 10 and CentOS 8 contain this change. Quote from man 2 getpid : From glibc version 2.3.4 up to and including version 2.24, the glibc wrapper function for getpid() cached PIDs, with the goal of avoiding additional system calls when a process calls getpid() repeatedly. ... Because of the aforementioned problems, since glibc version 2.25, the PID cache is removed: calls to getpid() always invoke the actual system call, rather than returning a cached value.","title":"getpid(2) no longer caches PID"},{"location":"bugs/#kernel","text":"","title":"Kernel"},{"location":"bugs/#write2-not-thread-safe","text":"Fixed in v3.14, released in 2014-03-30. Ubuntu 14.04 has this bug, Debian 8 doesn't. commit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4 Author: Linus Torvalds <torvalds@linux-foundation.org> Date: Mon Mar 3 09:36:58 2014 -0800 vfs: atomic f_pos accesses as per POSIX Our write() system call has always been atomic in the sense that you get the expected thread-safe contiguous write, but we haven't actually guaranteed that concurrent writes are serialized wrt f_pos accesses, so threads (or processes) that share a file descriptor and use \"write()\" concurrently would quite likely overwrite each others data. This violates POSIX.1-2008/SUSv4 Section XSI 2.9.7 that says: \"2.9.7 Thread Interactions with Regular File Operations All of the following functions shall be atomic with respect to each other in the effects specified in POSIX.1-2008 when they operate on regular files or symbolic links: [...]\" and one of the effects is the file position update. This unprotected file position behavior is not new behavior, and nobody has ever cared. Until now. Yongzhi Pan reported unexpected behavior to Michael Kerrisk that was due to this. This resolves the issue with a f_pos-specific lock that is taken by read/write/lseek on file descriptors that may be shared across threads or processes. Reported-by: Yongzhi Pan <panyongzhi@gmail.com> Reported-by: Michael Kerrisk <mtk.manpages@gmail.com> Cc: Al Viro <viro@zeniv.linux.org.uk> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org> Signed-off-by: Al Viro <viro@zeniv.linux.org.uk> $ man 2 write BUGS According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 (\"Thread Interactions with Regular File Operations\"): All of the following functions shall be atomic with respect to each other in the effects specified in POSIX.1-2008 when they operate on regular files or symbolic links: ... Among the APIs subsequently listed are write() and writev(2). And among the effects that should be atomic across threads (and processes) are updates of the file offset. However, on Linux before version 3.14, this was not the case: if two processes that share an open file description (see open(2)) perform a write() (or writev(2)) at the same time, then the I/O operations were not atomic with respect updating the file offset, with the result that the blocks of data output by the two processes might (incorrectly) overlap. This problem was fixed in Linux 3.14.","title":"write(2) not thread-safe"},{"location":"bugs/#java","text":"","title":"Java"},{"location":"bugs/#applied-to-string-operands-can-provoke-side-effects","text":"Introduced in JDK9, fixed in JDK10 but not JDK9. Why does array[idx++]+=\u201ca\u201d increase idx once in Java 8 but twice in Java 9 and 10?","title":"\"+=\" applied to String operands can provoke side effects"},{"location":"dsp/","text":"Digital Signal Processing DFT/FFT DFT is a matrix multiplication, the naive implementation is O(N^2) . FFT is a much faster multiplication in O(N \\log N) , which makes it practical. X_k = \\sum_{n=0}^{N-1} x_n e^{-j 2 \\pi k n / N} Your browser does not support the video element. Wikipedia Wikibooks DFT matrix Smith's Guide to DSP, ch.8 by Steven W. Smith Mathematics of the Discrete Fourier Transform by Julius O. Smith The Discrete Fourier Transform by Ivan W. Selenick and Gerald Schuller. From chapter 2 of The Transform and Data Compression Handbook ed. by Kamisetty Ramam Rao and Patrick C. Yip The Discrete Fourier Transform by prof. Jeffrey A. Fessler from EECS 451, Digital Signal Processing and Analysis The Discrete Fourier Transform by prof. Stephen Roberts from Signal Processing & Filter Design Digital Sinusoid Generators DTMF Tone Generation and Detection by Gunter Schmer Second-order digital resonator in Python: fs = 8000 # sampling frequency fo = 700 # output frequency A = 1.0 # amplitude w = 2*pi*fo/fs # angular frequency of fo c = 2.0 * cos(w) # coefficient, controls the frequency, 1.70528 x = -A * sin(w) # initial value, controls the amplitude and phase, -0.522498 y = 0.0 for ever: emit(x) x, y = c*x - y, x First 100 data points: N = 4096 f = fft(signal[:N]) p = np.argmax(abs(f)[:N//2]) print(p*fs/N) => 699.21895 Hz FFT: Digital Waveguide Oscillator by Julius O. Smith Effect Design Part 3 Oscillators: Sinusoidal and Pseudonoise by Jon Dattorro A sine generation algorithm for VLSI applications by John W. Gordon and Julius O. Smith The Second-Order Digital Waveguide Oscillator by Julius O. Smith and Perry R. Cook AN-263 Sine Wave Generation Techniques 5 ways to generate a sine wave","title":"DSP"},{"location":"dsp/#digital-signal-processing","text":"","title":"Digital Signal Processing"},{"location":"dsp/#dftfft","text":"DFT is a matrix multiplication, the naive implementation is O(N^2) . FFT is a much faster multiplication in O(N \\log N) , which makes it practical. X_k = \\sum_{n=0}^{N-1} x_n e^{-j 2 \\pi k n / N} Your browser does not support the video element. Wikipedia Wikibooks DFT matrix Smith's Guide to DSP, ch.8 by Steven W. Smith Mathematics of the Discrete Fourier Transform by Julius O. Smith The Discrete Fourier Transform by Ivan W. Selenick and Gerald Schuller. From chapter 2 of The Transform and Data Compression Handbook ed. by Kamisetty Ramam Rao and Patrick C. Yip The Discrete Fourier Transform by prof. Jeffrey A. Fessler from EECS 451, Digital Signal Processing and Analysis The Discrete Fourier Transform by prof. Stephen Roberts from Signal Processing & Filter Design","title":"DFT/FFT"},{"location":"dsp/#digital-sinusoid-generators","text":"DTMF Tone Generation and Detection by Gunter Schmer Second-order digital resonator in Python: fs = 8000 # sampling frequency fo = 700 # output frequency A = 1.0 # amplitude w = 2*pi*fo/fs # angular frequency of fo c = 2.0 * cos(w) # coefficient, controls the frequency, 1.70528 x = -A * sin(w) # initial value, controls the amplitude and phase, -0.522498 y = 0.0 for ever: emit(x) x, y = c*x - y, x First 100 data points: N = 4096 f = fft(signal[:N]) p = np.argmax(abs(f)[:N//2]) print(p*fs/N) => 699.21895 Hz FFT: Digital Waveguide Oscillator by Julius O. Smith Effect Design Part 3 Oscillators: Sinusoidal and Pseudonoise by Jon Dattorro A sine generation algorithm for VLSI applications by John W. Gordon and Julius O. Smith The Second-Order Digital Waveguide Oscillator by Julius O. Smith and Perry R. Cook AN-263 Sine Wave Generation Techniques 5 ways to generate a sine wave","title":"Digital Sinusoid Generators"},{"location":"git/","text":"Git data model Essentially, Git is a content-addressable filesystem , Linus's one page explanation , correction: the SHA1 hash is NOT the hash of the compressed object. Git from the Bottom Up by John Wiegley, discuss . blob is content of file $ git cat-file -p 74576250e3c3a901bf06832bd0e4ee5e00422115 # Shuo's notes http://chenshuo.github.io/notes tree has one or more tree / blob , it's Merkle tree . blob are leaf nodes tree are internal nodes $ git cat-file -p 5d42664e3d812288b47795718d0e4faf26397bf9 100644 blob cde88fe0e10f265ed3cb2af0ea5422f607c1a37c .gitignore 100644 blob 74576250e3c3a901bf06832bd0e4ee5e00422115 README.md 040000 tree eabff4ee0b30f5d6a644ce508ba7fe47dc563aa4 docs 100644 blob 020682e2399c75cf3ad9636964c7501f27a0e893 mkdocs.yml commit : has one tree has one or more parent commit (s) $ git cat-file -p 3f08891b366c750d4739241874cfb1dbef56c398 tree 5d42664e3d812288b47795718d0e4faf26397bf9 parent 955f683cae5d2514d1c788fce9206451e2ac3334 author Shuo Chen <chenshuo@chenshuo.com> 1484903215 -0800 committer Shuo Chen <chenshuo@chenshuo.com> 1484903215 -0800 update ssl.md tag ??? Exceptions: initial commit has no parent empty file is empty blob empty directory is empty tree Pack file format Delta Pack index format","title":"Git"},{"location":"git/#git-data-model","text":"Essentially, Git is a content-addressable filesystem , Linus's one page explanation , correction: the SHA1 hash is NOT the hash of the compressed object. Git from the Bottom Up by John Wiegley, discuss . blob is content of file $ git cat-file -p 74576250e3c3a901bf06832bd0e4ee5e00422115 # Shuo's notes http://chenshuo.github.io/notes tree has one or more tree / blob , it's Merkle tree . blob are leaf nodes tree are internal nodes $ git cat-file -p 5d42664e3d812288b47795718d0e4faf26397bf9 100644 blob cde88fe0e10f265ed3cb2af0ea5422f607c1a37c .gitignore 100644 blob 74576250e3c3a901bf06832bd0e4ee5e00422115 README.md 040000 tree eabff4ee0b30f5d6a644ce508ba7fe47dc563aa4 docs 100644 blob 020682e2399c75cf3ad9636964c7501f27a0e893 mkdocs.yml commit : has one tree has one or more parent commit (s) $ git cat-file -p 3f08891b366c750d4739241874cfb1dbef56c398 tree 5d42664e3d812288b47795718d0e4faf26397bf9 parent 955f683cae5d2514d1c788fce9206451e2ac3334 author Shuo Chen <chenshuo@chenshuo.com> 1484903215 -0800 committer Shuo Chen <chenshuo@chenshuo.com> 1484903215 -0800 update ssl.md tag ??? Exceptions: initial commit has no parent empty file is empty blob empty directory is empty tree","title":"Git data model"},{"location":"git/#pack-file-format","text":"","title":"Pack file format"},{"location":"git/#delta","text":"","title":"Delta"},{"location":"git/#pack-index-format","text":"","title":"Pack index format"},{"location":"lcc/","text":"Notes on LCC Callgraph of parsing expressions Callgraph of parsing statements Calltree of compiling an empty program Calltree of lcc 4.2 for following simple program: int main() { return 0; }","title":"lcc"},{"location":"lcc/#notes-on-lcc","text":"","title":"Notes on LCC"},{"location":"lcc/#callgraph-of-parsing-expressions","text":"","title":"Callgraph of parsing expressions"},{"location":"lcc/#callgraph-of-parsing-statements","text":"","title":"Callgraph of parsing statements"},{"location":"lcc/#calltree-of-compiling-an-empty-program","text":"Calltree of lcc 4.2 for following simple program: int main() { return 0; }","title":"Calltree of compiling an empty program"},{"location":"links/","text":"Links 42 Years of Microprocessor Trend Data by Karl Rupp The Architecture of Open Source Applications Volumn I and II The Performance of Open Source Applications 500 Lines or Less System programming Excuse me son, but your code is leaking !!! on Dan Walsh's Blog, about FD_CLOEXEC and O_CLOEXEC Secure File Descriptor Handling by Ulrich Drepper, about O_CLOEXEC , O_NONBLOCK . Time-keeping Leap Smear for applying leap seconds smoothly. Maths Theory and Applications of Markov Chains to Finance by Kevin Atteson Reed-Solomon by James S. Plank, also tutorials and SPE97","title":"Links"},{"location":"links/#links","text":"42 Years of Microprocessor Trend Data by Karl Rupp The Architecture of Open Source Applications Volumn I and II The Performance of Open Source Applications 500 Lines or Less","title":"Links"},{"location":"links/#system-programming","text":"Excuse me son, but your code is leaking !!! on Dan Walsh's Blog, about FD_CLOEXEC and O_CLOEXEC Secure File Descriptor Handling by Ulrich Drepper, about O_CLOEXEC , O_NONBLOCK .","title":"System programming"},{"location":"links/#time-keeping","text":"Leap Smear for applying leap seconds smoothly.","title":"Time-keeping"},{"location":"links/#maths","text":"Theory and Applications of Markov Chains to Finance by Kevin Atteson Reed-Solomon by James S. Plank, also tutorials and SPE97","title":"Maths"},{"location":"lua/","text":"Notes on Lua implementation Parser Lua uses a recursive descent parser, which generates code on-the-fly, similar to PL/0. Callgraph: Calltree Calltree of Lua 5.3 for following simple program: #include \"lua.hpp\" int main() { lua_State *L = luaL_newstate(); luaL_openlibs(L); // open standard libraries luaL_loadstring(L, R\"( x = 10 * 5 print(x) )\"); lua_pcall(L, 0, LUA_MULTRET, 0); lua_close(L); } Releases","title":"Lua"},{"location":"lua/#notes-on-lua-implementation","text":"","title":"Notes on Lua implementation"},{"location":"lua/#parser","text":"Lua uses a recursive descent parser, which generates code on-the-fly, similar to PL/0. Callgraph:","title":"Parser"},{"location":"lua/#calltree","text":"Calltree of Lua 5.3 for following simple program: #include \"lua.hpp\" int main() { lua_State *L = luaL_newstate(); luaL_openlibs(L); // open standard libraries luaL_loadstring(L, R\"( x = 10 * 5 print(x) )\"); lua_pcall(L, 0, LUA_MULTRET, 0); lua_close(L); }","title":"Calltree"},{"location":"lua/#releases","text":"","title":"Releases"},{"location":"mem/","text":"Notes on C/C++ memory model Threads and memory model for C++ by Hans Boehm GCC 4.7 and above does the right thing! The C11 and C++11 Concurrency Model by Mark John Batty C/C++11 mappings to processors by Alexander Terekhov, Paul McKenney, et al. Awesome Lock-Free","title":"Memory Model"},{"location":"mem/#notes-on-cc-memory-model","text":"Threads and memory model for C++ by Hans Boehm GCC 4.7 and above does the right thing! The C11 and C++11 Concurrency Model by Mark John Batty C/C++11 mappings to processors by Alexander Terekhov, Paul McKenney, et al. Awesome Lock-Free","title":"Notes on C/C++ memory model"},{"location":"ssl/","text":"Notes on SSL/TLS ChaCha20, Poly1305, X25519 RFC7539 defines ChaCha20 and Poly1305 RFC7905 adds TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (0xCCA8) etc to TLS 1.2 There is an old version of ECDHE_RSA_CHACHA20_POLY1305_OLD (0xCC13) exists in draft and OpenSSL code . OpenSSL will prefer AES if hardware supports it, otherwise prefer ChaCha20 over AES, in ssl_create_cipher_list() . Go 1.8 will support TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 commit 67d8226b48 commit 67d8226b4862f0f8deb4dc6fa8617017ecb0f32b Author: Adam Langley <agl@golang.org> Date: Wed Oct 12 10:46:43 2016 -0700 crypto/tls: support ChaCha20-Poly1305. This change adds support for the ChaCha20-Poly1305 AEAD to crypto/tls, as specified in https://tools.ietf.org/html/rfc7905. Fixes #15499. Change-Id: Iaa689be90e03f208c40b574eca399e56f3c7ecf1 Reviewed-on: https://go-review.googlesource.com/30957 Run-TryBot: Adam Langley <agl@golang.org> TryBot-Result: Gobot Gobot <gobot@golang.org> Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org> Go perfers X25519 over P-256, P-384 and P-521. commit 9e98e7e668 commit 9e98e7e6686a500f87352e3721038d194b1db33c Author: Adam Langley <agl@golang.org> Date: Tue Oct 11 15:08:35 2016 -0700 crypto/tls: enable X25519 by default. Since this changes the offered curves in the ClientHello, all the test data needs to be updated too. Change-Id: I227934711104349c0f0eab11d854e5a2adcbc363 Reviewed-on: https://go-review.googlesource.com/30825 Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org> API changes OpenSSL 1.0.2 has an undocumented SSL_get_server_tmp_key() function to get the curve used in handshaking, this is for openssl s_client command. http://crypto.stackexchange.com/questions/11310/with-openssl-and-ecdhe-how-to-show-the-actual-curve-being-used OpenSSL 1.0.1 only allows setting one curve with SSL_CTX_set_tmp_ecdh() (or use callbacks), OpenSSL 1.0.2 allows setting curve list with SSL_CTX_set1_curves() and SSL_CTX_set1_curves_list() OpenSSL 1.0.2 adds SSL_CTX_set_ecdh_auto() , but OpenSSL 1.1.0 makes it a no-op. OpenSSL 1.1.0 provides SSL_SESSION_get_master_key() function. Go 1.8 supports KeyLogWriter commit 320bd562cb commit 320bd562cbb24a01beb02706c42d06a290160645 Author: Joonas Kuorilehto <joneskoo@derbian.fi> Date: Sat Aug 20 14:41:42 2016 +0300 crypto/tls: add KeyLogWriter for debugging Add support for writing TLS client random and master secret in NSS key log format. https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format Normally this is enabled by a developer debugging TLS based applications, especially HTTP/2, by setting the KeyLogWriter to an open file. The keys negotiated in handshake are then logged and can be used to decrypt TLS sessions e.g. in Wireshark. Applications may choose to add support similar to NSS where this is enabled by environment variable, but no such mechanism is built in to Go. Instead each application must explicitly enable. Fixes #13057. Change-Id: If6edd2d58999903e8390b1674ba4257ecc747ae1 Reviewed-on: https://go-review.googlesource.com/27434 Run-TryBot: Brad Fitzpatrick <bradfitz@golang.org> TryBot-Result: Gobot Gobot <gobot@golang.org> Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org> Memory footprint Before OpenSSL 1.1.0, there is a free-list (~32k per SSL) unless disable with OPENSSL_NO_BUF_FREELISTS or set SSL_MODE_RELEASE_BUFFERS, the free list is freed in SSL_CTX_free() not SSL_free() . commit 63c574f6a6 in OpenSSL: commit 63c574f6a639cfa3f53476080054526e6bfa3bc9 Author: Rich Salz <rsalz@openssl.org> Date: Tue Jan 27 16:43:53 2015 -0500 OPENSSL_NO_XXX cleanup: OPENSSL_NO_BUF_FREELISTS Remove OPENSSL_NO_BUF_FREELISTS. This was turned on by default, so the work here is removing the 'maintain our own freelist' code. Also removed a minor old Windows-multibyte/widechar conversion flag. commit 72e56bc494 in LibreSSL: commit 72e56bc4947e53cec535f2fc84e00a3c278edf29 Author: tedu <> Date: Wed Apr 16 21:16:33 2014 +0000 TANSTAAFL - delete the buf freelist code. if you need a better malloc, get a better malloc. ok beck deraadt diff --git a/src/lib/libssl/s3_both.c b/src/lib/libssl/s3_both.c TANSTAAFL - There ain't no such thing as a free lunch commit 983f6bdb58 in BoringSSL: commit 983f6bdb5888d7074d7ee67d5e3741bcf1027108 Author: Alex Chernyakhovsky <achernya@google.com> Date: Sun Aug 3 15:48:35 2014 -0400 Set OPENSSL_NO_BUF_FREELISTS The memory freelist maintained by OpenSSL claims to be a performance optimization for platforms that have a slow malloc/free implementation. This should not be the case on modern linux/glibc. Remove the freelist as it poses a potential security hazard of buffer-reuse that is of \"initialized\" memory that will not be caught be tools such as valgrind. Change-Id: I3cfa6a05f9bdfbbba7820060bae5a673dee43014 Reviewed-on: https://boringssl-review.googlesource.com/1385 Reviewed-by: Adam Langley <agl@google.com> After commit b8d28cf532 BoringSSL calls ssl_write_buffer_flush() and ssl_write_buffer_clear() for each SSL_write() , so its memory footprint is much smaller than other SSL libraries (~32k) when no data is pending. Performance notes The P-256 curve, also known as prime256v1 or secp256r1 is widely used in ECDHE_RSA key exchange. For x86-64, there is a faster implementation, enabled by ./config enable-ec_nistp_64_gcc_128 . Futher speed up of P-256 in OpenSSL 1.1.0 and BoringSSL: commit 4d3fa06fce for OpenSSL 1.1.0 commit 3842a64d36 backports to 1.0.2 branch commit 1895493868 for BoringSSL commit 18954938684e269ccd59152027d2244040e2b819 Author: Adam Langley <agl@google.com> Date: Tue Nov 3 14:02:04 2015 -0800 Add Intel's P-256 This change incorporates Intel's P-256 implementation. The record of Intel's submission under CLA is in internal bug number 25330687. Before: Did 3582 ECDH P-256 operations in 1049114us (3414.3 ops/sec) Did 8525 ECDSA P-256 signing operations in 1028778us (8286.5 ops/sec) Did 3487 ECDSA P-256 verify operations in 1008996us (3455.9 ops/sec) build/tool/bssl is 1434704 bytes after strip -s After: Did 8618 ECDH P-256 operations in 1027884us (8384.2 ops/sec) Did 21000 ECDSA P-256 signing operations in 1049490us (20009.7 ops/sec) Did 8268 ECDSA P-256 verify operations in 1079481us (7659.2 ops/sec) build/tool/bssl is 1567216 bytes after strip -s Change-Id: I147971a8e19849779c8ed7e20310d41bd4962299 Reviewed-on: https://boringssl-review.googlesource.com/6371 Reviewed-by: Adam Langley <agl@google.com> None of them are available in LibreSSL as of Jan 19, 2017. Issue 259 . Cryptography cs387 Applied Cryptography on udacity Elliptic Curve Cryptography: ECDH and ECDSA Everything you need to know about cryptography in 1 hour","title":"SSL"},{"location":"ssl/#notes-on-ssltls","text":"","title":"Notes on SSL/TLS"},{"location":"ssl/#chacha20-poly1305-x25519","text":"RFC7539 defines ChaCha20 and Poly1305 RFC7905 adds TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (0xCCA8) etc to TLS 1.2 There is an old version of ECDHE_RSA_CHACHA20_POLY1305_OLD (0xCC13) exists in draft and OpenSSL code . OpenSSL will prefer AES if hardware supports it, otherwise prefer ChaCha20 over AES, in ssl_create_cipher_list() . Go 1.8 will support TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 commit 67d8226b48 commit 67d8226b4862f0f8deb4dc6fa8617017ecb0f32b Author: Adam Langley <agl@golang.org> Date: Wed Oct 12 10:46:43 2016 -0700 crypto/tls: support ChaCha20-Poly1305. This change adds support for the ChaCha20-Poly1305 AEAD to crypto/tls, as specified in https://tools.ietf.org/html/rfc7905. Fixes #15499. Change-Id: Iaa689be90e03f208c40b574eca399e56f3c7ecf1 Reviewed-on: https://go-review.googlesource.com/30957 Run-TryBot: Adam Langley <agl@golang.org> TryBot-Result: Gobot Gobot <gobot@golang.org> Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org> Go perfers X25519 over P-256, P-384 and P-521. commit 9e98e7e668 commit 9e98e7e6686a500f87352e3721038d194b1db33c Author: Adam Langley <agl@golang.org> Date: Tue Oct 11 15:08:35 2016 -0700 crypto/tls: enable X25519 by default. Since this changes the offered curves in the ClientHello, all the test data needs to be updated too. Change-Id: I227934711104349c0f0eab11d854e5a2adcbc363 Reviewed-on: https://go-review.googlesource.com/30825 Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org>","title":"ChaCha20, Poly1305, X25519"},{"location":"ssl/#api-changes","text":"OpenSSL 1.0.2 has an undocumented SSL_get_server_tmp_key() function to get the curve used in handshaking, this is for openssl s_client command. http://crypto.stackexchange.com/questions/11310/with-openssl-and-ecdhe-how-to-show-the-actual-curve-being-used OpenSSL 1.0.1 only allows setting one curve with SSL_CTX_set_tmp_ecdh() (or use callbacks), OpenSSL 1.0.2 allows setting curve list with SSL_CTX_set1_curves() and SSL_CTX_set1_curves_list() OpenSSL 1.0.2 adds SSL_CTX_set_ecdh_auto() , but OpenSSL 1.1.0 makes it a no-op. OpenSSL 1.1.0 provides SSL_SESSION_get_master_key() function. Go 1.8 supports KeyLogWriter commit 320bd562cb commit 320bd562cbb24a01beb02706c42d06a290160645 Author: Joonas Kuorilehto <joneskoo@derbian.fi> Date: Sat Aug 20 14:41:42 2016 +0300 crypto/tls: add KeyLogWriter for debugging Add support for writing TLS client random and master secret in NSS key log format. https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format Normally this is enabled by a developer debugging TLS based applications, especially HTTP/2, by setting the KeyLogWriter to an open file. The keys negotiated in handshake are then logged and can be used to decrypt TLS sessions e.g. in Wireshark. Applications may choose to add support similar to NSS where this is enabled by environment variable, but no such mechanism is built in to Go. Instead each application must explicitly enable. Fixes #13057. Change-Id: If6edd2d58999903e8390b1674ba4257ecc747ae1 Reviewed-on: https://go-review.googlesource.com/27434 Run-TryBot: Brad Fitzpatrick <bradfitz@golang.org> TryBot-Result: Gobot Gobot <gobot@golang.org> Reviewed-by: Brad Fitzpatrick <bradfitz@golang.org>","title":"API changes"},{"location":"ssl/#memory-footprint","text":"Before OpenSSL 1.1.0, there is a free-list (~32k per SSL) unless disable with OPENSSL_NO_BUF_FREELISTS or set SSL_MODE_RELEASE_BUFFERS, the free list is freed in SSL_CTX_free() not SSL_free() . commit 63c574f6a6 in OpenSSL: commit 63c574f6a639cfa3f53476080054526e6bfa3bc9 Author: Rich Salz <rsalz@openssl.org> Date: Tue Jan 27 16:43:53 2015 -0500 OPENSSL_NO_XXX cleanup: OPENSSL_NO_BUF_FREELISTS Remove OPENSSL_NO_BUF_FREELISTS. This was turned on by default, so the work here is removing the 'maintain our own freelist' code. Also removed a minor old Windows-multibyte/widechar conversion flag. commit 72e56bc494 in LibreSSL: commit 72e56bc4947e53cec535f2fc84e00a3c278edf29 Author: tedu <> Date: Wed Apr 16 21:16:33 2014 +0000 TANSTAAFL - delete the buf freelist code. if you need a better malloc, get a better malloc. ok beck deraadt diff --git a/src/lib/libssl/s3_both.c b/src/lib/libssl/s3_both.c TANSTAAFL - There ain't no such thing as a free lunch commit 983f6bdb58 in BoringSSL: commit 983f6bdb5888d7074d7ee67d5e3741bcf1027108 Author: Alex Chernyakhovsky <achernya@google.com> Date: Sun Aug 3 15:48:35 2014 -0400 Set OPENSSL_NO_BUF_FREELISTS The memory freelist maintained by OpenSSL claims to be a performance optimization for platforms that have a slow malloc/free implementation. This should not be the case on modern linux/glibc. Remove the freelist as it poses a potential security hazard of buffer-reuse that is of \"initialized\" memory that will not be caught be tools such as valgrind. Change-Id: I3cfa6a05f9bdfbbba7820060bae5a673dee43014 Reviewed-on: https://boringssl-review.googlesource.com/1385 Reviewed-by: Adam Langley <agl@google.com> After commit b8d28cf532 BoringSSL calls ssl_write_buffer_flush() and ssl_write_buffer_clear() for each SSL_write() , so its memory footprint is much smaller than other SSL libraries (~32k) when no data is pending.","title":"Memory footprint"},{"location":"ssl/#performance-notes","text":"The P-256 curve, also known as prime256v1 or secp256r1 is widely used in ECDHE_RSA key exchange. For x86-64, there is a faster implementation, enabled by ./config enable-ec_nistp_64_gcc_128 . Futher speed up of P-256 in OpenSSL 1.1.0 and BoringSSL: commit 4d3fa06fce for OpenSSL 1.1.0 commit 3842a64d36 backports to 1.0.2 branch commit 1895493868 for BoringSSL commit 18954938684e269ccd59152027d2244040e2b819 Author: Adam Langley <agl@google.com> Date: Tue Nov 3 14:02:04 2015 -0800 Add Intel's P-256 This change incorporates Intel's P-256 implementation. The record of Intel's submission under CLA is in internal bug number 25330687. Before: Did 3582 ECDH P-256 operations in 1049114us (3414.3 ops/sec) Did 8525 ECDSA P-256 signing operations in 1028778us (8286.5 ops/sec) Did 3487 ECDSA P-256 verify operations in 1008996us (3455.9 ops/sec) build/tool/bssl is 1434704 bytes after strip -s After: Did 8618 ECDH P-256 operations in 1027884us (8384.2 ops/sec) Did 21000 ECDSA P-256 signing operations in 1049490us (20009.7 ops/sec) Did 8268 ECDSA P-256 verify operations in 1079481us (7659.2 ops/sec) build/tool/bssl is 1567216 bytes after strip -s Change-Id: I147971a8e19849779c8ed7e20310d41bd4962299 Reviewed-on: https://boringssl-review.googlesource.com/6371 Reviewed-by: Adam Langley <agl@google.com> None of them are available in LibreSSL as of Jan 19, 2017. Issue 259 .","title":"Performance notes"},{"location":"ssl/#cryptography","text":"cs387 Applied Cryptography on udacity Elliptic Curve Cryptography: ECDH and ECDSA Everything you need to know about cryptography in 1 hour","title":"Cryptography"},{"location":"kernel/callgraph/","text":"tcp_sock tcp_hashinfo // include/linux/types.h struct hlist_head { struct hlist_node *first; }; struct hlist_node { struct hlist_node *next, **pprev; }; // include/linux/list_nulls.h struct hlist_nulls_head { struct hlist_nulls_node *first; }; struct hlist_nulls_node { struct hlist_nulls_node *next, **pprev; }; // include/net/inet_hashtables.h struct inet_ehash_bucket { struct hlist_nulls_head chain; }; struct inet_bind_hashbucket { spinlock_t lock; // empty struct hlist_head chain; }; struct inet_listen_hashbucket { spinlock_t lock; // empty struct hlist_head head; }; #define INET_LHTABLE_SIZE 32 /* Yes, really, this is all you need. */ struct inet_hashinfo { /* This is for sockets with full identity only. Sockets here will * always be without wildcards and will have the following invariant: * * TCP_ESTABLISHED <= sk->sk_state < TCP_CLOSE * */ struct inet_ehash_bucket *ehash; spinlock_t *ehash_locks; unsigned int ehash_mask; unsigned int ehash_locks_mask; /* Ok, let's try this, I give up, we do need a local binding * TCP hash as well as the others for fast bind/connect. */ struct inet_bind_hashbucket *bhash; unsigned int bhash_size; /* 4 bytes hole on 64 bit */ struct kmem_cache *bind_bucket_cachep; /* All the above members are written once at bootup and * never written again _or_ are predominantly read-access. * * Now align to a new cache line as all the following members * might be often dirty. */ /* All sockets in TCP_LISTEN state will be in here. This is the only * table where wildcard'd TCP sockets can exist. Hash function here * is just local port number. */ struct inet_listen_hashbucket listening_hash[INET_LHTABLE_SIZE] ____cacheline_aligned_in_smp; }; TCP state diagram in Linux 4.4+ bind sys_bind -> inet_bind -> inet_csk_get_port -> goto have_snum: -> goto tb_not_found: tb == NULL -> inet_bind_bucket_create -> goto success: -> inet_bind_hash -> sk_add_bind_node -> fput_light // tcp_hashinfo.bhash -> inet_bind_hashbucket -> inet_bind_bucket[port=2222] -> tcp_sock listen sys_listen -> inet_listen -> inet_csk_listen_start -> reqsk_queue_alloc -> inet_csk_delack_init -> set sk->sk_state = TCP_LISTEN -> inet_csk_get_port -> goto have_snum: -> goto tb_found: -> inet_csk_bind_conflict -> goto tb_not_found: tb != NULL -> inet_hash -> __inet_hash // tcp_hashinfo.listening_hash[X] add node After bind() and listen() Passive open Receive SYN tcp_v4_rcv -> __inet_lookup_skb -> __inet_lookup -> __inet_lookup_established -> __inet_lookup_listener // found -> tcp_v4_do_rcv // sk_state == TCP_LISTEN -> tcp_rcv_state_process -> tcp_v4_conn_request // icsk->icsk_af_ops->conn_request -> tcp_conn_request -> req = inet_reqsk_alloc -> reqsk_alloc req->rsk_listener = sk_listener; ireq->ireq_state = TCP_NEW_SYN_RECV; ireq->ireq_family = sk_listener->sk_family; -> tcp_parse_options -> tcp_openreq_init -> tcp_v4_init_req // af_ops->init_req -> tcp_v4_save_options -> isn = tcp_v4_init_sequence // af_ops->init_seq -> tcp_v4_route_req // af_ops->route_req -> inet_csk_route_req -> flowi4_init_output -> ip_route_output_flow -> tcp_ecn_create_request -> tcp_openreq_init_rwin -> tcp_select_initial_window -> tcp_reqsk_record_syn -> tcp_try_fastopen -> inet_csk_reqsk_queue_hash_add -> reqsk_queue_hash_req //*** -> inet_ehash_insert -> __sk_nulls_add_node_rcu -> inet_csk_reqsk_queue_added inet_csk(sk)->icsk_accept_queue.qlen++ -> tcp_v4_send_synack // af_ops->send_synack -> tcp_make_synack -> __tcp_v4_send_check -> ip_build_and_send_pkt -> ip_local_out -> __ip_local_out -> dst_output -> ip_output After receiving SYN Receive ACK tcp_v4_rcv -> __inet_lookup_skb -> __inet_lookup -> __inet_lookup_established // found tcp_request_sock -> sk->sk_state == TCP_NEW_SYN_RECV sk = req->rsk_listener; -> tcp_check_req -> tcp_parse_options -> tcp_paws_reject -> tcp_in_window -> tcp_v4_syn_recv_sock // inet_csk(sk)->icsk_af_ops->syn_recv_sock -> tcp_create_openreq_child -> inet_csk_clone_lock -> sk_clone_lock -> newsk = sk_prot_alloc // new tcp_sock -> sock_copy newsk->sk_state = TCP_SYN_RECV; -> tcp_init_xmit_timers -> inet_sk_rx_dst_set -> inet_csk_route_child_sock -> tcp_ca_openreq_child -> tcp_assign_congestion_control -> tcp_set_ca_state TCP_CA_Open -> tcp_sync_mss -> dst_mtu -> ipv4_mtu -> tcp_mtu_to_mss -> tcp_bound_to_half_wnd -> dst_metric_advmss -> ipv4_default_advmss -> tcp_initialize_rcv_mss -> __inet_inherit_port -> inet_bind_hash // put newsk in bind_bucket inet_csk(sk)->icsk_bind_hash = tb; -> inet_ehash_nolisten -> inet_ehash_insert(newsk, reqsk) -> sk_nulls_del_node_init_rcu(osk) -> __sk_nulls_add_node_rcu(sk, list) -> sock_prot_inuse_add -> tcp_move_syn -> sock_rps_save_rxhash -> tcp_synack_rtt_meas -> skb_mstamp_us_delta -> tcp_ack_update_rtt -> tcp_update_rtt_min -> tcp_rtt_estimator -> tcp_set_rto -> inet_csk_complete_hashdance -> inet_csk_reqsk_queue_drop -> reqsk_queue_unlink -> reqsk_put(req) return found(false) -> reqsk_queue_removed &inet_csk(sk)->icsk_accept_queue.qlen-- -> inet_csk_reqsk_queue_add queue->rskq_accept_head = req // first -> sk_acceptq_added sk->sk_ack_backlog++; // listen_sk -> tcp_child_process -> tcp_rcv_state_process(child, skb) -> tcp_validate_incoming -> tcp_ack -> tcp_ack_update_window -> tcp_ecn_rcv_ecn_echo // false -> tcp_in_ack_event return 1 switch(sk_state) case TCP_SYN_RECV: -> inet_sk_rebuild_header // icsk->icsk_af_ops->rebuild_header -> tcp_init_congestion_control -> tcp_mtup_init -> tcp_init_buffer_space -> tcp_fixup_rcvbuf -> tcp_sndbuf_expand -> tcp_full_space tcp_set_state(sk, TCP_ESTABLISHED) sk->sk_state_change -> sock_def_wakeup -> tcp_init_metrics -> tcp_update_pacing_rate -> tcp_initialize_rcv_mss -> tcp_fast_path_on // out of switch -> tcp_urg switch TCP_ESTABLISHED -> tcp_data_queue -> tcp_data_snd_check -> tcp_ack_snd_check -> parent->sk_data_ready -> sock_def_readable -> wake_up_interruptible_sync_poll After receiving ACK Active open connect sys_connect -> inet_stream_connect -> __inet_stream_connect -> tcp_v4_connect (sk->sk_prot->connect) -> ip_route_connect tcp_set_state(sk, TCP_SYN_SENT) -> inet_hash_connect -> port_offset = inet_sk_port_offset(sk) -> secure_ipv4_port_ephemeral(saddr, daddr, dport) -> md5_transform -> __inet_hash_connect(..., port_offset, __inet_check_established) static uint32_t hint // counter -> inet_get_local_port_range -> inet_bind_bucket_create -> inet_bind_hash -> sk_add_bind_node -> inet_ehash_nolisten -> inet_ehash_insert -> sk_ehashfn -> inet_ehashfn -> __inet_ehashfn -> jhash_3words -> sock_prot_inuse_add -> ip_route_newports -> ip_route_output_flow -> secure_tcp_sequence_number(saddr, daddr, sport, dport) -> md5_transform -> tcp_connect -> tcp_connect_init -> sk_stream_alloc_skb -> tcp_init_nondata_skb -> tcp_connect_queue_skb -> tcp_ecn_send_syn -> tcp_transmit_skb -> tcp_options_size = tcp_syn_options tcp_header_size = tcp_options_size + sizeof(struct tcphdr); -> skb_push(skb, tcp_header_size) -> skb_reset_transport_header -> skb_orphan skb->destructor = tcp_wfree; -> tcp_options_write -> tcp_v4_send_check (icsk->icsk_af_ops->send_check) -> __tcp_v4_send_check skb->ip_summed == CHECKSUM_PARTIAL -> ip_queue_xmit (icsk->icsk_af_ops->queue_xmit) -> skb_push -> skb_reset_network_header iph->frag_off = htons(IP_DF); -> ip_copy_addrs -> ip_select_ident_segs -> ip_local_out -> __ip_local_out -> ip_send_check -> ip_fast_csum -> nf_hook { return 1; } -> dst_output -> ip_output (skb_dst(skb)->output) -> inet_csk_reset_xmit_timer sock->state = SS_CONNECTING; err = -EINPROGRESS; timeo = sock_sndtimeo() // NULL return err After connect() Receive SYN+ACK tcp_v4_rcv -> __inet_lookup_skb -> __inet_lookup -> __inet_lookup_established // found -> tcp_v4_do_rcv // sk_state == TCP_SYN_SENT -> tcp_rcv_state_process case TCP_SYN_SENT: -> tcp_rcv_synsent_state_process -> tcp_parse_options if (th->ack) // true -> tcp_ecn_rcv_synack -> tcp_init_wl -> tcp_ack(FLAG_SLOWPATH) // FLAG_SLOWPATH -> tcp_ack_update_window -> tcp_may_update_window // true -> tcp_update_wln -> tcp_fast_path_check -> tcp_sync_mss -> tcp_snd_una_update -> tcp_ecn_rcv_ecn_echo // false -> tcp_in_ack_event -> tcp_clean_rtx_queue -> tcp_ack_update_rtt -> tcp_rearm_rto -> tcp_rate_gen -> tcp_cong_control -> tcp_xmit_recovery -> tcp_mtup_init -> tcp_sync_mss -> tcp_initialize_rcv_mss -> tcp_finish_connect -> tcp_set_state(sk, TCP_ESTABLISHED); -> inet_sk_rx_dst_set (icsk->icsk_af_ops->sk_rx_dst_set) -> inet_sk_rebuild_header (icsk->icsk_af_ops->rebuild_header) -> tcp_init_metrics -> tcp_init_congestion_control -> tcp_init_buffer_space -> tcp_fixup_rcvbuf -> tcp_sndbuf_expand -> tcp_full_space -> tcp_send_ack -> skb_reserve -> tcp_init_nondata_skb -> skb_set_tcp_pure_ack -> skb_mstamp_get -> tcp_transmit_skb -> tcp_options_size = tcp_established_options // 12 ... -> tcp_urg -> __kfree_skb -> tcp_data_snd_check return 0; accept sys_accept4 -> newsock = sock_alloc -> newfd = get_unused_fd_flags -> newfile = sock_alloc_file(newsock, ...) -> inet_accept (sock->ops->accept) -> sk2 = inet_csk_accept (sk1->sk_prot->accept) queue = &icsk->icsk_accept_queue; req = reqsk_queue_remove(queue, sk); req = queue->rskq_accept_head; -> sk_acceptq_removed(parent); // sk->sk_ack_backlog--; newsk = req->sk -> release_sock(sk) -> reqsk_put(req) -> reqsk_free return newsk -> sock_graft(sk2, newsock) -> fd_install(newfd, newfile) read write do_syscall_64 -> __x64_sys_write -> ksys_write -> vfs_write -> __vfs_write -> new_sync_write -> sock_write_iter -> sock_sendmsg -> inet_sendmsg -> tcp_sendmsg -> tcp_sendmsg_locked -> tcp_push_one -> tcp_write_xmit tcp_sendmsg_locked -> __tcp_push_pending_frames -> tcp_write_xmit tcp_sendmsg_locked -> tcp_push -> __tcp_push_pending_frames -> tcp_write_xmit Receive net_rx_action -> napi_poll -> mlx4_en_poll_rx_cq -> napi_complete_done -> gro_normal_list -> netif_receive_skb_list_internal -> __netif_receive_skb_list -> __netif_receive_skb_list_core -> __netif_receive_skb_list_ptype -> ip_list_rcv -> ip_sublist_rcv -> ip_list_rcv_finish -> ip_sublist_rcv_finish -> dst_input -> ip_local_deliver -> NF_HOOK -> ip_local_deliver_finish -> ip_protocol_deliver_rcu -> tcp_v4_rcv netif_receive_skb -> __netif_receive_skb -> __netif_receive_skb_one_core -> ip_rcv_finish_core -> ip_rcv -> ip_rcv_finish -> ip_protocol_deliver_rcu -> ip_local_deliver -> ip_local_deliver_finish -> ip_protocol_deliver_rcu _> tcp_v4_rcv transmit tcp_v4_rcv -> tcp_v4_do_rcv -> tcp_rcv_established -> __tcp_push_pending_frames -> tcp_write_xmit tcp_write_xmit -> tcp_transmit_skb -> __tcp_transmit_skb -> ip_queue_xmit -> __ip_queue_xmit -> ip_local_out -> __ip_local_out -> ip_output","title":"Call Graphs"},{"location":"kernel/callgraph/#tcp_sock","text":"","title":"tcp_sock"},{"location":"kernel/callgraph/#tcp_hashinfo","text":"// include/linux/types.h struct hlist_head { struct hlist_node *first; }; struct hlist_node { struct hlist_node *next, **pprev; }; // include/linux/list_nulls.h struct hlist_nulls_head { struct hlist_nulls_node *first; }; struct hlist_nulls_node { struct hlist_nulls_node *next, **pprev; }; // include/net/inet_hashtables.h struct inet_ehash_bucket { struct hlist_nulls_head chain; }; struct inet_bind_hashbucket { spinlock_t lock; // empty struct hlist_head chain; }; struct inet_listen_hashbucket { spinlock_t lock; // empty struct hlist_head head; }; #define INET_LHTABLE_SIZE 32 /* Yes, really, this is all you need. */ struct inet_hashinfo { /* This is for sockets with full identity only. Sockets here will * always be without wildcards and will have the following invariant: * * TCP_ESTABLISHED <= sk->sk_state < TCP_CLOSE * */ struct inet_ehash_bucket *ehash; spinlock_t *ehash_locks; unsigned int ehash_mask; unsigned int ehash_locks_mask; /* Ok, let's try this, I give up, we do need a local binding * TCP hash as well as the others for fast bind/connect. */ struct inet_bind_hashbucket *bhash; unsigned int bhash_size; /* 4 bytes hole on 64 bit */ struct kmem_cache *bind_bucket_cachep; /* All the above members are written once at bootup and * never written again _or_ are predominantly read-access. * * Now align to a new cache line as all the following members * might be often dirty. */ /* All sockets in TCP_LISTEN state will be in here. This is the only * table where wildcard'd TCP sockets can exist. Hash function here * is just local port number. */ struct inet_listen_hashbucket listening_hash[INET_LHTABLE_SIZE] ____cacheline_aligned_in_smp; };","title":"tcp_hashinfo"},{"location":"kernel/callgraph/#tcp-state-diagram-in-linux-44","text":"","title":"TCP state diagram in Linux 4.4+"},{"location":"kernel/callgraph/#bind","text":"sys_bind -> inet_bind -> inet_csk_get_port -> goto have_snum: -> goto tb_not_found: tb == NULL -> inet_bind_bucket_create -> goto success: -> inet_bind_hash -> sk_add_bind_node -> fput_light // tcp_hashinfo.bhash -> inet_bind_hashbucket -> inet_bind_bucket[port=2222] -> tcp_sock","title":"bind"},{"location":"kernel/callgraph/#listen","text":"sys_listen -> inet_listen -> inet_csk_listen_start -> reqsk_queue_alloc -> inet_csk_delack_init -> set sk->sk_state = TCP_LISTEN -> inet_csk_get_port -> goto have_snum: -> goto tb_found: -> inet_csk_bind_conflict -> goto tb_not_found: tb != NULL -> inet_hash -> __inet_hash // tcp_hashinfo.listening_hash[X] add node After bind() and listen()","title":"listen"},{"location":"kernel/callgraph/#passive-open","text":"","title":"Passive open"},{"location":"kernel/callgraph/#receive-syn","text":"tcp_v4_rcv -> __inet_lookup_skb -> __inet_lookup -> __inet_lookup_established -> __inet_lookup_listener // found -> tcp_v4_do_rcv // sk_state == TCP_LISTEN -> tcp_rcv_state_process -> tcp_v4_conn_request // icsk->icsk_af_ops->conn_request -> tcp_conn_request -> req = inet_reqsk_alloc -> reqsk_alloc req->rsk_listener = sk_listener; ireq->ireq_state = TCP_NEW_SYN_RECV; ireq->ireq_family = sk_listener->sk_family; -> tcp_parse_options -> tcp_openreq_init -> tcp_v4_init_req // af_ops->init_req -> tcp_v4_save_options -> isn = tcp_v4_init_sequence // af_ops->init_seq -> tcp_v4_route_req // af_ops->route_req -> inet_csk_route_req -> flowi4_init_output -> ip_route_output_flow -> tcp_ecn_create_request -> tcp_openreq_init_rwin -> tcp_select_initial_window -> tcp_reqsk_record_syn -> tcp_try_fastopen -> inet_csk_reqsk_queue_hash_add -> reqsk_queue_hash_req //*** -> inet_ehash_insert -> __sk_nulls_add_node_rcu -> inet_csk_reqsk_queue_added inet_csk(sk)->icsk_accept_queue.qlen++ -> tcp_v4_send_synack // af_ops->send_synack -> tcp_make_synack -> __tcp_v4_send_check -> ip_build_and_send_pkt -> ip_local_out -> __ip_local_out -> dst_output -> ip_output After receiving SYN","title":"Receive SYN"},{"location":"kernel/callgraph/#receive-ack","text":"tcp_v4_rcv -> __inet_lookup_skb -> __inet_lookup -> __inet_lookup_established // found tcp_request_sock -> sk->sk_state == TCP_NEW_SYN_RECV sk = req->rsk_listener; -> tcp_check_req -> tcp_parse_options -> tcp_paws_reject -> tcp_in_window -> tcp_v4_syn_recv_sock // inet_csk(sk)->icsk_af_ops->syn_recv_sock -> tcp_create_openreq_child -> inet_csk_clone_lock -> sk_clone_lock -> newsk = sk_prot_alloc // new tcp_sock -> sock_copy newsk->sk_state = TCP_SYN_RECV; -> tcp_init_xmit_timers -> inet_sk_rx_dst_set -> inet_csk_route_child_sock -> tcp_ca_openreq_child -> tcp_assign_congestion_control -> tcp_set_ca_state TCP_CA_Open -> tcp_sync_mss -> dst_mtu -> ipv4_mtu -> tcp_mtu_to_mss -> tcp_bound_to_half_wnd -> dst_metric_advmss -> ipv4_default_advmss -> tcp_initialize_rcv_mss -> __inet_inherit_port -> inet_bind_hash // put newsk in bind_bucket inet_csk(sk)->icsk_bind_hash = tb; -> inet_ehash_nolisten -> inet_ehash_insert(newsk, reqsk) -> sk_nulls_del_node_init_rcu(osk) -> __sk_nulls_add_node_rcu(sk, list) -> sock_prot_inuse_add -> tcp_move_syn -> sock_rps_save_rxhash -> tcp_synack_rtt_meas -> skb_mstamp_us_delta -> tcp_ack_update_rtt -> tcp_update_rtt_min -> tcp_rtt_estimator -> tcp_set_rto -> inet_csk_complete_hashdance -> inet_csk_reqsk_queue_drop -> reqsk_queue_unlink -> reqsk_put(req) return found(false) -> reqsk_queue_removed &inet_csk(sk)->icsk_accept_queue.qlen-- -> inet_csk_reqsk_queue_add queue->rskq_accept_head = req // first -> sk_acceptq_added sk->sk_ack_backlog++; // listen_sk -> tcp_child_process -> tcp_rcv_state_process(child, skb) -> tcp_validate_incoming -> tcp_ack -> tcp_ack_update_window -> tcp_ecn_rcv_ecn_echo // false -> tcp_in_ack_event return 1 switch(sk_state) case TCP_SYN_RECV: -> inet_sk_rebuild_header // icsk->icsk_af_ops->rebuild_header -> tcp_init_congestion_control -> tcp_mtup_init -> tcp_init_buffer_space -> tcp_fixup_rcvbuf -> tcp_sndbuf_expand -> tcp_full_space tcp_set_state(sk, TCP_ESTABLISHED) sk->sk_state_change -> sock_def_wakeup -> tcp_init_metrics -> tcp_update_pacing_rate -> tcp_initialize_rcv_mss -> tcp_fast_path_on // out of switch -> tcp_urg switch TCP_ESTABLISHED -> tcp_data_queue -> tcp_data_snd_check -> tcp_ack_snd_check -> parent->sk_data_ready -> sock_def_readable -> wake_up_interruptible_sync_poll After receiving ACK","title":"Receive ACK"},{"location":"kernel/callgraph/#active-open","text":"","title":"Active open"},{"location":"kernel/callgraph/#connect","text":"sys_connect -> inet_stream_connect -> __inet_stream_connect -> tcp_v4_connect (sk->sk_prot->connect) -> ip_route_connect tcp_set_state(sk, TCP_SYN_SENT) -> inet_hash_connect -> port_offset = inet_sk_port_offset(sk) -> secure_ipv4_port_ephemeral(saddr, daddr, dport) -> md5_transform -> __inet_hash_connect(..., port_offset, __inet_check_established) static uint32_t hint // counter -> inet_get_local_port_range -> inet_bind_bucket_create -> inet_bind_hash -> sk_add_bind_node -> inet_ehash_nolisten -> inet_ehash_insert -> sk_ehashfn -> inet_ehashfn -> __inet_ehashfn -> jhash_3words -> sock_prot_inuse_add -> ip_route_newports -> ip_route_output_flow -> secure_tcp_sequence_number(saddr, daddr, sport, dport) -> md5_transform -> tcp_connect -> tcp_connect_init -> sk_stream_alloc_skb -> tcp_init_nondata_skb -> tcp_connect_queue_skb -> tcp_ecn_send_syn -> tcp_transmit_skb -> tcp_options_size = tcp_syn_options tcp_header_size = tcp_options_size + sizeof(struct tcphdr); -> skb_push(skb, tcp_header_size) -> skb_reset_transport_header -> skb_orphan skb->destructor = tcp_wfree; -> tcp_options_write -> tcp_v4_send_check (icsk->icsk_af_ops->send_check) -> __tcp_v4_send_check skb->ip_summed == CHECKSUM_PARTIAL -> ip_queue_xmit (icsk->icsk_af_ops->queue_xmit) -> skb_push -> skb_reset_network_header iph->frag_off = htons(IP_DF); -> ip_copy_addrs -> ip_select_ident_segs -> ip_local_out -> __ip_local_out -> ip_send_check -> ip_fast_csum -> nf_hook { return 1; } -> dst_output -> ip_output (skb_dst(skb)->output) -> inet_csk_reset_xmit_timer sock->state = SS_CONNECTING; err = -EINPROGRESS; timeo = sock_sndtimeo() // NULL return err After connect()","title":"connect"},{"location":"kernel/callgraph/#receive-synack","text":"tcp_v4_rcv -> __inet_lookup_skb -> __inet_lookup -> __inet_lookup_established // found -> tcp_v4_do_rcv // sk_state == TCP_SYN_SENT -> tcp_rcv_state_process case TCP_SYN_SENT: -> tcp_rcv_synsent_state_process -> tcp_parse_options if (th->ack) // true -> tcp_ecn_rcv_synack -> tcp_init_wl -> tcp_ack(FLAG_SLOWPATH) // FLAG_SLOWPATH -> tcp_ack_update_window -> tcp_may_update_window // true -> tcp_update_wln -> tcp_fast_path_check -> tcp_sync_mss -> tcp_snd_una_update -> tcp_ecn_rcv_ecn_echo // false -> tcp_in_ack_event -> tcp_clean_rtx_queue -> tcp_ack_update_rtt -> tcp_rearm_rto -> tcp_rate_gen -> tcp_cong_control -> tcp_xmit_recovery -> tcp_mtup_init -> tcp_sync_mss -> tcp_initialize_rcv_mss -> tcp_finish_connect -> tcp_set_state(sk, TCP_ESTABLISHED); -> inet_sk_rx_dst_set (icsk->icsk_af_ops->sk_rx_dst_set) -> inet_sk_rebuild_header (icsk->icsk_af_ops->rebuild_header) -> tcp_init_metrics -> tcp_init_congestion_control -> tcp_init_buffer_space -> tcp_fixup_rcvbuf -> tcp_sndbuf_expand -> tcp_full_space -> tcp_send_ack -> skb_reserve -> tcp_init_nondata_skb -> skb_set_tcp_pure_ack -> skb_mstamp_get -> tcp_transmit_skb -> tcp_options_size = tcp_established_options // 12 ... -> tcp_urg -> __kfree_skb -> tcp_data_snd_check return 0;","title":"Receive SYN+ACK"},{"location":"kernel/callgraph/#accept","text":"sys_accept4 -> newsock = sock_alloc -> newfd = get_unused_fd_flags -> newfile = sock_alloc_file(newsock, ...) -> inet_accept (sock->ops->accept) -> sk2 = inet_csk_accept (sk1->sk_prot->accept) queue = &icsk->icsk_accept_queue; req = reqsk_queue_remove(queue, sk); req = queue->rskq_accept_head; -> sk_acceptq_removed(parent); // sk->sk_ack_backlog--; newsk = req->sk -> release_sock(sk) -> reqsk_put(req) -> reqsk_free return newsk -> sock_graft(sk2, newsock) -> fd_install(newfd, newfile)","title":"accept"},{"location":"kernel/callgraph/#read","text":"","title":"read"},{"location":"kernel/callgraph/#write","text":"do_syscall_64 -> __x64_sys_write -> ksys_write -> vfs_write -> __vfs_write -> new_sync_write -> sock_write_iter -> sock_sendmsg -> inet_sendmsg -> tcp_sendmsg -> tcp_sendmsg_locked -> tcp_push_one -> tcp_write_xmit tcp_sendmsg_locked -> __tcp_push_pending_frames -> tcp_write_xmit tcp_sendmsg_locked -> tcp_push -> __tcp_push_pending_frames -> tcp_write_xmit","title":"write"},{"location":"kernel/callgraph/#receive","text":"net_rx_action -> napi_poll -> mlx4_en_poll_rx_cq -> napi_complete_done -> gro_normal_list -> netif_receive_skb_list_internal -> __netif_receive_skb_list -> __netif_receive_skb_list_core -> __netif_receive_skb_list_ptype -> ip_list_rcv -> ip_sublist_rcv -> ip_list_rcv_finish -> ip_sublist_rcv_finish -> dst_input -> ip_local_deliver -> NF_HOOK -> ip_local_deliver_finish -> ip_protocol_deliver_rcu -> tcp_v4_rcv netif_receive_skb -> __netif_receive_skb -> __netif_receive_skb_one_core -> ip_rcv_finish_core -> ip_rcv -> ip_rcv_finish -> ip_protocol_deliver_rcu -> ip_local_deliver -> ip_local_deliver_finish -> ip_protocol_deliver_rcu _> tcp_v4_rcv","title":"Receive"},{"location":"kernel/callgraph/#transmit","text":"tcp_v4_rcv -> tcp_v4_do_rcv -> tcp_rcv_established -> __tcp_push_pending_frames -> tcp_write_xmit tcp_write_xmit -> tcp_transmit_skb -> __tcp_transmit_skb -> ip_queue_xmit -> __ip_queue_xmit -> ip_local_out -> __ip_local_out -> ip_output","title":"transmit"},{"location":"kernel/changes/","text":"4.12 - 2017-07-02 Removed net.ipv4.tcp_tw_recycle option from Kernel commit . Ref. Coping with the TCP TIME-WAIT state on busy Linux servers by Vincent Bernat. 4.9 - 2016-12-11 Linux 4.9 BBR congestion control algorithm tcp: use an RB tree for ooo receive queue commit 9f5afeae51 4.6 - 2016-05-15 Linux 4.6 Faster SO_REUSEPORT for TCP 4.5 - 2016-03-13 Linux 4.5 Faster SO_REUSEPORT for UDP Better epoll multithread scalability 4.4 - 2016-01-10 Linux 4.4 TCP scalability Lockless TCP listener SO_INCOMING_CPU TCP_NEW_SYN_RECV commit ca6fb06518836ef9b65dc0aac02ff97704d52a05 Author: Eric Dumazet <edumazet@google.com> Date: Fri Oct 2 11:43:35 2015 -0700 tcp: attach SYNACK messages to request sockets instead of listener If a listen backlog is very big (to avoid syncookies), then the listener sk->sk_wmem_alloc is the main source of false sharing, as we need to touch it twice per SYNACK re-transmit and TX completion. (One SYN packet takes listener lock once, but up to 6 SYNACK are generated) By attaching the skb to the request socket, we remove this source of contention. Tested: listen(fd, 10485760); // single listener (no SO_REUSEPORT) 16 RX/TX queue NIC Sustain a SYNFLOOD attack of ~320,000 SYN per second, Sending ~1,400,000 SYNACK per second. Perf profiles now show listener spinlock being next bottleneck. 20.29% [kernel] [k] queued_spin_lock_slowpath 10.06% [kernel] [k] __inet_lookup_established 5.12% [kernel] [k] reqsk_timer_handler 3.22% [kernel] [k] get_next_timer_interrupt 3.00% [kernel] [k] tcp_make_synack 2.77% [kernel] [k] ipt_do_table 2.70% [kernel] [k] run_timer_softirq 2.50% [kernel] [k] ip_finish_output 2.04% [kernel] [k] cascade Signed-off-by: Eric Dumazet <edumazet@google.com> Signed-off-by: David S. Miller <davem@davemloft.net> commit 079096f103faca2dd87342cca6f23d4b34da8871 Author: Eric Dumazet <edumazet@google.com> Date: Fri Oct 2 11:43:32 2015 -0700 tcp/dccp: install syn_recv requests into ehash table In this patch, we insert request sockets into TCP/DCCP regular ehash table (where ESTABLISHED and TIMEWAIT sockets are) instead of using the per listener hash table. ACK packets find SYN_RECV pseudo sockets without having to find and lock the listener. In nominal conditions, this halves pressure on listener lock. Note that this will allow for SO_REUSEPORT refinements, so that we can select a listener using cpu/numa affinities instead of the prior 'consistent hash', since only SYN packets will apply this selection logic. We will shrink listen_sock in the following patch to ease code review. Signed-off-by: Eric Dumazet <edumazet@google.com> Cc: Ying Cai <ycai@google.com> Cc: Willem de Bruijn <willemb@google.com> Signed-off-by: David S. Miller <davem@davemloft.net> 4.3 - 2015-11-01 Linux 4.3 commit 9dea5dc921b5f4045a18c63eb92e84dc274d17eb Author: Andy Lutomirski <luto@kernel.org> Date: Tue Jul 14 15:24:24 2015 -0700 x86/entry/syscalls: Wire up 32-bit direct socket calls On x86_64, there's no socketcall syscall; instead all of the socket calls are real syscalls. For 32-bit programs, we're stuck offering the socketcall syscall, but it would be nice to expose the direct calls as well. This will enable seccomp to filter socket calls (for new userspace only, but that's fine for some applications) and it will provide a tiny performance boost. glibc 2.23 2016-02-19. Ubuntu 16.04 supports it, Debian 8 doesn't. commit e5a5315e2d290fe34e0fb80996c713b8b802dcc9 Author: Joseph Myers <joseph@codesourcery.com> Date: Wed Dec 9 20:59:43 2015 +0000 Use direct socket syscalls for new kernels on i386, m68k, microblaze, sh. Now that we have __ASSUME_* macros for direct socket syscalls to use them instead of socketcall when they can be assumed to be available on socketcall architectures, this patch defines those macros when appropriate for i386, m68k, microblaze and sh (for 4.3, 4.3, all supported kernels and 2.6.37, respectively; the only use of socketcall support on microblaze is it allows accept4 and sendmmsg to be supported on a wider range of kernel versions). 4.2 - 2015-08-30 Linux 4.2 commit 90c337da1524863838658078ec34241f45d8394d Author: Eric Dumazet <edumazet@google.com> Date: Sat Jun 6 21:17:57 2015 -0700 inet: add IP_BIND_ADDRESS_NO_PORT to overcome bind(0) limitations When an application needs to force a source IP on an active TCP socket it has to use bind(IP, port=x). As most applications do not want to deal with already used ports, x is often set to 0, meaning the kernel is in charge to find an available port. But kernel does not know yet if this socket is going to be a listener or be connected. It has very limited choices (no full knowledge of final 4-tuple for a connect()) With limited ephemeral port range (about 32K ports), it is very easy to fill the space. This patch adds a new SOL_IP socket option, asking kernel to ignore the 0 port provided by application in bind(IP, port=0) and only remember the given IP address. The port will be automatically chosen at connect() time, in a way that allows sharing a source port as long as the 4-tuples are unique. This new feature is available for both IPv4 and IPv6 (Thanks Neal)","title":"Changes"},{"location":"kernel/changes/#412-2017-07-02","text":"Removed net.ipv4.tcp_tw_recycle option from Kernel commit . Ref. Coping with the TCP TIME-WAIT state on busy Linux servers by Vincent Bernat.","title":"4.12 - 2017-07-02"},{"location":"kernel/changes/#49-2016-12-11","text":"Linux 4.9 BBR congestion control algorithm tcp: use an RB tree for ooo receive queue commit 9f5afeae51","title":"4.9 - 2016-12-11"},{"location":"kernel/changes/#46-2016-05-15","text":"Linux 4.6 Faster SO_REUSEPORT for TCP","title":"4.6 - 2016-05-15"},{"location":"kernel/changes/#45-2016-03-13","text":"Linux 4.5 Faster SO_REUSEPORT for UDP Better epoll multithread scalability","title":"4.5 - 2016-03-13"},{"location":"kernel/changes/#44-2016-01-10","text":"Linux 4.4 TCP scalability Lockless TCP listener SO_INCOMING_CPU TCP_NEW_SYN_RECV commit ca6fb06518836ef9b65dc0aac02ff97704d52a05 Author: Eric Dumazet <edumazet@google.com> Date: Fri Oct 2 11:43:35 2015 -0700 tcp: attach SYNACK messages to request sockets instead of listener If a listen backlog is very big (to avoid syncookies), then the listener sk->sk_wmem_alloc is the main source of false sharing, as we need to touch it twice per SYNACK re-transmit and TX completion. (One SYN packet takes listener lock once, but up to 6 SYNACK are generated) By attaching the skb to the request socket, we remove this source of contention. Tested: listen(fd, 10485760); // single listener (no SO_REUSEPORT) 16 RX/TX queue NIC Sustain a SYNFLOOD attack of ~320,000 SYN per second, Sending ~1,400,000 SYNACK per second. Perf profiles now show listener spinlock being next bottleneck. 20.29% [kernel] [k] queued_spin_lock_slowpath 10.06% [kernel] [k] __inet_lookup_established 5.12% [kernel] [k] reqsk_timer_handler 3.22% [kernel] [k] get_next_timer_interrupt 3.00% [kernel] [k] tcp_make_synack 2.77% [kernel] [k] ipt_do_table 2.70% [kernel] [k] run_timer_softirq 2.50% [kernel] [k] ip_finish_output 2.04% [kernel] [k] cascade Signed-off-by: Eric Dumazet <edumazet@google.com> Signed-off-by: David S. Miller <davem@davemloft.net> commit 079096f103faca2dd87342cca6f23d4b34da8871 Author: Eric Dumazet <edumazet@google.com> Date: Fri Oct 2 11:43:32 2015 -0700 tcp/dccp: install syn_recv requests into ehash table In this patch, we insert request sockets into TCP/DCCP regular ehash table (where ESTABLISHED and TIMEWAIT sockets are) instead of using the per listener hash table. ACK packets find SYN_RECV pseudo sockets without having to find and lock the listener. In nominal conditions, this halves pressure on listener lock. Note that this will allow for SO_REUSEPORT refinements, so that we can select a listener using cpu/numa affinities instead of the prior 'consistent hash', since only SYN packets will apply this selection logic. We will shrink listen_sock in the following patch to ease code review. Signed-off-by: Eric Dumazet <edumazet@google.com> Cc: Ying Cai <ycai@google.com> Cc: Willem de Bruijn <willemb@google.com> Signed-off-by: David S. Miller <davem@davemloft.net>","title":"4.4 - 2016-01-10"},{"location":"kernel/changes/#43-2015-11-01","text":"Linux 4.3 commit 9dea5dc921b5f4045a18c63eb92e84dc274d17eb Author: Andy Lutomirski <luto@kernel.org> Date: Tue Jul 14 15:24:24 2015 -0700 x86/entry/syscalls: Wire up 32-bit direct socket calls On x86_64, there's no socketcall syscall; instead all of the socket calls are real syscalls. For 32-bit programs, we're stuck offering the socketcall syscall, but it would be nice to expose the direct calls as well. This will enable seccomp to filter socket calls (for new userspace only, but that's fine for some applications) and it will provide a tiny performance boost. glibc 2.23 2016-02-19. Ubuntu 16.04 supports it, Debian 8 doesn't. commit e5a5315e2d290fe34e0fb80996c713b8b802dcc9 Author: Joseph Myers <joseph@codesourcery.com> Date: Wed Dec 9 20:59:43 2015 +0000 Use direct socket syscalls for new kernels on i386, m68k, microblaze, sh. Now that we have __ASSUME_* macros for direct socket syscalls to use them instead of socketcall when they can be assumed to be available on socketcall architectures, this patch defines those macros when appropriate for i386, m68k, microblaze and sh (for 4.3, 4.3, all supported kernels and 2.6.37, respectively; the only use of socketcall support on microblaze is it allows accept4 and sendmmsg to be supported on a wider range of kernel versions).","title":"4.3 - 2015-11-01"},{"location":"kernel/changes/#42-2015-08-30","text":"Linux 4.2 commit 90c337da1524863838658078ec34241f45d8394d Author: Eric Dumazet <edumazet@google.com> Date: Sat Jun 6 21:17:57 2015 -0700 inet: add IP_BIND_ADDRESS_NO_PORT to overcome bind(0) limitations When an application needs to force a source IP on an active TCP socket it has to use bind(IP, port=x). As most applications do not want to deal with already used ports, x is often set to 0, meaning the kernel is in charge to find an available port. But kernel does not know yet if this socket is going to be a listener or be connected. It has very limited choices (no full knowledge of final 4-tuple for a connect()) With limited ephemeral port range (about 32K ports), it is very easy to fill the space. This patch adds a new SOL_IP socket option, asking kernel to ignore the 0 port provided by application in bind(IP, port=0) and only remember the given IP address. The port will be automatically chosen at connect() time, in a way that allows sharing a source port as long as the 4-tuples are unique. This new feature is available for both IPv4 and IPv6 (Thanks Neal)","title":"4.2 - 2015-08-30"},{"location":"kernel/data-structures/","text":"File Descriptor Table // include/linux/sched.h struct task_struct { // ... /* open file information */ struct files_struct *files; // ... }; // include/linux/fdtable.h struct fdtable { unsigned int max_fds; struct file __rcu **fd; /* current fd array */ unsigned long *close_on_exec; unsigned long *open_fds; unsigned long *full_fds_bits; struct rcu_head rcu; }; /* * Open file table structure */ struct files_struct { /* * read mostly part */ atomic_t count; bool resize_in_progress; wait_queue_head_t resize_wait; struct fdtable __rcu *fdt; struct fdtable fdtab; /* * written part on a separate cache line in SMP */ spinlock_t file_lock ____cacheline_aligned_in_smp; unsigned int next_fd; unsigned long close_on_exec_init[1]; unsigned long open_fds_init[1]; unsigned long full_fds_bits_init[1]; struct file __rcu * fd_array[NR_OPEN_DEFAULT]; }; // include/linux/fs.h struct file { union { struct llist_node fu_llist; struct rcu_head fu_rcuhead; } f_u; struct path f_path; struct inode *f_inode; /* cached value */ const struct file_operations *f_op; // ... atomic_long_t f_count; // ... /* needed for tty driver, and maybe others */ void *private_data; #ifdef CONFIG_EPOLL /* Used by fs/eventpoll.c to link all the hooks to this file */ struct list_head f_ep_links; struct list_head f_tfile_llink; #endif }; struct socket{} // include/linux/net.h struct socket_wq { /* Note: wait MUST be first field of socket_wq */ wait_queue_head_t wait; struct fasync_struct *fasync_list; unsigned long flags; /* %SOCKWQ_ASYNC_NOSPACE, etc */ struct rcu_head rcu; } ____cacheline_aligned_in_smp; /** * struct socket - general BSD socket * @state: socket state (%SS_CONNECTED, etc) * @type: socket type (%SOCK_STREAM, etc) * @flags: socket flags (%SOCK_NOSPACE, etc) * @ops: protocol specific socket operations * @file: File back pointer for gc * @sk: internal networking protocol agnostic socket representation * @wq: wait queue for several uses */ struct socket { socket_state state; kmemcheck_bitfield_begin(type); short type; kmemcheck_bitfield_end(type); unsigned long flags; struct socket_wq __rcu *wq; struct file *file; struct sock *sk; const struct proto_ops *ops; }; // include/net/sock.h struct socket_alloc { struct socket socket; struct inode vfs_inode; }; // include/linux/fs.h struct inode { umode_t i_mode; // S_IFSOCK | S_IRWXUGO; unsigned short i_opflags; kuid_t i_uid; kgid_t i_gid; unsigned int i_flags; // ... const struct inode_operations *i_op; struct super_block *i_sb; // ... unsigned long i_ino; // sockfs_dname: \"socket:[%lu]\" // ... union { struct hlist_head i_dentry; struct rcu_head i_rcu; }; // ... }; socket(2) int sys_socket(int family, int type, int protocol) -> struct socket* sock_create(family, type, protocol) -> __sock_create(family, type, protocol) -> struct socket* sock = sock_alloc() -> inode = new_inode_pseudo(super_block of sockfs) // fs/inode.c -> alloc_inode -> sock_alloc_inode (sb->s_op->alloc_inod) -> socket_alloc *ei = kmem_cache_alloc(sock_inode_cachep) // 306B -> socket_wq *wq = kmalloc(sizeof(*wq)) // 24B ei->socket.wq = wq; ei->socket.state = SS_UNCONNECTED; -> inode_init_always sock = SOCKET_I(inode); inode->i_op = &sockfs_inode_ops; // .listxattr = sockfs_listxattr, -> net_families[family]->create(sock, protocol) -> inet_create(sock, protocol) // net/ipv4/af_inet.c -> sock_map_fd() -> get_unused_fd_flags -> sock_alloc_file -> d_alloc_pseudo // sizeof(struct dentry) == 128 -> file = alloc_file(..., &socket_file_ops); // sizeof(struct file) == 140 -> get_empty_filp file.f_op = &socket_file_ops sock->file = file; file->private_data = sock; -> fd_install inet_create(sock, protocol) -> find inet_protosw for sock->type & protocol -> struct sock* sk = sk_alloc() -> sk_prot_alloc -> kmem_cache_alloc (tcp_prot is 1360B) -> sock_init_data sk->sk_socket = sock; sock->sk = sk; -> sk->sk_prot->init(sk) -> tcp_v4_init_sock -> tcp_init_sock -> tcp_init_xmit_timers -> tcp_prequeue_init -> tcp_enable_early_retrans -> tcp_assign_congestion_control sk->sk_state = TCP_CLOSE; icsk->icsk_af_ops = &ipv4_specific; After socket() Memory usage On x86-64 Deiban 8, Linux 3.16, /proc/slabinfo struct size slab cache name file 256 \"filp\" dentry 192 \"dentry\" socket_alloc 640 \"sock_inode_cache\" tcp_sock 1792 \"TCP\" socket_wq 64 \"kmalloc-64\" inet_bind_bucket 64 \"tcp_bind_bucket\" tcp_request_sock 256 \"request_sock_TCP\" inet_timewait_sock 192 \"tw_sock_TCP\" epitem 128 \"eventpoll_epi\" Total : 2944 bytes/socket, not including send/receive buffers. For client sockets, +64B for inet_bind_bucket . net_proto_family family type protocol AF_UNIX=1 SOCK_STREAM=1 0 AF_UNIX SOCK_DGRAM=2 0 AF_INET=2 SOCK_STREAM IPPROTO_TCP=6 AF_INET SOCK_DGRAM IPPROTO_UDP=17 AF_INET SOCK_DGRAM IPPROTO_ICMP=1 AF_INET SOCK_RAW=3 IPPROTO_IP=0 NPROTO=AF_MAX=41 SOCK_MAX=11 no max? // include/linux/net.h // How to create a socket for an address family struct net_proto_family { int family; // AF_INET, AF_UNIX, AF_INET6, etc. must: 0 <= family < NPROTO int (*create)(struct net *net, struct socket *sock, int protocol, int kern); struct module *owner; }; // net/socket.c static const struct net_proto_family *net_families[NPROTO]; // net/ipv4/af_inet.c static int inet_create(struct net *net, struct socket *sock, int protocol, int kern); static const struct net_proto_family inet_family_ops = { .family = PF_INET, .create = inet_create, .owner = THIS_MODULE }; // inet_init() calls sock_register(): net_families[AF_INET] = &inet_family_ops; inet_protosw // include/net/protocol.h /* This is used to register socket interfaces for IP protocols. */ struct inet_protosw { struct list_head list; /* These two fields form the lookup key. */ unsigned short type; /* This is the 2nd argument to socket(2). eg. SOCK_STREAM, SOCK_DGRAM */ unsigned short protocol; /* This is the L4 protocol number. eg. IPPROTO_TCP, IPPROTO_TCP */ struct proto *prot; const struct proto_ops *ops; unsigned char flags; /* See INET_PROTOSW_* below. */ }; #define INET_PROTOSW_REUSE 0x01 /* Are ports automatically reusable? */ #define INET_PROTOSW_PERMANENT 0x02 /* Permanent protocols are unremovable. */ #define INET_PROTOSW_ICSK 0x04 /* Is this an inet_connection_sock? */ // net/ipv4/af_inet.c /* The inetsw table contains everything that inet_create needs to * build a new socket. */ static struct list_head inetsw[SOCK_MAX]; static DEFINE_SPINLOCK(inetsw_lock); /* Upon startup we insert all the elements in inetsw_array[] into * the linked list inetsw. */ static struct inet_protosw inetsw_array[] = { { .type = SOCK_STREAM, .protocol = IPPROTO_TCP, .prot = &tcp_prot, .ops = &inet_stream_ops, .flags = INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK, }, { .type = SOCK_DGRAM, .protocol = IPPROTO_UDP, .prot = &udp_prot, .ops = &inet_dgram_ops, .flags = INET_PROTOSW_PERMANENT, }, { .type = SOCK_DGRAM, .protocol = IPPROTO_ICMP, .prot = &ping_prot, .ops = &inet_dgram_ops, .flags = INET_PROTOSW_REUSE, }, { .type = SOCK_RAW, .protocol = IPPROTO_IP, /* wild card */ .prot = &raw_prot, .ops = &inet_sockraw_ops, .flags = INET_PROTOSW_REUSE, } }; #define INETSW_ARRAY_LEN ARRAY_SIZE(inetsw_array) // inet_init() sock_register(&inet_family_ops); /* Register the socket-side information for inet_create. */ for (struct list_head *r = &inetsw[0]; r < &inetsw[SOCK_MAX]; ++r) INIT_LIST_HEAD(r); for (struct inet_protosw *q = inetsw_array; q < &inetsw_array[INETSW_ARRAY_LEN]; ++q) inet_register_protosw(q); After Initialization: skbuff A sample of receive skb for TCP SYN segment:","title":"Data Structures"},{"location":"kernel/data-structures/#file-descriptor-table","text":"// include/linux/sched.h struct task_struct { // ... /* open file information */ struct files_struct *files; // ... }; // include/linux/fdtable.h struct fdtable { unsigned int max_fds; struct file __rcu **fd; /* current fd array */ unsigned long *close_on_exec; unsigned long *open_fds; unsigned long *full_fds_bits; struct rcu_head rcu; }; /* * Open file table structure */ struct files_struct { /* * read mostly part */ atomic_t count; bool resize_in_progress; wait_queue_head_t resize_wait; struct fdtable __rcu *fdt; struct fdtable fdtab; /* * written part on a separate cache line in SMP */ spinlock_t file_lock ____cacheline_aligned_in_smp; unsigned int next_fd; unsigned long close_on_exec_init[1]; unsigned long open_fds_init[1]; unsigned long full_fds_bits_init[1]; struct file __rcu * fd_array[NR_OPEN_DEFAULT]; }; // include/linux/fs.h struct file { union { struct llist_node fu_llist; struct rcu_head fu_rcuhead; } f_u; struct path f_path; struct inode *f_inode; /* cached value */ const struct file_operations *f_op; // ... atomic_long_t f_count; // ... /* needed for tty driver, and maybe others */ void *private_data; #ifdef CONFIG_EPOLL /* Used by fs/eventpoll.c to link all the hooks to this file */ struct list_head f_ep_links; struct list_head f_tfile_llink; #endif };","title":"File Descriptor Table"},{"location":"kernel/data-structures/#struct-socket","text":"// include/linux/net.h struct socket_wq { /* Note: wait MUST be first field of socket_wq */ wait_queue_head_t wait; struct fasync_struct *fasync_list; unsigned long flags; /* %SOCKWQ_ASYNC_NOSPACE, etc */ struct rcu_head rcu; } ____cacheline_aligned_in_smp; /** * struct socket - general BSD socket * @state: socket state (%SS_CONNECTED, etc) * @type: socket type (%SOCK_STREAM, etc) * @flags: socket flags (%SOCK_NOSPACE, etc) * @ops: protocol specific socket operations * @file: File back pointer for gc * @sk: internal networking protocol agnostic socket representation * @wq: wait queue for several uses */ struct socket { socket_state state; kmemcheck_bitfield_begin(type); short type; kmemcheck_bitfield_end(type); unsigned long flags; struct socket_wq __rcu *wq; struct file *file; struct sock *sk; const struct proto_ops *ops; }; // include/net/sock.h struct socket_alloc { struct socket socket; struct inode vfs_inode; }; // include/linux/fs.h struct inode { umode_t i_mode; // S_IFSOCK | S_IRWXUGO; unsigned short i_opflags; kuid_t i_uid; kgid_t i_gid; unsigned int i_flags; // ... const struct inode_operations *i_op; struct super_block *i_sb; // ... unsigned long i_ino; // sockfs_dname: \"socket:[%lu]\" // ... union { struct hlist_head i_dentry; struct rcu_head i_rcu; }; // ... };","title":"struct socket{}"},{"location":"kernel/data-structures/#socket2","text":"int sys_socket(int family, int type, int protocol) -> struct socket* sock_create(family, type, protocol) -> __sock_create(family, type, protocol) -> struct socket* sock = sock_alloc() -> inode = new_inode_pseudo(super_block of sockfs) // fs/inode.c -> alloc_inode -> sock_alloc_inode (sb->s_op->alloc_inod) -> socket_alloc *ei = kmem_cache_alloc(sock_inode_cachep) // 306B -> socket_wq *wq = kmalloc(sizeof(*wq)) // 24B ei->socket.wq = wq; ei->socket.state = SS_UNCONNECTED; -> inode_init_always sock = SOCKET_I(inode); inode->i_op = &sockfs_inode_ops; // .listxattr = sockfs_listxattr, -> net_families[family]->create(sock, protocol) -> inet_create(sock, protocol) // net/ipv4/af_inet.c -> sock_map_fd() -> get_unused_fd_flags -> sock_alloc_file -> d_alloc_pseudo // sizeof(struct dentry) == 128 -> file = alloc_file(..., &socket_file_ops); // sizeof(struct file) == 140 -> get_empty_filp file.f_op = &socket_file_ops sock->file = file; file->private_data = sock; -> fd_install inet_create(sock, protocol) -> find inet_protosw for sock->type & protocol -> struct sock* sk = sk_alloc() -> sk_prot_alloc -> kmem_cache_alloc (tcp_prot is 1360B) -> sock_init_data sk->sk_socket = sock; sock->sk = sk; -> sk->sk_prot->init(sk) -> tcp_v4_init_sock -> tcp_init_sock -> tcp_init_xmit_timers -> tcp_prequeue_init -> tcp_enable_early_retrans -> tcp_assign_congestion_control sk->sk_state = TCP_CLOSE; icsk->icsk_af_ops = &ipv4_specific; After socket()","title":"socket(2)"},{"location":"kernel/data-structures/#memory-usage","text":"On x86-64 Deiban 8, Linux 3.16, /proc/slabinfo struct size slab cache name file 256 \"filp\" dentry 192 \"dentry\" socket_alloc 640 \"sock_inode_cache\" tcp_sock 1792 \"TCP\" socket_wq 64 \"kmalloc-64\" inet_bind_bucket 64 \"tcp_bind_bucket\" tcp_request_sock 256 \"request_sock_TCP\" inet_timewait_sock 192 \"tw_sock_TCP\" epitem 128 \"eventpoll_epi\" Total : 2944 bytes/socket, not including send/receive buffers. For client sockets, +64B for inet_bind_bucket .","title":"Memory usage"},{"location":"kernel/data-structures/#net_proto_family","text":"family type protocol AF_UNIX=1 SOCK_STREAM=1 0 AF_UNIX SOCK_DGRAM=2 0 AF_INET=2 SOCK_STREAM IPPROTO_TCP=6 AF_INET SOCK_DGRAM IPPROTO_UDP=17 AF_INET SOCK_DGRAM IPPROTO_ICMP=1 AF_INET SOCK_RAW=3 IPPROTO_IP=0 NPROTO=AF_MAX=41 SOCK_MAX=11 no max? // include/linux/net.h // How to create a socket for an address family struct net_proto_family { int family; // AF_INET, AF_UNIX, AF_INET6, etc. must: 0 <= family < NPROTO int (*create)(struct net *net, struct socket *sock, int protocol, int kern); struct module *owner; }; // net/socket.c static const struct net_proto_family *net_families[NPROTO]; // net/ipv4/af_inet.c static int inet_create(struct net *net, struct socket *sock, int protocol, int kern); static const struct net_proto_family inet_family_ops = { .family = PF_INET, .create = inet_create, .owner = THIS_MODULE }; // inet_init() calls sock_register(): net_families[AF_INET] = &inet_family_ops;","title":"net_proto_family"},{"location":"kernel/data-structures/#inet_protosw","text":"// include/net/protocol.h /* This is used to register socket interfaces for IP protocols. */ struct inet_protosw { struct list_head list; /* These two fields form the lookup key. */ unsigned short type; /* This is the 2nd argument to socket(2). eg. SOCK_STREAM, SOCK_DGRAM */ unsigned short protocol; /* This is the L4 protocol number. eg. IPPROTO_TCP, IPPROTO_TCP */ struct proto *prot; const struct proto_ops *ops; unsigned char flags; /* See INET_PROTOSW_* below. */ }; #define INET_PROTOSW_REUSE 0x01 /* Are ports automatically reusable? */ #define INET_PROTOSW_PERMANENT 0x02 /* Permanent protocols are unremovable. */ #define INET_PROTOSW_ICSK 0x04 /* Is this an inet_connection_sock? */ // net/ipv4/af_inet.c /* The inetsw table contains everything that inet_create needs to * build a new socket. */ static struct list_head inetsw[SOCK_MAX]; static DEFINE_SPINLOCK(inetsw_lock); /* Upon startup we insert all the elements in inetsw_array[] into * the linked list inetsw. */ static struct inet_protosw inetsw_array[] = { { .type = SOCK_STREAM, .protocol = IPPROTO_TCP, .prot = &tcp_prot, .ops = &inet_stream_ops, .flags = INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK, }, { .type = SOCK_DGRAM, .protocol = IPPROTO_UDP, .prot = &udp_prot, .ops = &inet_dgram_ops, .flags = INET_PROTOSW_PERMANENT, }, { .type = SOCK_DGRAM, .protocol = IPPROTO_ICMP, .prot = &ping_prot, .ops = &inet_dgram_ops, .flags = INET_PROTOSW_REUSE, }, { .type = SOCK_RAW, .protocol = IPPROTO_IP, /* wild card */ .prot = &raw_prot, .ops = &inet_sockraw_ops, .flags = INET_PROTOSW_REUSE, } }; #define INETSW_ARRAY_LEN ARRAY_SIZE(inetsw_array) // inet_init() sock_register(&inet_family_ops); /* Register the socket-side information for inet_create. */ for (struct list_head *r = &inetsw[0]; r < &inetsw[SOCK_MAX]; ++r) INIT_LIST_HEAD(r); for (struct inet_protosw *q = inetsw_array; q < &inetsw_array[INETSW_ARRAY_LEN]; ++q) inet_register_protosw(q); After Initialization:","title":"inet_protosw"},{"location":"kernel/data-structures/#skbuff","text":"A sample of receive skb for TCP SYN segment:","title":"skbuff"},{"location":"kernel/epoll/","text":"EPOLL(7) data structures After epoll_create() After epoll_ctl(ADD, socketfd) pipe()","title":"Epoll"},{"location":"kernel/epoll/#epoll7-data-structures","text":"","title":"EPOLL(7) data structures"},{"location":"kernel/epoll/#after-epoll_create","text":"","title":"After epoll_create()"},{"location":"kernel/epoll/#after-epoll_ctladd-socketfd","text":"","title":"After epoll_ctl(ADD, socketfd)"},{"location":"kernel/epoll/#pipe","text":"","title":"pipe()"},{"location":"kernel/eventpoll/","text":"epoll Data structures eventpoll{} epitem{} eppoll_entry epoll_create() epoll_create1(flags) CHECK(only valid flags is O_CLOEXEC) struct eventpool* ep = ep_alloc(); int fd = get_unused_fd_flags() -> __alloc_fd fd = find_next_fd() __set_open_fd(fd, fdt) struct file* file = anon_inode_getfile(name, fops, ep) path.dentry = d_alloc_pseudo() path.mnt = mntget() d_instantiate(path.dentry) file = alloc_file(&path, flags, fops) file->private_data = ep ep->file = file fd_install(fd, file) return fd close() close(fd) -> __close_fd(current->files, fd) struct fdtable* fdt = files_fdtable(files) struct file* file = fdt->fd[fd] fdt->fd[fd] = NULL -> __put_unused_fd(files, fd) -> __clear_open_fd(fd, fdt) // clear bit masks -> filp_close(file, files) -> fput(file) if (file_count(file) == 0) return 0 if (--file->f_count == 0) __fput(file) // delayed -> file->f_op->release(inode, file) struct eventpoll *ep = file->private_data if (ep) ep_free(ep) -> ep_remove(ep, epi) -> epi_rcu_free epoll_ctl(ADD/DEL/MOD) epoll_ctl(epfd, op, fd event) f = fdget(epfd) // epoll itself tf = fdget(fd) // target eventpoll* ep = f.file->private_data if (ADD) -> ep_look_check(ep, tf.file) epitem* epi = ep_find(ep, tf.file, fd) if (ADD && epi == NULL) -> ep_insert(ep, event, tf.file, fd, ) if (DEL && epi != NULL) -> ep_remove(ep, epi) if (MOD && epi != NULL && !(event & EXCLUSIVE)) -> ep_modify(ep, epi, event) ep_insert -> ep_insert ep_remove -> ep_remove ep_modify -> ep_modify epoll_wait()","title":"epoll"},{"location":"kernel/eventpoll/#epoll","text":"","title":"epoll"},{"location":"kernel/eventpoll/#data-structures","text":"","title":"Data structures"},{"location":"kernel/eventpoll/#eventpoll","text":"","title":"eventpoll{}"},{"location":"kernel/eventpoll/#epitem","text":"","title":"epitem{}"},{"location":"kernel/eventpoll/#eppoll_entry","text":"","title":"eppoll_entry"},{"location":"kernel/eventpoll/#epoll_create","text":"epoll_create1(flags) CHECK(only valid flags is O_CLOEXEC) struct eventpool* ep = ep_alloc(); int fd = get_unused_fd_flags() -> __alloc_fd fd = find_next_fd() __set_open_fd(fd, fdt) struct file* file = anon_inode_getfile(name, fops, ep) path.dentry = d_alloc_pseudo() path.mnt = mntget() d_instantiate(path.dentry) file = alloc_file(&path, flags, fops) file->private_data = ep ep->file = file fd_install(fd, file) return fd","title":"epoll_create()"},{"location":"kernel/eventpoll/#close","text":"close(fd) -> __close_fd(current->files, fd) struct fdtable* fdt = files_fdtable(files) struct file* file = fdt->fd[fd] fdt->fd[fd] = NULL -> __put_unused_fd(files, fd) -> __clear_open_fd(fd, fdt) // clear bit masks -> filp_close(file, files) -> fput(file) if (file_count(file) == 0) return 0 if (--file->f_count == 0) __fput(file) // delayed -> file->f_op->release(inode, file) struct eventpoll *ep = file->private_data if (ep) ep_free(ep) -> ep_remove(ep, epi) -> epi_rcu_free","title":"close()"},{"location":"kernel/eventpoll/#epoll_ctladddelmod","text":"epoll_ctl(epfd, op, fd event) f = fdget(epfd) // epoll itself tf = fdget(fd) // target eventpoll* ep = f.file->private_data if (ADD) -> ep_look_check(ep, tf.file) epitem* epi = ep_find(ep, tf.file, fd) if (ADD && epi == NULL) -> ep_insert(ep, event, tf.file, fd, ) if (DEL && epi != NULL) -> ep_remove(ep, epi) if (MOD && epi != NULL && !(event & EXCLUSIVE)) -> ep_modify(ep, epi, event)","title":"epoll_ctl(ADD/DEL/MOD)"},{"location":"kernel/eventpoll/#ep_insert","text":"-> ep_insert","title":"ep_insert"},{"location":"kernel/eventpoll/#ep_remove","text":"-> ep_remove","title":"ep_remove"},{"location":"kernel/eventpoll/#ep_modify","text":"-> ep_modify","title":"ep_modify"},{"location":"kernel/eventpoll/#epoll_wait","text":"","title":"epoll_wait()"},{"location":"kernel/file-descriptor-table/","text":"Evolution of File Descriptor Table in Linux Kernel 0.01 to 1.1.10 A fixed length array in struct task_struct . // include/linux/sched.h of linux-1.1.10 struct task_struct { // ... struct file * filp[NR_OPEN]; fd_set close_on_exec; // ... }; Note 1: file_table and inode_table were made dynamic in 0.99.10. Version NR_OPEN NR_FILE NR_INODE 0.01 20 64 32 0.12 20 64 64 0.95 20 64 128 0.96a-patch3 32 64 128 0.96c-patch1 32 128 128 0.96pre 32 64 128 0.97 32 128 128 0.98.4 256 128 128 0.99.10 256 1024 2048 // fs/file_table.c of linux-0.99.10 -struct file file_table[NR_FILE]; +struct file * first_file; Note 2: ext2 file system was added 0.99.7. 1.1.11 to 1.3.21 Split into struct files_struct . 1.1.11 was released in 1995/05. // include/linux/sched.h of linux-1.3.21 struct files_struct { int count; fd_set close_on_exec; struct file * fd[NR_OPEN]; }; struct task_struct { // ... /* filesystem information */ struct fs_struct fs[1]; /* open file information */ struct files_struct files[1]; /* memory management info */ struct mm_struct mm[1]; // ... }; 1.3.22 to 2.1.89 Change files from a struct[1] to a pointer, so it can be shared by threads within a process. 1.3.22 was released in 1995/09. LinuxThreads needs 2.0 kernel, which was released in 1996/07. // include/linux/sched.h of linux-2.0.2 /* Open file table structure */ struct files_struct { int count; fd_set close_on_exec; fd_set open_fds; struct file * fd[NR_OPEN]; }; struct task_struct { // ... /* filesystem information */ - struct fs_struct fs[1]; + struct fs_struct *fs; /* open file information */ - struct files_struct files[1]; + struct files_struct *files; /* memory management info */ - struct mm_struct mm[1]; + struct mm_struct *mm; // ... }; 2.1.90 to 2.6.13 Change fixed-length array fd to dynamic array. 2.2.0 was released in 1999/01. // include/linux/sched.h of linux-2.2.0 /* * Open file table structure */ struct files_struct { atomic_t count; + int max_fds; + struct file ** fd; /* current fd array */ fd_set close_on_exec; // changed to fd_set* in 2.2.12 fd_set open_fds; - struct file * fd[NR_OPEN]; }; struct task_struct { // ... /* open file information */ struct files_struct *files; // ... }; 2.6.14 to now (4.15.7) Introduce struct fdtable for RCU. 2.6.15 was released in 2006/01, Ubuntu 6.04 LTS and Debian 4 ship it. // include/linux/fdtable.h of linux-2.6.37 struct fdtable { unsigned int max_fds; struct file __rcu **fd; /* current fd array */ fd_set *close_on_exec; fd_set *open_fds; struct rcu_head rcu; struct fdtable *next; }; /* * Open file table structure */ struct files_struct { /* * read mostly part */ atomic_t count; struct fdtable __rcu *fdt; struct fdtable fdtab; /* * written part on a separate cache line in SMP */ spinlock_t file_lock ____cacheline_aligned_in_smp; int next_fd; struct embedded_fd_set close_on_exec_init; struct embedded_fd_set open_fds_init; struct file __rcu * fd_array[NR_OPEN_DEFAULT]; }; struct task_struct { // ... /* open file information */ struct files_struct *files; // ... }; struct file itself. // include/linux/fs.h of linux-4.9 struct file { union { struct llist_node fu_llist; struct rcu_head fu_rcuhead; } f_u; struct path f_path; struct inode *f_inode; /* cached value */ // added back in 3.9, same as f_path.dentry->d_inode const struct file_operations *f_op; /* * Protects f_ep_links, f_flags. * Must not be taken from IRQ context. */ spinlock_t f_lock; atomic_long_t f_count; unsigned int f_flags; fmode_t f_mode; struct mutex f_pos_lock; // Fixed in 3.14 loff_t f_pos; struct fown_struct f_owner; const struct cred *f_cred; struct file_ra_state f_ra; u64 f_version; #ifdef CONFIG_SECURITY void *f_security; #endif /* needed for tty driver, and maybe others */ void *private_data; #ifdef CONFIG_EPOLL /* Used by fs/eventpoll.c to link all the hooks to this file */ struct list_head f_ep_links; struct list_head f_tfile_llink; #endif /* #ifdef CONFIG_EPOLL */ struct address_space *f_mapping; } __attribute__((aligned(4))); /* lest something weird decides that 2 is OK */ FreeBSD up to 9.3 4.3BSD-Reno and older BSDes use fixed-length array of struct file* . struct user { // ... struct file *u_ofile[NOFILE]; /* file structures for open files */ // ... }; From BSD Net/2 up to FreeBSD 9.3 use a similiar dynamic array data structure of Linux 2.0 (see diagram above.), where proc == task_struct , filedesc == files_struct , file == file . // sys/proc.h /* * Process structure. */ struct proc { // ... struct filedesc *p_fd; /* (b) Open files. */ // ... }; // sys/filedesc.h struct filedesc { struct file **fd_ofiles; /* file structures for open files */ char *fd_ofileflags; /* per-process open file flags */ struct vnode *fd_cdir; /* current directory */ struct vnode *fd_rdir; /* root directory */ struct vnode *fd_jdir; /* jail root directory */ int fd_nfiles; /* number of open files allocated */ NDSLOTTYPE *fd_map; /* bitmap of free fds */ int fd_lastfile; /* high-water mark of fd_ofiles */ int fd_freefile; /* approx. next free file */ u_short fd_cmask; /* mask for file creation */ u_short fd_refcnt; /* thread reference count */ u_short fd_holdcnt; /* hold count on structure + mutex */ struct sx fd_sx; /* protects members of this struct */ struct kqlist fd_kqlist; /* list of kqueues on this filedesc */ int fd_holdleaderscount; /* block fdfree() for shared close() */ int fd_holdleaderswakeup; /* fdfree() needs wakeup */ }; // sys/file.h struct file { void *f_data; /* file descriptor specific data */ struct fileops *f_ops; /* File operations */ struct ucred *f_cred; /* associated credentials. */ struct vnode *f_vnode; /* NULL or applicable vnode */ short f_type; /* descriptor type */ short f_vnread_flags; /* (f) Sleep lock for f_offset */ volatile u_int f_flag; /* see fcntl.h */ volatile u_int f_count; /* reference count */ // ... off_t f_offset; // ... };","title":"File Descriptor Table"},{"location":"kernel/file-descriptor-table/#evolution-of-file-descriptor-table-in-linux-kernel","text":"","title":"Evolution of File Descriptor Table in Linux Kernel"},{"location":"kernel/file-descriptor-table/#001-to-1110","text":"A fixed length array in struct task_struct . // include/linux/sched.h of linux-1.1.10 struct task_struct { // ... struct file * filp[NR_OPEN]; fd_set close_on_exec; // ... }; Note 1: file_table and inode_table were made dynamic in 0.99.10. Version NR_OPEN NR_FILE NR_INODE 0.01 20 64 32 0.12 20 64 64 0.95 20 64 128 0.96a-patch3 32 64 128 0.96c-patch1 32 128 128 0.96pre 32 64 128 0.97 32 128 128 0.98.4 256 128 128 0.99.10 256 1024 2048 // fs/file_table.c of linux-0.99.10 -struct file file_table[NR_FILE]; +struct file * first_file; Note 2: ext2 file system was added 0.99.7.","title":"0.01 to 1.1.10"},{"location":"kernel/file-descriptor-table/#1111-to-1321","text":"Split into struct files_struct . 1.1.11 was released in 1995/05. // include/linux/sched.h of linux-1.3.21 struct files_struct { int count; fd_set close_on_exec; struct file * fd[NR_OPEN]; }; struct task_struct { // ... /* filesystem information */ struct fs_struct fs[1]; /* open file information */ struct files_struct files[1]; /* memory management info */ struct mm_struct mm[1]; // ... };","title":"1.1.11 to 1.3.21"},{"location":"kernel/file-descriptor-table/#1322-to-2189","text":"Change files from a struct[1] to a pointer, so it can be shared by threads within a process. 1.3.22 was released in 1995/09. LinuxThreads needs 2.0 kernel, which was released in 1996/07. // include/linux/sched.h of linux-2.0.2 /* Open file table structure */ struct files_struct { int count; fd_set close_on_exec; fd_set open_fds; struct file * fd[NR_OPEN]; }; struct task_struct { // ... /* filesystem information */ - struct fs_struct fs[1]; + struct fs_struct *fs; /* open file information */ - struct files_struct files[1]; + struct files_struct *files; /* memory management info */ - struct mm_struct mm[1]; + struct mm_struct *mm; // ... };","title":"1.3.22 to 2.1.89"},{"location":"kernel/file-descriptor-table/#2190-to-2613","text":"Change fixed-length array fd to dynamic array. 2.2.0 was released in 1999/01. // include/linux/sched.h of linux-2.2.0 /* * Open file table structure */ struct files_struct { atomic_t count; + int max_fds; + struct file ** fd; /* current fd array */ fd_set close_on_exec; // changed to fd_set* in 2.2.12 fd_set open_fds; - struct file * fd[NR_OPEN]; }; struct task_struct { // ... /* open file information */ struct files_struct *files; // ... };","title":"2.1.90 to 2.6.13"},{"location":"kernel/file-descriptor-table/#2614-to-now-4157","text":"Introduce struct fdtable for RCU. 2.6.15 was released in 2006/01, Ubuntu 6.04 LTS and Debian 4 ship it. // include/linux/fdtable.h of linux-2.6.37 struct fdtable { unsigned int max_fds; struct file __rcu **fd; /* current fd array */ fd_set *close_on_exec; fd_set *open_fds; struct rcu_head rcu; struct fdtable *next; }; /* * Open file table structure */ struct files_struct { /* * read mostly part */ atomic_t count; struct fdtable __rcu *fdt; struct fdtable fdtab; /* * written part on a separate cache line in SMP */ spinlock_t file_lock ____cacheline_aligned_in_smp; int next_fd; struct embedded_fd_set close_on_exec_init; struct embedded_fd_set open_fds_init; struct file __rcu * fd_array[NR_OPEN_DEFAULT]; }; struct task_struct { // ... /* open file information */ struct files_struct *files; // ... }; struct file itself. // include/linux/fs.h of linux-4.9 struct file { union { struct llist_node fu_llist; struct rcu_head fu_rcuhead; } f_u; struct path f_path; struct inode *f_inode; /* cached value */ // added back in 3.9, same as f_path.dentry->d_inode const struct file_operations *f_op; /* * Protects f_ep_links, f_flags. * Must not be taken from IRQ context. */ spinlock_t f_lock; atomic_long_t f_count; unsigned int f_flags; fmode_t f_mode; struct mutex f_pos_lock; // Fixed in 3.14 loff_t f_pos; struct fown_struct f_owner; const struct cred *f_cred; struct file_ra_state f_ra; u64 f_version; #ifdef CONFIG_SECURITY void *f_security; #endif /* needed for tty driver, and maybe others */ void *private_data; #ifdef CONFIG_EPOLL /* Used by fs/eventpoll.c to link all the hooks to this file */ struct list_head f_ep_links; struct list_head f_tfile_llink; #endif /* #ifdef CONFIG_EPOLL */ struct address_space *f_mapping; } __attribute__((aligned(4))); /* lest something weird decides that 2 is OK */","title":"2.6.14 to now (4.15.7)"},{"location":"kernel/file-descriptor-table/#freebsd-up-to-93","text":"4.3BSD-Reno and older BSDes use fixed-length array of struct file* . struct user { // ... struct file *u_ofile[NOFILE]; /* file structures for open files */ // ... }; From BSD Net/2 up to FreeBSD 9.3 use a similiar dynamic array data structure of Linux 2.0 (see diagram above.), where proc == task_struct , filedesc == files_struct , file == file . // sys/proc.h /* * Process structure. */ struct proc { // ... struct filedesc *p_fd; /* (b) Open files. */ // ... }; // sys/filedesc.h struct filedesc { struct file **fd_ofiles; /* file structures for open files */ char *fd_ofileflags; /* per-process open file flags */ struct vnode *fd_cdir; /* current directory */ struct vnode *fd_rdir; /* root directory */ struct vnode *fd_jdir; /* jail root directory */ int fd_nfiles; /* number of open files allocated */ NDSLOTTYPE *fd_map; /* bitmap of free fds */ int fd_lastfile; /* high-water mark of fd_ofiles */ int fd_freefile; /* approx. next free file */ u_short fd_cmask; /* mask for file creation */ u_short fd_refcnt; /* thread reference count */ u_short fd_holdcnt; /* hold count on structure + mutex */ struct sx fd_sx; /* protects members of this struct */ struct kqlist fd_kqlist; /* list of kqueues on this filedesc */ int fd_holdleaderscount; /* block fdfree() for shared close() */ int fd_holdleaderswakeup; /* fdfree() needs wakeup */ }; // sys/file.h struct file { void *f_data; /* file descriptor specific data */ struct fileops *f_ops; /* File operations */ struct ucred *f_cred; /* associated credentials. */ struct vnode *f_vnode; /* NULL or applicable vnode */ short f_type; /* descriptor type */ short f_vnread_flags; /* (f) Sleep lock for f_offset */ volatile u_int f_flag; /* see fcntl.h */ volatile u_int f_count; /* reference count */ // ... off_t f_offset; // ... };","title":"FreeBSD up to 9.3"},{"location":"kernel/reuseport/","text":"SO_REUSEPORT Linux 4.5 improves UDP SO_REUSEPORT , Linux 4.6 Improves TCP SO_REUSEPORT .","title":"SO_REUSEPRT"},{"location":"kernel/reuseport/#so_reuseport","text":"Linux 4.5 improves UDP SO_REUSEPORT , Linux 4.6 Improves TCP SO_REUSEPORT .","title":"SO_REUSEPORT"}]}